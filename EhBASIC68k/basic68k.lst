 AS V1.42 Beta [Bld 283] - Source File BASIC68K.ASM - Page 1 - 4/10/2025 21:30:24


    1/       0 :                        	page	0
    2/       0 :                        	CPU	68000
    3/       0 :                        	SUPMODE	ON
    4/       0 :                        ;********************************************************************************
    5/       0 :                        ;										*
    6/       0 :                        ;	Enhanced BASIC for the Motorola MC680xx					*
    7/       0 :                        ;										*
    8/       0 :                        ;	This version is for the TS2 single board computer.			*
    9/       0 :                        ;	Jeff Tranter (tranter@pobox.com)					*
   10/       0 :                        ;										*
   11/       0 :                        ;********************************************************************************
   12/       0 :                        ;    										*
   13/       0 :                        ; Copyright(C) 2002-12 by Lee Davison. This program may be freely distributed 	*
   14/       0 :                        ;	for personal use only. All commercial rights are reserved.		*
   15/       0 :                        ;										*
   16/       0 :                        ;	More 68000 and other projects can be found on my website at ..		*
   17/       0 :                        ;										*
   18/       0 :                        ;	 http://mycorner.no-ip.org/index.html					*
   19/       0 :                        ;										*
   20/       0 :                        ;	mail : leeedavison@googlemail.com					*
   21/       0 :                        ;										*
   22/       0 :                        ;*********************************************************************************
   23/       0 :                        
   24/       0 :                        ; Ver 3.54
   25/       0 :                        
   26/       0 :                        ; Ver 3.54 adds experimental support for LOAD/SAVE using Hobbytronics
   27/       0 :                        ; USB Flash Drive Host Board
   28/       0 :                        ; Ver 3.53 fixes math error that affected exponentiation ("^") and
   29/       0 :                        ;  EXP() function. Thanks to joelang for fix.
   30/       0 :                        ; Ver 3.52 stops USING$() from reading beyond the end of the format string
   31/       0 :                        ; Ver 3.51 fixes the UCASE$() and LCASE$() functions for null strings
   32/       0 :                        ; Ver 3.50 unary minus in concatenate generates a type mismatch error
   33/       0 :                        ; Ver 3.49 doesn't tokenise 'DEF' or 'DEC' within a hex value
   34/       0 :                        ; Ver 3.48 allows scientific notation underflow in the USING$() function
   35/       0 :                        ; Ver 3.47 traps the use of array elements as the FOR loop variable
   36/       0 :                        ; Ver 3.46 updates function and function variable handling
   37/       0 :                        
   38/       0 :                        ;************************************************************************************
   39/       0 :                        ;
   40/       0 :                        ; Ver 3.45 makes the handling of non existant variables consistent and gives the
   41/       0 :                        ; option of not returning an error for a non existant variable. If this is the
   42/       0 :                        ; behaviour you want just change novar to some non zero value
   43/       0 :                        
   44/       0 : =$0                    novar		EQU	0					; non existant variables cause errors
   45/       0 :                        
   46/       0 :                        ; Set the symbol FLASH_SUPPORT to 1 if you want to enable experimental
   47/       0 :                        ; support for LOAD/SAVE using a Hobbytronics USB Flash Drive Host
   48/       0 :                        ; Board.
   49/       0 :                        
   50/       0 : =$0                    FLASH_SUPPORT   EQU     0
   51/       0 :                        
   52/       0 :                        ;************************************************************************************
   53/       0 :                        
   54/       0 :                        ; Ver 3.44 adds overflow indication to the USING$() function
   55/       0 :                        ; Ver 3.43 removes an undocumented feature of concatenating null strings
   56/       0 :                        ; Ver 3.42 reimplements backspace so that characters are overwritten with [SPACE]
   57/       0 :                        ; Ver 3.41 removes undocumented features of the USING$() function
   58/       0 :                        ; Ver 3.40 adds the USING$() function
   59/       0 :                        ; Ver 3.33 adds the file requester to LOAD and SAVE
   60/       0 :                        ; Ver 3.32 adds the optional ELSE clause to IF .. THEN
   61/       0 :                        
   62/       0 :                        ;************************************************************************************
   63/       0 :                        ;
   64/       0 :                        ; Version 3.25 adds the option to change the behaviour of INPUT so that a null
   65/       0 :                        ; response does not cause a program break. If this is the behaviour you want just
   66/       0 :                        ; change nobrk to some non zero value.
   67/       0 :                        
   68/       0 : =$0                    nobrk		EQU	0					; null response to INPUT causes a break
   69/       0 :                        
   70/       0 :                        
   71/       0 :                        ;************************************************************************************
   72/       0 :                        ;
   73/       0 :                        ; Version 3.xx replaces the fixed RAM addressing from previous versions with a RAM
   74/       0 :                        ; pointer in a3. this means that this could now be run as a task on a multitasking
   75/       0 :                        ; system where memory resources may change.
   76/       0 :                        
   77/       0 :                        
   78/       0 :                        ;************************************************************************************
   79/       0 :                        
   80/       0 :                        
   81/       0 : =$0                    value_off	equ	0
   82/       0 :                        
   83/       0 :                        	org	value_off
   84/       0 :                        
   85/       0 :                        	ds.l	$100		; allow 1K for the stack, this should be plenty
   86/     400 :                        								; for any BASIC program that doesn't do something
   87/     400 :                        								; silly, it could even be much less.
   88/     400 :                        ram_base
   89/     400 :                        LAB_WARM	ds.w	1			; BASIC warm start entry point
   90/     402 :                        Wrmjpv		ds.l	1			; BASIC warm start jump vector
   91/     406 :                        
   92/     406 :                        Usrjmp		ds.w	1			; USR function JMP address
   93/     408 :                        Usrjpv		ds.l	1			; USR function JMP vector
   94/     40C :                        
   95/     40C :                        ; system dependant i/o vectors
   96/     40C :                        ; these are in RAM and are set at start-up
   97/     40C :                        
   98/     40C :                        V_INPT		ds.w	1			; non halting scan input device entry point
   99/     40E :                        V_INPTv		ds.l	1			; non halting scan input device jump vector
  100/     412 :                        
  101/     412 :                        V_OUTP		ds.w	1			; send byte to output device entry point
  102/     414 :                        V_OUTPv		ds.l	1			; send byte to output device jump vector
  103/     418 :                        
  104/     418 :                        V_LOAD		ds.w	1			; load BASIC program entry point
  105/     41A :                        V_LOADv		ds.l	1			; load BASIC program jump vector
  106/     41E :                        
  107/     41E :                        V_SAVE		ds.w	1			; save BASIC program entry point
  108/     420 :                        V_SAVEv		ds.l	1			; save BASIC program jump vector
  109/     424 :                        
  110/     424 :                        V_CTLC		ds.w	1			; save CTRL-C check entry point
  111/     426 :                        V_CTLCv		ds.l	1			; save CTRL-C check jump vector
  112/     42A :                        
  113/     42A :                        Itemp		ds.l	1			; temporary integer	(for GOTO etc)
  114/     42E :                        
  115/     42E :                        Smeml		ds.l	1			; start of memory		(start of program)
  116/     432 :                        
  117/     432 :                        ; the program is stored as a series of lines each line having the following format
  118/     432 :                        ;
  119/     432 :                        ;		ds.l	1			; pointer to the next line or $00000000 if [EOT]
  120/     432 :                        ;		ds.l	1			; line number
  121/     432 :                        ;		ds.b	n			; program bytes
  122/     432 :                        ;		dc.b	$00			; [EOL] marker, there will be a second $00 byte, if
  123/     432 :                        ;						; needed, to pad the line to an even number of bytes
  124/     432 :                        
  125/     432 :                        Sfncl		ds.l	1			; start of functions	(end of Program)
  126/     436 :                        
  127/     436 :                        ; the functions are stored as function name, function execute pointer and function
  128/     436 :                        ; variable name
  129/     436 :                        ;
  130/     436 :                        ;		ds.l	1			; name
  131/     436 :                        ;		ds.l	1			; execute pointer
  132/     436 :                        ;		ds.l	1			; function variable
  133/     436 :                        
  134/     436 :                        Svarl		ds.l	1			; start of variables	(end of functions)
  135/     43A :                        
  136/     43A :                        ; the variables are stored as variable name, variable value
  137/     43A :                        ;
  138/     43A :                        ;		ds.l	1			; name
  139/     43A :                        ;		ds.l	1			; packed float or integer value
  140/     43A :                        
  141/     43A :                        Sstrl		ds.l	1			; start of strings	(end of variables)
  142/     43E :                        
  143/     43E :                        ; the strings are stored as string name, string pointer and string length
  144/     43E :                        ;
  145/     43E :                        ;		ds.l	1			; name
  146/     43E :                        ;		ds.l	1			; string pointer
  147/     43E :                        ;		ds.w	1			; string length
  148/     43E :                        
  149/     43E :                        Sarryl		ds.l	1			; start of arrays		(end of strings)
  150/     442 :                        
  151/     442 :                        ; the arrays are stored as array name, array size, array dimensions count, array
  152/     442 :                        ; dimensions upper bounds and array elements
  153/     442 :                        ;
  154/     442 :                        ;		ds.l	1			; name
  155/     442 :                        ;		ds.l	1			; size including this header
  156/     442 :                        ;		ds.w	1			; dimensions count
  157/     442 :                        ;		ds.w	1			; 1st dimension upper bound
  158/     442 :                        ;		ds.w	1			; 2nd dimension upper bound
  159/     442 :                        ;		...				; ...
  160/     442 :                        ;		ds.w	1			; nth dimension upper bound
  161/     442 :                        ;
  162/     442 :                        ; then (i1+1)*(i2+1)...*(in+1) of either ..
  163/     442 :                        ;
  164/     442 :                        ;		ds.l	1			; packed float or integer value
  165/     442 :                        ;
  166/     442 :                        ; .. if float or integer, or ..
  167/     442 :                        ;
  168/     442 :                        ;		ds.l	1			; string pointer
  169/     442 :                        ;		ds.w	1			; string length
  170/     442 :                        ;
  171/     442 :                        ; .. if string
  172/     442 :                        
  173/     442 :                        Earryl		ds.l	1			; end of arrays		(start of free mem)
  174/     446 :                        Sstorl		ds.l	1			; string storage		(moving down)
  175/     44A :                        Ememl		ds.l	1			; end of memory		(upper bound of RAM)
  176/     44E :                        Sutill		ds.l	1			; string utility ptr
  177/     452 :                        Clinel		ds.l	1			; current line		(Basic line number)
  178/     456 :                        Blinel		ds.l	1			; break line		(Basic line number)
  179/     45A :                        
  180/     45A :                        Cpntrl		ds.l	1			; continue pointer
  181/     45E :                        Dlinel		ds.l	1			; current DATA line
  182/     462 :                        Dptrl		ds.l	1			; DATA pointer
  183/     466 :                        Rdptrl		ds.l	1			; read pointer
  184/     46A :                        Varname		ds.l	1			; current var name
  185/     46E :                        Cvaral		ds.l	1			; current var address
  186/     472 :                        Lvarpl		ds.l	1			; variable pointer for LET and FOR/NEXT
  187/     476 :                        
  188/     476 :                        des_sk_e	ds.l	6			; descriptor stack end address
  189/     48E :                        des_sk							; descriptor stack start address
  190/     48E :                        								; use a4 for the descriptor pointer
  191/     48E :                        			ds.w	1			
  192/     490 :                        Ibuffs		ds.l	$40			; start of input buffer
  193/     590 :                        Ibuffe
  194/     590 :                        								; end of input buffer
  195/     590 :                        
  196/     590 :                        FAC1_m		ds.l	1			; FAC1 mantissa1
  197/     594 :                        FAC1_e		ds.w	1			; FAC1 exponent
  198/     596 : =$595                  FAC1_s		EQU	FAC1_e+1		; FAC1 sign (b7)
  199/     596 :                        			ds.w	1			
  200/     598 :                        
  201/     598 :                        FAC2_m		ds.l	1			; FAC2 mantissa1
  202/     59C :                        FAC2_e		ds.l	1			; FAC2 exponent
  203/     5A0 : =$59D                  FAC2_s		EQU	FAC2_e+1		; FAC2 sign (b7)
  204/     5A0 : =$59E                  FAC_sc		EQU	FAC2_e+2		; FAC sign comparison, Acc#1 vs #2
  205/     5A0 : =$59F                  flag		EQU	FAC2_e+3		; flag byte for divide routine
  206/     5A0 :                        
  207/     5A0 :                        PRNlword	ds.l	1			; PRNG seed long word
  208/     5A4 :                        
  209/     5A4 :                        ut1_pl		ds.l	1			; utility pointer 1
  210/     5A8 :                        
  211/     5A8 :                        Asptl		ds.l	1			; array size/pointer
  212/     5AC :                        Astrtl		ds.l	1			; array start pointer
  213/     5B0 :                        
  214/     5B0 : =$5AC                  numexp		EQU	Astrtl			; string to float number exponent count
  215/     5B0 : =$5AD                  expcnt		EQU	Astrtl+1		; string to float exponent count
  216/     5B0 :                        
  217/     5B0 : =$5AF                  expneg		EQU	Astrtl+3		; string to float eval exponent -ve flag
  218/     5B0 :                        
  219/     5B0 :                        func_l		ds.l	1			; function pointer
  220/     5B4 :                        
  221/     5B4 :                        
  222/     5B4 :                        								; these two need to be a word aligned pair !
  223/     5B4 :                        Defdim		ds.w	1			; default DIM flag
  224/     5B6 : =$5B4                  cosout		EQU	Defdim			; flag which CORDIC output (re-use byte)
  225/     5B6 : =$5B5                  Dtypef		EQU	Defdim+1		; data type flag, $80=string, $40=integer, $00=float
  226/     5B6 :                        
  227/     5B6 :                        
  228/     5B6 :                        Binss		ds.l	4			; number to bin string start (32 chrs)
  229/     5C6 :                        
  230/     5C6 :                        Decss		ds.l	1			; number to decimal string start (16 chrs)
  231/     5CA :                        			ds.w	1
  232/     5CC :                        Usdss		ds.w	1			; unsigned decimal string start (10 chrs)
  233/     5CE :                        
  234/     5CE :                        Hexss		ds.l	2			; number to hex string start (8 chrs)
  235/     5D6 :                        
  236/     5D6 :                        BHsend		ds.w	1			; bin/decimal/hex string end
  237/     5D8 :                        
  238/     5D8 :                        
  239/     5D8 :                        prstk		ds.b	1			; stacked function index
  240/     5D9 :                        
  241/     5D9 :                        tpower		ds.b	1			; remember CORDIC power
  242/     5DA :                        
  243/     5DA :                        Asrch		ds.b	1			; scan-between-quotes flag, alt search character
  244/     5DB :                        
  245/     5DB :                        Dimcnt		ds.b	1			; # of dimensions
  246/     5DC :                        
  247/     5DC :                        Breakf		ds.b	1			; break flag, $00=END else=break
  248/     5DD :                        Oquote		ds.b	1			; open quote flag (Flag: DATA; LIST; memory)
  249/     5DE :                        Gclctd		ds.b	1			; garbage collected flag
  250/     5DF :                        Sufnxf		ds.b	1			; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
  251/     5E0 :                        Imode		ds.b	1			; input mode flag, $00=INPUT, $98=READ
  252/     5E1 :                        
  253/     5E1 :                        Cflag		ds.b	1			; comparison evaluation flag
  254/     5E2 :                        
  255/     5E2 :                        TabSiz		ds.b	1			; TAB step size
  256/     5E3 :                        
  257/     5E3 :                        comp_f		ds.b	1			; compare function flag, bits 0,1 and 2 used
  258/     5E4 :                        								; bit 2 set if >
  259/     5E4 :                        								; bit 1 set if =
  260/     5E4 :                        								; bit 0 set if <
  261/     5E4 :                        
  262/     5E4 :                        Nullct		ds.b	1			; nulls output after each line
  263/     5E5 :                        TPos		ds.b	1			; BASIC terminal position byte
  264/     5E6 :                        TWidth		ds.b	1			; BASIC terminal width byte
  265/     5E7 :                        Iclim		ds.b	1			; input column limit
  266/     5E8 :                        ccflag		ds.b	1			; CTRL-C check flag
  267/     5E9 :                        ccbyte		ds.b	1			; CTRL-C last received byte
  268/     5EA :                        ccnull		ds.b	1			; CTRL-C last received byte 'life' timer
  269/     5EB :                        
  270/     5EB :                        WORK_E:
  271/     5EB : =$600                  work_end:	EQU	(WORK_E+$100) & $ffffff00
  272/     5EB :                        
  273/     5EB : =$600                  prg_strt:	equ	work_end
  274/     5EB :                        
  275/     5EB :                        ;;;
  276/     5EB :                        ;;; Memory
  277/     5EB :                        ;;;
  278/     5EB :                        
  279/     5EB : =$0                    VECT_T:	EQU	$00000000
  280/     5EB : =$400                  PROG_B:	EQU	$00000400
  281/     5EB : =$100                  SHAD_M: EQU	$00000100	;PIC <-> 68008 Shared Memory
  282/     5EB :                        
  283/     5EB :                        
  284/     5EB :                        
  285/       0 :                        	ORG	VECT_T
  286/       0 :                        
  287/       0 :                        INIVEC:
  288/       0 :                        	;; 0-7
  289/       0 : 0000 3F00              	DC.L	ram_strt+ram_base	; Reset: Initial SSP
  290/       4 : 0000 0550              	DC.L	code_start		; Reset: Initial PC
  291/       8 :                        
  292/       8 : 0000 0486              	DC.L	DUMMY_H		; Bus Error
  293/       C : 0000 0486              	DC.L	DUMMY_H		; Address Error
  294/      10 :                        
  295/      10 : 0000 0486              	DC.L	DUMMY_H		; Illegal Instruction
  296/      14 : 0000 0486              	DC.L	DUMMY_H		; Zero Divide
  297/      18 : 0000 0486              	DC.L	DUMMY_H		; CHK Instruction
  298/      1C : 0000 0486              	DC.L	DUMMY_H		; TRAPV Instruction
  299/      20 :                        
  300/      20 :                        	;; 8-15
  301/      20 : 0000 0486              	DC.L	DUMMY_H		; Privilege Violation
  302/      24 : 0000 0486              	DC.L	DUMMY_H		; Trace
  303/      28 : 0000 0486              	DC.L	DUMMY_H		; Line 1010 Emulator
  304/      2C : 0000 0486              	DC.L	DUMMY_H		; Line 1111 Emulator
  305/      30 :                        
  306/      30 : 0000 0486              	DC.L	DUMMY_H		; (Unassigned, reserved)
  307/      34 : 0000 0486              	DC.L	DUMMY_H		; (Unassigned, reserved)
  308/      38 : 0000 0486              	DC.L	DUMMY_H		; Format Error (MC68010)
  309/      3C : 0000 0486              	DC.L	DUMMY_H		; (Unassigned, reserved)
  310/      40 :                        
  311/      40 :                        	;; 16-23
  312/      40 : 0000 0486              	DC.L	DUMMY_H		; (Unassigned, reserved)
  313/      44 : 0000 0486              	DC.L	DUMMY_H		; (Unassigned, reserved)
  314/      48 : 0000 0486              	DC.L	DUMMY_H		; (Unassigned, reserved)
  315/      4C : 0000 0486              	DC.L	DUMMY_H		; (Unassigned, reserved)
  316/      50 :                        
  317/      50 : 0000 0486              	DC.L	DUMMY_H		; (Unassigned, reserved)
  318/      54 : 0000 0486              	DC.L	DUMMY_H		; (Unassigned, reserved)
  319/      58 : 0000 0486              	DC.L	DUMMY_H		; (Unassigned, reserved)
  320/      5C : 0000 0486              	DC.L	DUMMY_H		; (Unassigned, reserved)
  321/      60 :                        
  322/      60 :                        	;; 24-31
  323/      60 : 0000 0486              	DC.L	DUMMY_H		; Spurious Interrupt
  324/      64 : 0000 0486              	DC.L	DUMMY_H		; Level 1 Interrupt Autovector
  325/      68 : 0000 0486              	DC.L	DUMMY_H		; Level 2 Interrupt Autovector
  326/      6C : 0000 0486              	DC.L	DUMMY_H		; Level 3 Interrupt Autovector
  327/      70 :                        
  328/      70 : 0000 0486              	DC.L	DUMMY_H		; Level 4 Interrupt Autovector
  329/      74 : 0000 0400              	DC.L	IRQ5_H		; Level 5 Interrupt Autovector
  330/      78 : 0000 0486              	DC.L	DUMMY_H		; Level 6 Interrupt Autovector
  331/      7C : 0000 0488              	DC.L	NMI_H		; Level 7 Interrupt Autovector
  332/      80 :                        
  333/      80 :                        	;; 32-39
  334/      80 : 0000 0486              	DC.L	DUMMY_H		; TRAP Instruction Vector #0
  335/      84 : 0000 0486              	DC.L	DUMMY_H		; TRAP Instruction Vector #1
  336/      88 : 0000 0486              	DC.L	DUMMY_H		; TRAP Instruction Vector #2
  337/      8C : 0000 0486              	DC.L	DUMMY_H		; TRAP Instruction Vector #3
  338/      90 :                        
  339/      90 : 0000 0486              	DC.L	DUMMY_H		; TRAP Instruction Vector #4
  340/      94 : 0000 0486              	DC.L	DUMMY_H		; TRAP Instruction Vector #5
  341/      98 : 0000 0486              	DC.L	DUMMY_H		; TRAP Instruction Vector #6
  342/      9C : 0000 0486              	DC.L	DUMMY_H		; TRAP Instruction Vector #7
  343/      A0 :                        
  344/      A0 :                        	;; 40-47
  345/      A0 : 0000 0486              	DC.L	DUMMY_H		; TRAP Instruction Vector #8
  346/      A4 : 0000 0486              	DC.L	DUMMY_H		; TRAP Instruction Vector #9
  347/      A8 : 0000 0486              	DC.L	DUMMY_H		; TRAP Instruction Vector #10
  348/      AC : 0000 0486              	DC.L	DUMMY_H		; TRAP Instruction Vector #11
  349/      B0 :                        
  350/      B0 : 0000 0486              	DC.L	DUMMY_H		; TRAP Instruction Vector #12
  351/      B4 : 0000 0486              	DC.L	DUMMY_H		; TRAP Instruction Vector #13
  352/      B8 : 0000 0486              	DC.L	DUMMY_H		; TRAP Instruction Vector #14
  353/      BC : 0000 0486              	DC.L	DUMMY_H		; TRAP Instruction Vector #15
  354/      C0 :                        
  355/      C0 :                        INIVECE:
  356/      C0 :                        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  357/      C0 :                        ;
  358/      C0 :                        ; define shared memory area
  359/      C0 :                        ;
  360/      C0 :                        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  361/     100 :                        	ORG	SHAD_M
  362/     100 :                        
  363/     100 :                        ;			   ; offset:
  364/     100 :                        UREQ_COM:	DS.B	1	; 0: monitor CONIN/CONOUT request command
  365/     101 :                        UNI_CHR:	DS.B	1	; 1: charcter (CONIN/CONOUT) or number of strings
  366/     102 :                        STR_addr	DS.L	1	; 2: string address
  367/     106 :                        ;--------------------------------------------------------------------------------
  368/     106 :                        CREQ_COM:	DS.B	1	; 6: PIC function CONIN/CONOUT request command
  369/     107 :                        CBI_CHR:	DS.B	1	; 7: charcter (CONIN/CONOUT) or number of strings
  370/     108 :                        disk_drive:	DS.B	1	; 8
  371/     109 :                        		DS.B	1	; 9
  372/     10A :                        disk_track:	DS.W	1	; A, B
  373/     10C :                        disk_sector:	DS.W	1	; C, D
  374/     10E :                        data_dma:	DS.L	1	; E, F, 10, 11
  375/     112 :                        
  376/     112 :                        crd_cnt:	ds.b	1
  377/     113 :                        crd_rp:		ds.b	1
  378/     114 :                        crd_wp:		ds.b	1
  379/     115 :                        
  380/     115 :                        req_e:
  381/     115 :                        
  382/     180 :                        	org	(req_e+$80) & $ff80
  383/     180 :                        
  384/     180 : =$80                   con_size:	equ	128
  385/     180 :                        contmp_buf:	ds.b	con_size	; tmp string buffer
  386/     200 :                        crd_buf:	ds.b	con_size	; console input buffer
  387/     280 :                        
  388/     280 :                        ;----------------------------------------------------------------------------------
  389/     280 :                        ;  ---- request command to PIC
  390/     280 :                        ; UREQ_COM = 1 ; CONIN  : return char in UNI_CHR
  391/     280 :                        ;          = 2 ; CONOUT : UNI_CHR = output char
  392/     280 :                        ;          = 3 ; CONST  : return status in UNI_CHR
  393/     280 :                        ;                       : ( 0: no key, 1 : key exist )
  394/     280 :                        ;          = 4 ; STROUT : string address
  395/     280 :                        
  396/     280 :                        ;----------------------------------------------------------------------------------
  397/     280 : =$1                    REQ_CONIN:	equ	1		; return char in UNI_CHR
  398/     280 : =$2                    REQ_CONOUT	equ	2		; UNI_CHR = output char
  399/     280 : =$3                    REQ_CONST:	equ	3		; return status in UNI_CHR( 0: no key, 1 : key exist )
  400/     280 : =$4                    REQ_STROUT	equ	4		; string output to console
  401/     280 :                        					; UNI_CHR or CBI_CHR = string size.
  402/     280 :                        					; STR_addr or data_dma = string address
  403/     280 : =$9                    REQ_CONIN1:	equ	9		; return char,(null char is no key)
  404/     280 : =$A                    REQ_CONOUT1:	equ	10		; return status,(0:output OK, 1:console busy)
  405/     280 : =$B                    REQ_STRIN	equ	11
  406/     280 : =$C                    REQ_CLR_IRQ:	equ	12		; clear IRQ interrupt request
  407/     280 :                        
  408/     280 : =$80000                PIC_REQ:	equ	$80000		;A19 = 1
  409/     280 :                        
  410/     280 :                        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  411/     280 :                        ;
  412/     280 :                        ; basic program
  413/     280 :                        ;
  414/     280 :                        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  415/     400 :                        	ORG	PROG_B
  416/     400 :                        
  417/     400 :                        ;;;
  418/     400 :                        ;;; Exception Handler
  419/     400 :                        ;;;
  420/     400 :                        
  421/     400 :                        ;
  422/     400 :                        ; timer interrupt handler
  423/     400 :                        ;contmp_buf	ds.b	con_size	; tmp string buffer
  424/     400 :                        
  425/     400 :                        IRQ5_H:
  426/     400 : 48E7 F0C0              	movem.l	d0-d3/a0-a1, -(a7)	;push d0,d1,a0,a1
  427/     404 : 0C38 0080 0112         	cmp.b	#$80, crd_cnt
  428/     40A : 6772                   	beq	exit_cin	; buffer full, then ignore key data
  429/     40C :                        
  430/     40C : 21FC 0000 0180 0102    	move.l	#contmp_buf, STR_addr	; save temp buffer address
  431/     414 :                        
  432/     414 :                        	; change change big endian to little endian
  433/     414 : 41F8 0102              	lea	STR_addr, a0
  434/     418 : 1010                   	move.b	(a0), d0		;hh
  435/     41A : 1228 0001              	move.b	1(a0), d1		;hl
  436/     41E : 1428 0002              	move.b	2(a0), d2		;lh
  437/     422 : 1628 0003              	move.b	3(a0), d3		;ll
  438/     426 : 1083                   	move.b	d3,(a0)
  439/     428 : 1142 0001              	move.b	d2,1(a0)
  440/     42C : 1141 0002              	move.b	d1,2(a0)
  441/     430 : 1140 0003              	move.b	d0,3(a0)
  442/     434 :                        
  443/     434 : 103C 0080              	move.b	#$80, d0
  444/     438 : 9038 0112              	sub.b	crd_cnt,d0		; d0 = #$80 - crd_cnt
  445/     43C : 11C0 0101              	move.b	d0, UNI_CHR		; set read buffer size
  446/     440 : 11FC 000B 0100         	move.b	#REQ_STRIN, UREQ_COM	; set string input request
  447/     446 : 1039 0008 0000         	move.b	PIC_REQ, d0		; request STRIN to PIC. Memory $80000 read
  448/     44C :                        wa_pic:
  449/     44C : 1038 0100              	move.b	UREQ_COM, d0
  450/     450 : 66FA                   	bne	wa_pic
  451/     452 :                        
  452/     452 : 1038 0101              	move.b	UNI_CHR, d0		; get string count
  453/     456 : 6726                   	beq	exit_cin		; exit, if no data
  454/     458 :                        
  455/     458 : 41F8 0200              	lea	crd_buf, a0		; a0 = crd_buf
  456/     45C : 43F8 0180              	lea	contmp_buf, a1		; a1 = contmp_buf
  457/     460 : 4281                   	clr.l	d1
  458/     462 : 1238 0114              	move.b	crd_wp, d1		; d1 = crd_wp
  459/     466 :                        
  460/     466 :                        mv_str:
  461/     466 : 1191 1000              	move.b	(a1), 0(a0,d1)	; crd_buf[d1] <- (a1)++
  462/     46A : 5249                   	addq	#1, a1
  463/     46C : 5201                   	addq.b	#1, d1			; crd_wp++
  464/     46E : 0201 007F              	andi.b	#$7f, d1
  465/     472 : 5238 0112              	addq.b	#1, crd_cnt		; crd_cnt++
  466/     476 : 5300                   	subq.b	#1, d0			; decriment string count
  467/     478 : 66EC                   	bne	mv_str
  468/     47A : 11C1 0114              	move.b	d1, crd_wp		; update write point
  469/     47E :                        
  470/     47E :                        exit_cin:
  471/     47E : 7001                   	moveq	#1, d0
  472/     480 : 6130                   	bsr	clr_int			; clear interrupt request
  473/     482 : 4CDF 030F              	movem.l	(a7)+, d0-d3/a0-a1	 ;pop a1,a0,d1,d0
  474/     486 :                        
  475/     486 :                        	;; Dummy
  476/     486 :                        DUMMY_H:
  477/     486 : 4E73                   	RTE
  478/     488 :                        ;
  479/     488 :                        ; NMI interrupt
  480/     488 :                        ;
  481/     488 :                        NMI_H:
  482/     488 : 41F8 049E              	lea	nmi_msg,a0
  483/     48C : 613C                   	bsr	strout
  484/     48E : 7000                   	moveq	#0, d0
  485/     490 : 6120                   	bsr	clr_int			; clear interrupt request
  486/     492 : 6100 04B4              	bsr	LAB_1491		; flush stack & clear continue flag
  487/     496 :                        ;	set interrupt level
  488/     496 : 46FC 2400              	move.w #$2400,sr
  489/     49A : 6000 020A              	bra	LAB_1274		; warm start
  490/     49E :                        
  491/     49E : 0D0A 4E4D 4920 496E    nmi_msg:	dc.b	$0d,$0a,"NMI Interrupt!!",$0d,$0a,$00
           4A6 : 7465 7272 7570 7421
           4AE : 210D 0A00            
  492/     4B2 :                        
  493/     4B2 :                        clr_int:
  494/     4B2 : 11C0 0101              	move.b	d0, UNI_CHR		; set interrupt source(0: NMI 1:IRQ5)
  495/     4B6 : 11FC 000C 0100         	move.b	#REQ_CLR_IRQ, UREQ_COM	; set clear interrupt request
  496/     4BC : 1039 0008 0000         	move.b	PIC_REQ, d0		; request conin to PIC. Memory $80000 read
  497/     4C2 :                        w_pic:
  498/     4C2 : 1038 0100              	move.b	UREQ_COM, d0
  499/     4C6 : 66FA                   	bne	w_pic
  500/     4C8 : 4E75                   	rts
  501/     4CA :                        
  502/     4CA :                        strout:
  503/     4CA : 1018                   	move.b	(a0)+,d0
  504/     4CC : 6704                   	beq	stroe
  505/     4CE : 613E                   	bsr	VEC_OUT
  506/     4D0 : 60F8                   	bra	strout
  507/     4D2 :                        stroe:
  508/     4D2 : 4E75                   	rts
  509/     4D4 :                        
  510/     4D4 :                        
  511/     4D4 :                        ;************************************************************************************
  512/     4D4 :                        ;
  513/     4D4 :                        ; input a character from the console into register d0
  514/     4D4 :                        ; else return Cb=0 if there's no character available
  515/     4D4 :                        
  516/     4D4 :                        ; output d0 : conin character
  517/     4D4 :                        VEC_IN:	; CONIN
  518/     4D4 :                        
  519/     4D4 : 1038 0112              	move.b	crd_cnt, d0
  520/     4D8 : 4A00                   	tst.b	d0
  521/     4DA : 6730                   	beq	no_keyin
  522/     4DC :                        
  523/     4DC :                        	; disable interrupt
  524/     4DC : 40E7                   	move sr, -(a7)		; save status register
  525/     4DE : 46FC 2700              	move #$2700, sr		; disable interrupt
  526/     4E2 :                        
  527/     4E2 : 48E7 4080              	movem.l	d1/a0, -(a7)	;push d1,a0
  528/     4E6 :                        
  529/     4E6 : 41F8 0200              	lea	crd_buf, a0	; a0 = crd_buf
  530/     4EA : 4281                   	clr.l	d1
  531/     4EC : 1238 0113              	move.b	crd_rp, d1	; d1 = crd_rp
  532/     4F0 : 1030 1000              	move.b	0(a0,d1), d0	; d0 <- crd_buf[d1]
  533/     4F4 :                        
  534/     4F4 : 5201                   	addq.b	#1, d1		; crd_rp++
  535/     4F6 : 0201 007F              	andi.b	#$7f, d1
  536/     4FA : 11C1 0113              	move.b	d1, crd_rp
  537/     4FE :                        
  538/     4FE : 5338 0112              	subq.b	#1,crd_cnt
  539/     502 :                        
  540/     502 : 4CDF 0102              	movem.l	(a7)+, d1/a0	 ;pop a0,d1
  541/     506 :                        
  542/     506 :                        	; enable interrupt
  543/     506 : 46DF                   	move	(a7)+, sr
  544/     508 : 003C 0001              	ori.b	#1,ccr		; set carry flag. get key in
  545/     50C :                        
  546/     50C :                        no_keyin:
  547/     50C : 4E75                   	rts
  548/     50E :                        
  549/     50E :                        ;************************************************************************************
  550/     50E :                        ;
  551/     50E :                        ; the following code is simulator specific, change to suit your system
  552/     50E :                        ; Output character to the console from register d0.b
  553/     50E :                        
  554/     50E :                        VEC_OUT:	; CONOUT
  555/     50E : 48E7 C000              	movem.l	d0/d1, -(a7)	;push d0,d1
  556/     512 : 1200                   	move.b	d0, d1
  557/     514 :                        cout_1:
  558/     514 : 40E7                   	move sr, -(a7)		; save status register
  559/     516 : 46FC 2700              	move #$2700, sr		; disable interrupt
  560/     51A :                        
  561/     51A : 11FC 000A 0100         	move.b	#REQ_CONOUT1, UREQ_COM	; set CONOUT request
  562/     520 : 11C0 0101              	move.b	d0, UNI_CHR		; set output character
  563/     524 :                        
  564/     524 : 1039 0008 0000         	move.b	PIC_REQ, d0		; request conin to PIC. Memory $80000 read
  565/     52A :                        cin1:
  566/     52A : 1038 0100              	move.b	UREQ_COM, d0
  567/     52E : 66FA                   	bne	cin1
  568/     530 :                        	
  569/     530 :                        	; get character or status
  570/     530 : 1038 0101              	move.b	UNI_CHR, d0
  571/     534 :                        
  572/     534 : 46DF                   	move	(a7)+, sr
  573/     536 :                        
  574/     536 : 8000                   	or.b	d0, d0
  575/     538 : 6704                   	beq.s	end_cout
  576/     53A : 1001                   	move.b	d1, d0
  577/     53C : 60D6                   	bra	cout_1
  578/     53E :                        
  579/     53E :                        end_cout:
  580/     53E : 4CDF 0003              	movem.l	(a7)+, d0/d1	;pop d1, d0
  581/     542 : 4E75                   	rts
  582/     544 :                        
  583/     544 :                        ;************************************************************************************
  584/     544 :                        ;
  585/     544 :                        ; LOAD routine for the TS2 computer (not implemented)
  586/     544 :                        
  587/     544 :                        VEC_LD
  588/     544 : 7E2E                          MOVEQ           #$2E,d7                        ; error code $2E "Not implemented" error
  589/     546 : 6000 0134                     BRA             LAB_XERR                       ; do error #d7, then warm start
  590/     54A :                        
  591/     54A :                        ;************************************************************************************
  592/     54A :                        ;
  593/     54A :                        ; SAVE routine for the TS2 computer (not implemented)
  594/     54A :                        
  595/     54A :                        VEC_SV
  596/     54A : 7E2E                          MOVEQ           #$2E,d7                        ; error code $2E "Not implemented" error
  597/     54C : 6000 012E                     BRA             LAB_XERR                       ; do error #d7, then warm start
  598/     550 :                        
  599/     550 :                        
  600/     550 :                        ;************************************************************************************
  601/     550 :                        
  602/     550 :                        code_start
  603/     550 :                        
  604/     550 :                        ;; Initialize PIC command request table
  605/     550 : 41F8 0100              	LEA	SHAD_M,A0
  606/     554 : 303C 0014              	MOVE	#(req_e-SHAD_M)-1,D0
  607/     558 :                        shad_0:
  608/     558 : 4218                   	CLR.B	(A0)+
  609/     55A : 51C8 FFFC              	DBF	D0,shad_0
  610/     55E :                        ;                               ; Set up ACIA parameters
  611/     55E :                        ;        LEA.L   ACIA_1,A0      ; A0 points to console ACIA
  612/     55E :                        ;        MOVE.B  #$15,(A0)      ; Set up ACIA1 constants (no IRQ,
  613/     55E :                        ;                               ; RTS* low, 8 bit, no parity, 1 stop)
  614/     55E :                        ;        LEA.L   ACIA_2,A0      ; A0 points to aux. ACIA
  615/     55E :                        ;        MOVE.B  #$15,(A0)      ; Set up ACIA2 constants (no IRQ,
  616/     55E :                        ;                               ; RTS* low, 8 bit, no parity, 1 stop)
  617/     55E :                        
  618/     55E :                        ; to tell EhBASIC where and how much RAM it has pass the address in a0 and the size
  619/     55E :                        ; in d0. these values are at the end of the .inc file
  620/     55E :                        
  621/     55E : 207C 0000 3B00         	MOVEA.l	#ram_strt,a0		; tell BASIC where RAM starts
  622/     564 : 203C 0007 C500         	MOVE.l	#ram_size,d0			; tell BASIC how big RAM is
  623/     56A :                        
  624/     56A :                        ; end of simulator specific code
  625/     56A :                        
  626/     56A :                        
  627/     56A :                        ;************************************************************************************
  628/     56A :                        ;************************************************************************************
  629/     56A :                        ;************************************************************************************
  630/     56A :                        ;************************************************************************************
  631/     56A :                        ;
  632/     56A :                        ; Register use :- (must improve this !!)
  633/     56A :                        ;
  634/     56A :                        ;	a6 -	temp Bpntr					; temporary BASIC execute pointer
  635/     56A :                        ;	a5 -	Bpntr						; BASIC execute (get byte) pointer
  636/     56A :                        ;	a4 -	des_sk				       ; descriptor stack pointer
  637/     56A :                        ;	a3 -	ram_strt					; start of RAM. all RAM references are offsets
  638/     56A :                        ;								; from this value
  639/     56A :                        ;
  640/     56A :                        
  641/     56A :                        ;************************************************************************************
  642/     56A :                        ;
  643/     56A :                        ; BASIC cold start entry point. assume entry with RAM address in a0 and RAM length
  644/     56A :                        ; in d0
  645/     56A :                        
  646/     56A :                        LAB_COLD
  647/     56A :                        ;	CMP.l		#$4000,d0			; compare size with 16k
  648/     56A :                        ;	BGE.s		LAB_sizok			; branch if >= 16k
  649/     56A :                        ;
  650/     56A :                        ;	MOVEQ	#5,d0					; error 5 - not enough RAM
  651/     56A :                        ;	move.b	#228,D7					; Go to TUTOR function
  652/     56A :                        ;	trap	#14						; Call TRAP14 handler
  653/     56A :                        ;
  654/     56A :                        ;LAB_sizok
  655/     56A : 2648                   	MOVEA.l	a0,a3					; copy RAM base to a3
  656/     56C : D1C0                   	ADDA.l	d0,a0					; a0 is top of RAM
  657/     56E : 2748 044A              	MOVE.l	a0,Ememl(a3)				; set end of mem
  658/     572 : 2E7C 0000 3F00         	MOVE.l	#ram_strt+ram_base,sp				; set stack to RAM start + 1k
  659/     578 :                        
  660/     578 : 303C 4EF9              	MOVE.w	#$4EF9,d0				; JMP opcode
  661/     57C : 204F                   	MOVEA.l	sp,a0					; point to start of vector table
  662/     57E :                        
  663/     57E : 30C0                   	MOVE.w	d0,(a0)+				; LAB_WARM
  664/     580 : 43FA FFE8              	LEA		LAB_COLD(pc),a1			; initial warm start vector
  665/     584 : 20C9                   	MOVE.l	a1,(a0)+				; set vector
  666/     586 :                        
  667/     586 : 30C0                   	MOVE.w	d0,(a0)+				; Usrjmp
  668/     588 : 43FA 00E0              	LEA		LAB_FCER(pc),a1			; initial user function vector
  669/     58C :                        									; "Function call" error
  670/     58C : 20C9                   	MOVE.l	a1,(a0)+				; set vector
  671/     58E :                        
  672/     58E : 30C0                   	MOVE.w	d0,(a0)+				; V_INPT JMP opcode
  673/     590 : 43FA FF42              	LEA		VEC_IN(pc),a1			; get byte from input device vector
  674/     594 : 20C9                   	MOVE.l	a1,(a0)+				; set vector
  675/     596 :                        
  676/     596 : 30C0                   	MOVE.w	d0,(a0)+				; V_OUTP JMP opcode
  677/     598 : 43FA FF74              	LEA		VEC_OUT(pc),a1			; send byte to output device vector
  678/     59C : 20C9                   	MOVE.l	a1,(a0)+				; set vector
  679/     59E :                        
  680/     59E : 30C0                   	MOVE.w	d0,(a0)+				; V_LOAD JMP opcode
  681/     5A0 : 43FA FFA2              	LEA		VEC_LD(pc),a1			; load BASIC program vector
  682/     5A4 : 20C9                   	MOVE.l	a1,(a0)+				; set vector
  683/     5A6 :                        
  684/     5A6 : 30C0                   	MOVE.w	d0,(a0)+				; V_SAVE JMP opcode
  685/     5A8 : 43FA FFA0              	LEA		VEC_SV(pc),a1			; save BASIC program vector
  686/     5AC : 20C9                   	MOVE.l	a1,(a0)+				; set vector
  687/     5AE :                        
  688/     5AE : 30C0                   	MOVE.w	d0,(a0)+				; V_CTLC JMP opcode
  689/     5B0 : 43FA 2638              	LEA		VEC_CC(pc),a1			; save CTRL-C check vector
  690/     5B4 : 20C9                   	MOVE.l	a1,(a0)+				; set vector
  691/     5B6 :                        
  692/     5B6 :                        ; set-up start values
  693/     5B6 :                        
  694/     5B6 :                        ;##LAB_GMEM
  695/     5B6 : 7000                   	MOVEQ	#$00,d0					; clear d0
  696/     5B8 : 1740 05E4              	MOVE.b	d0,Nullct(a3)			; default NULL count
  697/     5BC : 1740 05E5              	MOVE.b	d0,TPos(a3)				; clear terminal position
  698/     5C0 : 1740 05E8              	MOVE.b	d0,ccflag(a3)			; allow CTRL-C check
  699/     5C4 : 3740 05FE              	MOVE.w	d0,prg_strt-2(a3)			; clear start word
  700/     5C8 : 3740 05D6              	MOVE.w	d0,BHsend(a3)			; clear value to string end word
  701/     5CC :                        
  702/     5CC : 177C 0050 05E6         	MOVE.b	#$50,TWidth(a3)			; default terminal width byte for simulator
  703/     5D2 : 177C 000E 05E2         	MOVE.b	#$0E,TabSiz(a3)			; save default tab size = 14
  704/     5D8 :                        
  705/     5D8 : 177C 0038 05E7         	MOVE.b	#$38,Iclim(a3)			; default limit for TAB = 14 for simulator
  706/     5DE :                        
  707/     5DE : 49EB 048E              	LEA		des_sk(a3),a4			; set descriptor stack start
  708/     5E2 :                        
  709/     5E2 : 41EB 0600              	LEA		prg_strt(a3),a0			; get start of mem
  710/     5E6 : 2748 042E              	MOVE.l	a0,Smeml(a3)			; save start of mem
  711/     5EA :                        
  712/     5EA : 6100 0326              	BSR		LAB_1463				; do "NEW" and "CLEAR"
  713/     5EE : 6100 08A4              	BSR		LAB_CRLF				; print CR/LF
  714/     5F2 : 202B 044A              	MOVE.l	Ememl(a3),d0			; get end of mem
  715/     5F6 : 90AB 042E              	SUB.l		Smeml(a3),d0			; subtract start of mem
  716/     5FA :                        
  717/     5FA : 6100 1BE0              	BSR		LAB_295E				; print d0 as unsigned integer (bytes free)
  718/     5FE : 41FA 3408              	LEA		LAB_SMSG(pc),a0			; point to start message
  719/     602 : 6100 08EE              	BSR		LAB_18C3				; print null terminated string from memory
  720/     606 :                        
  721/     606 : 41FA 29EC              	LEA		LAB_RSED(pc),a0			; get pointer to value
  722/     60A : 6100 1A78              	BSR		LAB_UFAC				; unpack memory (a0) into FAC1
  723/     60E :                        
  724/     60E : 41FA 0096              	LEA		LAB_1274(pc),a0			; get warm start vector
  725/     612 : 2748 0402              	MOVE.l	a0,Wrmjpv(a3)			; set warm start vector
  726/     616 : 6100 1FEA              	BSR		LAB_RND					; initialise
  727/     61A :                        
  728/     61A :                        ;	set interrupt level
  729/     61A : 46FC 2400              	move.w #$2400,sr
  730/     61E :                        
  731/     61E : 4EEB 0400              	JMP		LAB_WARM(a3)			; go do warm start
  732/     622 :                        
  733/     622 :                        
  734/     622 :                        ;************************************************************************************
  735/     622 :                        ;
  736/     622 :                        ; do format error
  737/     622 :                        
  738/     622 :                        LAB_FOER
  739/     622 : 7E2C                   	MOVEQ		#$2C,d7				; error code $2C "Format" error
  740/     624 : 6056                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  741/     626 :                        
  742/     626 :                        
  743/     626 :                        ;************************************************************************************
  744/     626 :                        ;
  745/     626 :                        ; do address error
  746/     626 :                        
  747/     626 :                        LAB_ADER
  748/     626 : 7E2A                   	MOVEQ		#$2A,d7				; error code $2A "Address" error
  749/     628 : 6052                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  750/     62A :                        
  751/     62A :                        
  752/     62A :                        ;************************************************************************************
  753/     62A :                        ;
  754/     62A :                        ; do wrong dimensions error
  755/     62A :                        
  756/     62A :                        LAB_WDER
  757/     62A : 7E28                   	MOVEQ		#$28,d7				; error code $28 "Wrong dimensions" error
  758/     62C : 604E                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  759/     62E :                        
  760/     62E :                        
  761/     62E :                        ;************************************************************************************
  762/     62E :                        ;
  763/     62E :                        ; do undimensioned array error
  764/     62E :                        
  765/     62E :                        LAB_UDER
  766/     62E : 7E26                   	MOVEQ		#$26,d7				; error code $26 "undimensioned array" error
  767/     630 : 604A                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  768/     632 :                        
  769/     632 :                        
  770/     632 :                        ;************************************************************************************
  771/     632 :                        ;
  772/     632 :                        ; do undefined variable error
  773/     632 :                        
  774/     632 :                        LAB_UVER
  775/     632 :                        
  776/     632 : 7E24                   	MOVEQ		#$24,d7				; error code $24 "undefined variable" error
  777/     634 : 6046                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  778/     636 :                        
  779/     636 :                        
  780/     636 :                        ;************************************************************************************
  781/     636 :                        ;
  782/     636 :                        ; do loop without do error
  783/     636 :                        
  784/     636 :                        LAB_LDER
  785/     636 : 7E22                   	MOVEQ		#$22,d7				; error code $22 "LOOP without DO" error
  786/     638 : 6042                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  787/     63A :                        
  788/     63A :                        
  789/     63A :                        ;************************************************************************************
  790/     63A :                        ;
  791/     63A :                        ; do undefined function error
  792/     63A :                        
  793/     63A :                        LAB_UFER
  794/     63A : 7E20                   	MOVEQ		#$20,d7				; error code $20 "Undefined function" error
  795/     63C : 603E                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  796/     63E :                        
  797/     63E :                        
  798/     63E :                        ;************************************************************************************
  799/     63E :                        ;
  800/     63E :                        ; do can't continue error
  801/     63E :                        
  802/     63E :                        LAB_CCER
  803/     63E : 7E1E                   	MOVEQ		#$1E,d7				; error code $1E "Can't continue" error
  804/     640 : 603A                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  805/     642 :                        
  806/     642 :                        
  807/     642 :                        ;************************************************************************************
  808/     642 :                        ;
  809/     642 :                        ; do string too complex error
  810/     642 :                        
  811/     642 :                        LAB_SCER
  812/     642 : 7E1C                   	MOVEQ		#$1C,d7				; error code $1C "String too complex" error
  813/     644 : 6036                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  814/     646 :                        
  815/     646 :                        
  816/     646 :                        ;************************************************************************************
  817/     646 :                        ;
  818/     646 :                        ; do string too long error
  819/     646 :                        
  820/     646 :                        LAB_SLER
  821/     646 : 7E1A                   	MOVEQ		#$1A,d7				; error code $1A "String too long" error
  822/     648 : 6032                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  823/     64A :                        
  824/     64A :                        
  825/     64A :                        ;************************************************************************************
  826/     64A :                        ;
  827/     64A :                        ; do type missmatch error
  828/     64A :                        
  829/     64A :                        LAB_TMER
  830/     64A : 7E18                   	MOVEQ		#$18,d7				; error code $18 "Type mismatch" error
  831/     64C : 602E                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  832/     64E :                        
  833/     64E :                        
  834/     64E :                        ;************************************************************************************
  835/     64E :                        ;
  836/     64E :                        ; do illegal direct error
  837/     64E :                        
  838/     64E :                        LAB_IDER
  839/     64E : 7E16                   	MOVEQ		#$16,d7				; error code $16 "Illegal direct" error
  840/     650 : 602A                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  841/     652 :                        
  842/     652 :                        
  843/     652 :                        ;************************************************************************************
  844/     652 :                        ;
  845/     652 :                        ; do divide by zero error
  846/     652 :                        
  847/     652 :                        LAB_DZER
  848/     652 : 7E14                   	MOVEQ		#$14,d7				; error code $14 "Divide by zero" error
  849/     654 : 6026                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  850/     656 :                        
  851/     656 :                        
  852/     656 :                        ;************************************************************************************
  853/     656 :                        ;
  854/     656 :                        ; do double dimension error
  855/     656 :                        
  856/     656 :                        LAB_DDER
  857/     656 : 7E12                   	MOVEQ		#$12,d7				; error code $12 "Double dimension" error
  858/     658 : 6022                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  859/     65A :                        
  860/     65A :                        
  861/     65A :                        ;************************************************************************************
  862/     65A :                        ;
  863/     65A :                        ; do array bounds error
  864/     65A :                        
  865/     65A :                        LAB_ABER
  866/     65A : 7E10                   	MOVEQ		#$10,d7				; error code $10 "Array bounds" error
  867/     65C : 601E                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  868/     65E :                        
  869/     65E :                        
  870/     65E :                        ;************************************************************************************
  871/     65E :                        ;
  872/     65E :                        ; do undefined satement error
  873/     65E :                        
  874/     65E :                        LAB_USER
  875/     65E : 7E0E                   	MOVEQ		#$0E,d7				; error code $0E "Undefined statement" error
  876/     660 : 601A                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  877/     662 :                        
  878/     662 :                        
  879/     662 :                        ;************************************************************************************
  880/     662 :                        ;
  881/     662 :                        ; do out of memory error
  882/     662 :                        
  883/     662 :                        LAB_OMER
  884/     662 : 7E0C                   	MOVEQ		#$0C,d7				; error code $0C "Out of memory" error
  885/     664 : 6016                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  886/     666 :                        
  887/     666 :                        
  888/     666 :                        ;************************************************************************************
  889/     666 :                        ;
  890/     666 :                        ; do overflow error
  891/     666 :                        
  892/     666 :                        LAB_OFER
  893/     666 : 7E0A                   	MOVEQ		#$0A,d7				; error code $0A "Overflow" error
  894/     668 : 6012                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  895/     66A :                        
  896/     66A :                        
  897/     66A :                        ;************************************************************************************
  898/     66A :                        ;
  899/     66A :                        ; do function call error
  900/     66A :                        
  901/     66A :                        LAB_FCER
  902/     66A : 7E08                   	MOVEQ		#$08,d7				; error code $08 "Function call" error
  903/     66C : 600E                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  904/     66E :                        
  905/     66E :                        
  906/     66E :                        ;************************************************************************************
  907/     66E :                        ;
  908/     66E :                        ; do out of data error
  909/     66E :                        
  910/     66E :                        LAB_ODER
  911/     66E : 7E06                   	MOVEQ		#$06,d7				; error code $06 "Out of DATA" error
  912/     670 : 600A                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  913/     672 :                        
  914/     672 :                        
  915/     672 :                        ;************************************************************************************
  916/     672 :                        ;
  917/     672 :                        ; do return without gosub error
  918/     672 :                        
  919/     672 :                        LAB_RGER
  920/     672 : 7E04                   	MOVEQ		#$04,d7				; error code $04 "RETURN without GOSUB" error
  921/     674 : 6006                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  922/     676 :                        
  923/     676 :                        
  924/     676 :                        ;************************************************************************************
  925/     676 :                        ;
  926/     676 :                        ; do syntax error
  927/     676 :                        
  928/     676 :                        LAB_SNER
  929/     676 : 7E02                   	MOVEQ		#$02,d7				; error code $02 "Syntax" error
  930/     678 : 6002                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  931/     67A :                        
  932/     67A :                        
  933/     67A :                        ;************************************************************************************
  934/     67A :                        ;
  935/     67A :                        ; do next without for error
  936/     67A :                        
  937/     67A :                        LAB_NFER
  938/     67A : 7E00                   	MOVEQ		#$00,d7				; error code $00 "NEXT without FOR" error
  939/     67C :                        
  940/     67C :                        
  941/     67C :                        ;************************************************************************************
  942/     67C :                        ;
  943/     67C :                        ; do error #d7, then warm start
  944/     67C :                        
  945/     67C :                        LAB_XERR
  946/     67C : 6100 02CA              	BSR		LAB_1491				; flush stack & clear continue flag
  947/     680 : 6100 0812              	BSR		LAB_CRLF				; print CR/LF
  948/     684 : 43FA 2FFA              	LEA		LAB_BAER(pc),a1			; start of error message pointer table
  949/     688 : 3E31 7000              	MOVE.w	(a1,d7.w),d7			; get error message offset
  950/     68C : 41F1 7000              	LEA		(a1,d7.w),a0			; get error message address
  951/     690 : 6100 0860              	BSR		LAB_18C3				; print null terminated string from memory
  952/     694 : 41FA 3335              	LEA		LAB_EMSG(pc),a0			; point to " Error" message
  953/     698 :                        LAB_1269
  954/     698 : 6100 0858              	BSR		LAB_18C3				; print null terminated string from memory
  955/     69C : 202B 0452              	MOVE.l	Clinel(a3),d0			; get current line
  956/     6A0 : 6B04                   	BMI.s	LAB_1274				; go do warm start if -ve # (was immediate mode)
  957/     6A2 :                        
  958/     6A2 :                        									; else print line number
  959/     6A2 : 6100 1B2C              	BSR		LAB_2953				; print " in line [LINE #]"
  960/     6A6 :                        
  961/     6A6 :                        ; BASIC warm start entry point, wait for Basic command
  962/     6A6 :                        
  963/     6A6 :                        LAB_1274
  964/     6A6 : 41FA 3356              	LEA		LAB_RMSG(pc),a0			; point to "Ready" message
  965/     6AA : 6100 0846              	BSR		LAB_18C3				; go do print string
  966/     6AE :                        
  967/     6AE :                        ; wait for Basic command - no "Ready"
  968/     6AE :                        
  969/     6AE :                        LAB_127D
  970/     6AE : 72FF                   	MOVEQ	#-1,d1					; set to -1
  971/     6B0 : 2741 0452              	MOVE.l	d1,Clinel(a3)			; set current line #
  972/     6B4 : 1741 05DC              	MOVE.b	d1,Breakf(a3)			; set break flag
  973/     6B8 : 4BEB 0490              	LEA		Ibuffs(a3),a5			; set basic execute pointer ready for new line
  974/     6BC :                        LAB_127E
  975/     6BC : 6100 00EC              	BSR		LAB_1357				; call for BASIC input
  976/     6C0 : 6100 0BFC              	BSR		LAB_GBYT				; scan memory
  977/     6C4 : 67F6                   	BEQ.s	LAB_127E				; loop while null
  978/     6C6 :                        
  979/     6C6 :                        ; got to interpret input line now ....
  980/     6C6 :                        
  981/     6C6 : 6508                   	BCS.s	LAB_1295				; branch if numeric character, handle new
  982/     6C8 :                        								; BASIC line
  983/     6C8 :                        
  984/     6C8 :                        								; no line number so do immediate mode, a5
  985/     6C8 :                        								; points to the buffer start
  986/     6C8 : 6100 0156              	BSR		LAB_13A6				; crunch keywords into Basic tokens
  987/     6CC :                        								; crunch from (a5), output to (a0)
  988/     6CC :                        								; returns ..
  989/     6CC :                        								; d2 is length, d1 trashed, d0 trashed,
  990/     6CC :                        								; a1 trashed
  991/     6CC : 6000 03C6              	BRA		LAB_15F6				; go scan & interpret code
  992/     6D0 :                        
  993/     6D0 :                        
  994/     6D0 :                        ;************************************************************************************
  995/     6D0 :                        ;
  996/     6D0 :                        ; handle a new BASIC line
  997/     6D0 :                        
  998/     6D0 :                        LAB_1295
  999/     6D0 : 6100 0640              	BSR		LAB_GFPN				; get fixed-point number into temp integer & d1
 1000/     6D4 : 6100 014A              	BSR		LAB_13A6				; crunch keywords into Basic tokens
 1001/     6D8 :                        								; crunch from (a5), output to (a0)
 1002/     6D8 :                        								; returns .. d2 is length,
 1003/     6D8 :                        								; d1 trashed, d0 trashed, a1 trashed
 1004/     6D8 : 222B 042A              	MOVE.l	Itemp(a3),d1			; get required line #
 1005/     6DC : 6100 0218              	BSR		LAB_SSLN				; search BASIC for d1 line number
 1006/     6E0 :                        								; returns pointer in a0
 1007/     6E0 : 6532                   	BCS.s		LAB_12E6				; branch if not found
 1008/     6E2 :                        
 1009/     6E2 :                        								; aroooogah! line # already exists! delete it
 1010/     6E2 : 2250                   	MOVEA.l	(a0),a1				; get start of block (next line pointer)
 1011/     6E4 : 202B 0432              	MOVE.l	Sfncl(a3),d0			; get end of block (start of functions)
 1012/     6E8 : 9089                   	SUB.l		a1,d0					; subtract start of block ( = bytes to move)
 1013/     6EA : E288                   	LSR.l		#1,d0					; /2 (word move)
 1014/     6EC : 5380                   	SUBQ.l	#1,d0					; adjust for DBF loop
 1015/     6EE : 4840                   	SWAP		d0					; swap high word to low word
 1016/     6F0 : 2448                   	MOVEA.l	a0,a2					; copy destination
 1017/     6F2 :                        LAB_12AE
 1018/     6F2 : 4840                   	SWAP		d0					; swap high word to low word
 1019/     6F4 :                        LAB_12B0
 1020/     6F4 : 34D9                   	MOVE.w	(a1)+,(a2)+				; copy word
 1021/     6F6 : 51C8 FFFC              	DBF		d0,LAB_12B0				; decrement low count and loop until done
 1022/     6FA :                        
 1023/     6FA : 4840                   	SWAP		d0					; swap high word to low word
 1024/     6FC : 51C8 FFF4              	DBF		d0,LAB_12AE				; decrement high count and loop until done
 1025/     700 :                        
 1026/     700 : 274A 0432              	MOVE.l	a2,Sfncl(a3)			; start of functions
 1027/     704 : 274A 0436              	MOVE.l	a2,Svarl(a3)			; save start of variables
 1028/     708 : 274A 043A              	MOVE.l	a2,Sstrl(a3)			; start of strings
 1029/     70C : 274A 043E              	MOVE.l	a2,Sarryl(a3)			; save start of arrays
 1030/     710 : 274A 0442              	MOVE.l	a2,Earryl(a3)			; save end of arrays
 1031/     714 :                        
 1032/     714 :                        								; got new line in buffer and no existing same #
 1033/     714 :                        LAB_12E6
 1034/     714 : 102B 0490              	MOVE.b	Ibuffs(a3),d0			; get byte from start of input buffer
 1035/     718 : 6764                   	BEQ.s		LAB_1325				; if null line go do line chaining
 1036/     71A :                        
 1037/     71A :                        								; got new line and it isn't empty line
 1038/     71A : 226B 0432              	MOVEA.l	Sfncl(a3),a1			; get start of functions (end of block to move)
 1039/     71E : 45F1 2008              	LEA		8(a1,d2),a2				; copy it, add line length and add room for
 1040/     722 :                        								; pointer and line number
 1041/     722 :                        
 1042/     722 : 274A 0432              	MOVE.l	a2,Sfncl(a3)			; start of functions
 1043/     726 : 274A 0436              	MOVE.l	a2,Svarl(a3)			; save start of variables
 1044/     72A : 274A 043A              	MOVE.l	a2,Sstrl(a3)			; start of strings
 1045/     72E : 274A 043E              	MOVE.l	a2,Sarryl(a3)			; save start of arrays
 1046/     732 : 274A 0442              	MOVE.l	a2,Earryl(a3)			; save end of arrays
 1047/     736 : 276B 044A 0446         	MOVE.l	Ememl(a3),Sstorl(a3)		; copy end of mem to start of strings, clear
 1048/     73C :                        								; strings
 1049/     73C :                        
 1050/     73C : 2209                   	MOVE.l	a1,d1					; copy end of block to move
 1051/     73E : 9288                   	SUB.l		a0,d1					; subtract start of block to move
 1052/     740 : E289                   	LSR.l		#1,d1					; /2 (word copy)
 1053/     742 : 5381                   	SUBQ.l	#1,d1					; correct for loop end on -1
 1054/     744 : 4841                   	SWAP		d1					; swap high word to low word
 1055/     746 :                        LAB_12FF
 1056/     746 : 4841                   	SWAP		d1					; swap high word to low word
 1057/     748 :                        LAB_1301
 1058/     748 : 3521                   	MOVE.w	-(a1),-(a2)				; decrement pointers and copy word
 1059/     74A : 51C9 FFFC              	DBF		d1,LAB_1301				; decrement & loop
 1060/     74E :                        
 1061/     74E : 4841                   	SWAP		d1					; swap high word to low word
 1062/     750 : 51C9 FFF4              	DBF		d1,LAB_12FF				; decrement high count and loop until done
 1063/     754 :                        
 1064/     754 :                        ; space is opened up, now copy the crunched line from the input buffer into the space
 1065/     754 :                        
 1066/     754 : 43EB 0490              	LEA		Ibuffs(a3),a1			; source is input buffer
 1067/     758 : 2448                   	MOVEA.l	a0,a2					; copy destination
 1068/     75A : 72FF                   	MOVEQ		#-1,d1				; set to allow re-chaining
 1069/     75C : 24C1                   	MOVE.l	d1,(a2)+				; set next line pointer (allow re-chaining)
 1070/     75E : 24EB 042A              	MOVE.l	Itemp(a3),(a2)+			; save line number
 1071/     762 : E24A                   	LSR.w		#1,d2					; /2 (word copy)
 1072/     764 : 5342                   	SUBQ.w	#1,d2					; correct for loop end on -1
 1073/     766 :                        LAB_1303
 1074/     766 : 34D9                   	MOVE.w	(a1)+,(a2)+				; copy word
 1075/     768 : 51CA FFFC              	DBF		d2,LAB_1303				; decrement & loop
 1076/     76C :                        
 1077/     76C : 6010                   	BRA.s		LAB_1325				; go test for end of prog
 1078/     76E :                        
 1079/     76E :                        ; rebuild chaining of BASIC lines
 1080/     76E :                        
 1081/     76E :                        LAB_132E
 1082/     76E : 5048                   	ADDQ.w	#8,a0					; point to first code byte of line, there is
 1083/     770 :                        								; always 1 byte + [EOL] as null entries are
 1084/     770 :                        								; deleted
 1085/     770 :                        LAB_1330
 1086/     770 : 4A18                   	TST.b		(a0)+					; test byte	
 1087/     772 : 66FC                   	BNE.s		LAB_1330				; loop if not [EOL]
 1088/     774 :                        
 1089/     774 :                        								; was [EOL] so get next line start
 1090/     774 : 3208                   	MOVE.w	a0,d1					; past pad byte(s)
 1091/     776 : 0241 0001              	ANDI.w	#1,d1					; mask odd bit
 1092/     77A : D0C1                   	ADD.w		d1,a0					; add back to ensure even
 1093/     77C : 2288                   	MOVE.l	a0,(a1)				; save next line pointer to current line
 1094/     77E :                        LAB_1325
 1095/     77E : 2248                   	MOVEA.l	a0,a1					; copy pointer for this line
 1096/     780 : 4A90                   	TST.l		(a0)					; test pointer to next line
 1097/     782 : 66EA                   	BNE.s		LAB_132E				; not end of program yet so we must
 1098/     784 :                        								; go and fix the pointers
 1099/     784 :                        
 1100/     784 : 6100 0198              	BSR		LAB_1477				; reset execution to start, clear variables
 1101/     788 :                        								; and flush stack
 1102/     788 : 6000 FF24              	BRA		LAB_127D				; now we just wait for Basic command, no "Ready"
 1103/     78C :                        
 1104/     78C :                        
 1105/     78C :                        ;************************************************************************************
 1106/     78C :                        ;
 1107/     78C :                        ; receive a line from the keyboard
 1108/     78C :                        								; character $08 as delete key, BACKSPACE on
 1109/     78C :                        								; standard keyboard
 1110/     78C :                        LAB_134B
 1111/     78C : 6100 077E              	BSR		LAB_PRNA				; go print the character
 1112/     790 : 7020                   	MOVEQ		#' ',d0				; load [SPACE]
 1113/     792 : 6100 0778              	BSR		LAB_PRNA				; go print
 1114/     796 : 7008                   	MOVEQ		#$08,d0				; load [BACKSPACE]
 1115/     798 : 6100 0772              	BSR		LAB_PRNA				; go print
 1116/     79C : 5341                   	SUBQ.w	#$01,d1				; decrement the buffer index (delete)
 1117/     79E : 6010                   	BRA.s		LAB_1359				; re-enter loop
 1118/     7A0 :                        
 1119/     7A0 :                        ; print "? " and get BASIC input
 1120/     7A0 :                        ; return a0 pointing to the buffer start
 1121/     7A0 :                        
 1122/     7A0 :                        LAB_INLN
 1123/     7A0 : 6100 0768              	BSR		LAB_18E3				; print "?" character
 1124/     7A4 : 7020                   	MOVEQ		#' ',d0				; load " "
 1125/     7A6 : 6100 0764              	BSR		LAB_PRNA				; go print
 1126/     7AA :                        
 1127/     7AA :                        ; call for BASIC input (main entry point)
 1128/     7AA :                        ; return a0 pointing to the buffer start
 1129/     7AA :                        
 1130/     7AA :                        LAB_1357
 1131/     7AA : 7200                   	MOVEQ		#$00,d1				; clear buffer index
 1132/     7AC : 41EB 0490              	LEA		Ibuffs(a3),a0			; set buffer base pointer
 1133/     7B0 :                        LAB_1359
 1134/     7B0 : 4EAB 040C              	JSR		V_INPT(a3)				; call scan input device
 1135/     7B4 : 64FA                   	BCC.s		LAB_1359				; loop if no byte
 1136/     7B6 :                        
 1137/     7B6 : 67F8                   	BEQ.s		LAB_1359				; loop if null byte
 1138/     7B8 :                        
 1139/     7B8 : B03C 0007              	CMP.b		#$07,d0				; compare with [BELL]
 1140/     7BC : 6718                   	BEQ.s		LAB_1378				; branch if [BELL]
 1141/     7BE :                        
 1142/     7BE : B03C 000D              	CMP.b		#$0D,d0				; compare with [CR]
 1143/     7C2 : 6700 06CA              	BEQ		LAB_1866				; do CR/LF exit if [CR]
 1144/     7C6 :                        
 1145/     7C6 : 4A41                   	TST.w		d1					; set flags on buffer index
 1146/     7C8 : 6606                   	BNE.s		LAB_1374				; branch if not empty
 1147/     7CA :                        
 1148/     7CA :                        ; the next two lines ignore any non printing character and [SPACE] if the input buffer
 1149/     7CA :                        ; is empty
 1150/     7CA :                        
 1151/     7CA : B03C 0020              	CMP.b		#' ',d0				; compare with [SP]+1
 1152/     7CE : 63E0                   	BLS.s		LAB_1359				; if < ignore character
 1153/     7D0 :                        
 1154/     7D0 :                        ;##	CMP.b		#' '+1,d0				; compare with [SP]+1
 1155/     7D0 :                        ;##	BCS.s		LAB_1359				; if < ignore character
 1156/     7D0 :                        
 1157/     7D0 :                        LAB_1374
 1158/     7D0 : B03C 0008              	CMP.b		#$08,d0				; compare with [BACKSPACE]
 1159/     7D4 : 67B6                   	BEQ.s		LAB_134B				; go delete last character
 1160/     7D6 :                        
 1161/     7D6 :                        LAB_1378
 1162/     7D6 : B27C 00FF              	CMP.w		#(Ibuffe-Ibuffs-1),d1		; compare character count with max-1
 1163/     7DA : 640C                   	BCC.s		LAB_138E				; skip store & do [BELL] if buffer full
 1164/     7DC :                        
 1165/     7DC : 1180 1000              	MOVE.b	d0,(a0,d1.w)			; else store in buffer
 1166/     7E0 : 5241                   	ADDQ.w	#$01,d1				; increment index
 1167/     7E2 :                        LAB_137F
 1168/     7E2 : 6100 0728              	BSR		LAB_PRNA				; go print the character
 1169/     7E6 : 60C8                   	BRA.s		LAB_1359				; always loop for next character
 1170/     7E8 :                        
 1171/     7E8 :                        ; announce buffer full
 1172/     7E8 :                        
 1173/     7E8 :                        LAB_138E
 1174/     7E8 : 7007                   	MOVEQ		#$07,d0				; [BELL] character into d0
 1175/     7EA : 60F6                   	BRA.s		LAB_137F				; go print the [BELL] but ignore input character
 1176/     7EC :                        
 1177/     7EC :                        
 1178/     7EC :                        ;************************************************************************************
 1179/     7EC :                        ;
 1180/     7EC :                        ; copy a hex value without crunching
 1181/     7EC :                        
 1182/     7EC :                        LAB_1392
 1183/     7EC : 1180 2000              	MOVE.b	d0,(a0,d2.w)			; save the byte to the output
 1184/     7F0 : 5242                   	ADDQ.w	#1,d2					; increment the buffer save index
 1185/     7F2 :                        
 1186/     7F2 : 5241                   	ADDQ.w	#1,d1					; increment the buffer read index
 1187/     7F4 : 1035 1000              	MOVE.b	(a5,d1.w),d0			; get a byte from the input buffer
 1188/     7F8 : 6700 0094              	BEQ		LAB_13EC				; if [EOL] go save it without crunching
 1189/     7FC :                        
 1190/     7FC : B03C 0020              	CMP.b		#' ',d0				; compare the character with " "
 1191/     800 : 67EA                   	BEQ.s		LAB_1392				; if [SPACE] just go save it and get another
 1192/     802 :                        
 1193/     802 : B03C 0030              	CMP.b		#'0',d0				; compare the character with "0"
 1194/     806 : 654A                   	BCS.s		LAB_13C6				; if < "0" quit the hex save loop
 1195/     808 :                        
 1196/     808 : B03C 0039              	CMP.b		#'9',d0				; compare with "9"
 1197/     80C : 63DE                   	BLS.s		LAB_1392				; if it is "0" to "9" save it and get another
 1198/     80E :                        
 1199/     80E : 7ADF                   	MOVEQ		#-33,d5				; mask xx0x xxxx, ASCII upper case
 1200/     810 : CA00                   	AND.b		d0,d5					; mask the character
 1201/     812 :                        
 1202/     812 : BA3C 0041              	CMP.b		#'A',d5				; compare with "A"
 1203/     816 : 6540                   	BCS.s		LAB_13CC				; if < "A" quit the hex save loop
 1204/     818 :                        
 1205/     818 : BA3C 0046              	CMP.b		#'F',d5				; compare with "F"
 1206/     81C : 63CE                   	BLS.s		LAB_1392				; if it is "A" to "F" save it and get another
 1207/     81E :                        
 1208/     81E : 6038                   	BRA.s		LAB_13CC				; else continue crunching
 1209/     820 :                        
 1210/     820 :                        ; crunch keywords into Basic tokens
 1211/     820 :                        ; crunch from (a5), output to (a0)
 1212/     820 :                        ; returns ..
 1213/     820 :                        ; d4 trashed
 1214/     820 :                        ; d3 trashed
 1215/     820 :                        ; d2 is length
 1216/     820 :                        ; d1 trashed
 1217/     820 :                        ; d0 trashed
 1218/     820 :                        ; a1 trashed
 1219/     820 :                        
 1220/     820 :                        ; this is the improved BASIC crunch routine and is 10 to 100 times faster than the
 1221/     820 :                        ; old list search
 1222/     820 :                        
 1223/     820 :                        LAB_13A6
 1224/     820 : 7200                   	MOVEQ		#0,d1					; clear the read index
 1225/     822 : 2401                   	MOVE.l	d1,d2					; clear the save index
 1226/     824 : 1741 05DD              	MOVE.b	d1,Oquote(a3)			; clear the open quote/DATA flag
 1227/     828 :                        LAB_13AC
 1228/     828 : 7000                   	MOVEQ		#0,d0					; clear word
 1229/     82A : 1035 1000              	MOVE.b	(a5,d1.w),d0			; get byte from input buffer
 1230/     82E : 675E                   	BEQ.s		LAB_13EC				; if null save byte then continue crunching
 1231/     830 :                        
 1232/     830 : B03C 005F              	CMP.b		#'_',d0				; compare with "_"
 1233/     834 : 6458                   	BCC.s		LAB_13EC				; if >= "_" save byte then continue crunching
 1234/     836 :                        
 1235/     836 : B03C 003C              	CMP.b		#'<',d0				; compare with "<"
 1236/     83A : 641C                   	BCC.s		LAB_13CC				; if >= "<" go crunch
 1237/     83C :                        
 1238/     83C : B03C 0030              	CMP.b		#'0',d0				; compare with "0"
 1239/     840 : 644C                   	BCC.s		LAB_13EC				; if >= "0" save byte then continue crunching
 1240/     842 :                        
 1241/     842 : 1740 05DA              	MOVE.b	d0,Asrch(a3)			; save buffer byte as search character
 1242/     846 : B03C 0022              	CMP.b		#$22,d0				; is it quote character?
 1243/     84A : 6776                   	BEQ.s		LAB_1410				; branch if so (copy quoted string)
 1244/     84C :                        
 1245/     84C : B03C 0024              	CMP.b		#'$',d0				; is it the hex value character?
 1246/     850 : 679A                   	BEQ.s		LAB_1392				; if so go copy a hex value
 1247/     852 :                        
 1248/     852 :                        LAB_13C6
 1249/     852 : B03C 002A              	CMP.b		#'*',d0				; compare with "*"
 1250/     856 : 6536                   	BCS.s		LAB_13EC				; if <= "*" save byte then continue crunching
 1251/     858 :                        
 1252/     858 :                        								; crunch rest
 1253/     858 :                        LAB_13CC
 1254/     858 : 082B 0006 05DD         	BTST.b	#6,Oquote(a3)			; test open quote/DATA token flag
 1255/     85E : 662E                   	BNE.s		LAB_13EC				; branch if b6 of Oquote set (was DATA)
 1256/     860 :                        								; go save byte then continue crunching
 1257/     860 :                        
 1258/     860 : 903C 002A              	SUB.b		#$2A,d0				; normalise byte
 1259/     864 : D040                   	ADD.w		d0,d0					; *2 makes word offset (high byte=$00)
 1260/     866 : 43FA 2C1A              	LEA		TAB_CHRT(pc),a1			; get keyword offset table address
 1261/     86A : 3031 0000              	MOVE.w	(a1,d0.w),d0			; get offset into keyword table
 1262/     86E : 6B6E                   	BMI.s		LAB_141F				; branch if no keywords for character
 1263/     870 :                        
 1264/     870 : 43FA 2FA6              	LEA		TAB_STAR(pc),a1			; get keyword table address
 1265/     874 : D2C0                   	ADDA.w	d0,a1					; add keyword offset
 1266/     876 : 76FF                   	MOVEQ		#-1,d3				; clear index
 1267/     878 : 3801                   	MOVE.w	d1,d4					; copy read index
 1268/     87A :                        LAB_13D6
 1269/     87A : 5243                   	ADDQ.w	#1,d3					; increment table index
 1270/     87C : 1031 3000              	MOVE.b	(a1,d3.w),d0			; get byte from table
 1271/     880 :                        LAB_13D8
 1272/     880 : 6B0A                   	BMI.s		LAB_13EA				; branch if token, save token and continue
 1273/     882 :                        								; crunching
 1274/     882 :                        
 1275/     882 : 5244                   	ADDQ.w	#1,d4					; increment read index
 1276/     884 : B035 4000              	CMP.b		(a5,d4.w),d0			; compare byte from input buffer
 1277/     888 : 67F0                   	BEQ.s		LAB_13D6				; loop if character match
 1278/     88A :                        
 1279/     88A : 6040                   	BRA.s		LAB_1417				; branch if no match
 1280/     88C :                        
 1281/     88C :                        LAB_13EA
 1282/     88C : 3204                   	MOVE.w	d4,d1					; update read index
 1283/     88E :                        LAB_13EC
 1284/     88E : 1180 2000              	MOVE.b	d0,(a0,d2.w)			; save byte to output
 1285/     892 : 5242                   	ADDQ.w	#1,d2					; increment buffer save index
 1286/     894 : 5241                   	ADDQ.w	#1,d1					; increment buffer read index
 1287/     896 : 4A00                   	TST.b		d0					; set flags
 1288/     898 : 674A                   	BEQ.s		LAB_142A				; branch if was null [EOL]
 1289/     89A :                        
 1290/     89A :                        								; d0 holds token or byte here
 1291/     89A : 903C 003A              	SUB.b		#$3A,d0				; subtract ":"
 1292/     89E : 6706                   	BEQ.s		LAB_13FF				; branch if it was ":" (is now $00)
 1293/     8A0 :                        
 1294/     8A0 :                        								; d0 now holds token-$3A
 1295/     8A0 : B03C 0049              	CMP.b		#(TK_DATA-$3A),d0			; compare with DATA token - $3A
 1296/     8A4 : 6604                   	BNE.s		LAB_1401				; branch if not DATA
 1297/     8A6 :                        
 1298/     8A6 :                        								; token was : or DATA
 1299/     8A6 :                        LAB_13FF
 1300/     8A6 : 1740 05DD              	MOVE.b	d0,Oquote(a3)			; save token-$3A ($00 for ":", TK_DATA-$3A for
 1301/     8AA :                        								; DATA)
 1302/     8AA :                        LAB_1401
 1303/     8AA : 903C 0055              	SUB.b		#(TK_REM-$3A),d0			; subtract REM token offset
 1304/     8AE : 6600 FF78              	BNE		LAB_13AC				; If wasn't REM then go crunch rest of line
 1305/     8B2 :                        
 1306/     8B2 : 1740 05DA              	MOVE.b	d0,Asrch(a3)			; else was REM so set search for [EOL]
 1307/     8B6 :                        
 1308/     8B6 :                        								; loop for REM, "..." etc.
 1309/     8B6 :                        LAB_1408
 1310/     8B6 : 1035 1000              	MOVE.b	(a5,d1.w),d0			; get byte from input buffer
 1311/     8BA : 67D2                   	BEQ.s		LAB_13EC				; branch if null [EOL]
 1312/     8BC :                        
 1313/     8BC : B02B 05DA              	CMP.b		Asrch(a3),d0			; compare with stored character
 1314/     8C0 : 67CC                   	BEQ.s		LAB_13EC				; branch if match (end quote, REM, :, or DATA)
 1315/     8C2 :                        
 1316/     8C2 :                        								; entry for copy string in quotes, don't crunch
 1317/     8C2 :                        LAB_1410
 1318/     8C2 : 1180 2000              	MOVE.b	d0,(a0,d2.w)			; save byte to output
 1319/     8C6 : 5242                   	ADDQ.w	#1,d2					; increment buffer save index
 1320/     8C8 : 5241                   	ADDQ.w	#1,d1					; increment buffer read index
 1321/     8CA : 60EA                   	BRA.s		LAB_1408				; loop
 1322/     8CC :                        
 1323/     8CC :                        ; not found keyword this go so find the end of this word in the table
 1324/     8CC :                        
 1325/     8CC :                        LAB_1417
 1326/     8CC : 3801                   	MOVE.w	d1,d4					; reset read pointer
 1327/     8CE :                        LAB_141B
 1328/     8CE : 5243                   	ADDQ.w	#1,d3					; increment keyword table pointer, flag
 1329/     8D0 :                        								; unchanged
 1330/     8D0 : 1031 3000              	MOVE.b	(a1,d3.w),d0			; get keyword table byte
 1331/     8D4 : 6AF8                   	BPL.s		LAB_141B				; if not end of keyword go do next byte
 1332/     8D6 :                        
 1333/     8D6 : 5243                   	ADDQ.w	#1,d3					; increment keyword table pointer flag
 1334/     8D8 :                        								; unchanged
 1335/     8D8 : 1031 3000              	MOVE.b	(a1,d3.w),d0			; get keyword table byte
 1336/     8DC : 66A2                   	BNE.s		LAB_13D8				; go test next word if not zero byte (table end)
 1337/     8DE :                        
 1338/     8DE :                        								; reached end of table with no match
 1339/     8DE :                        LAB_141F
 1340/     8DE : 1035 1000              	MOVE.b	(a5,d1.w),d0			; restore byte from input buffer
 1341/     8E2 : 60AA                   	BRA.s		LAB_13EC				; go save byte in output and continue crunching
 1342/     8E4 :                        
 1343/     8E4 :                        								; reached [EOL]
 1344/     8E4 :                        LAB_142A
 1345/     8E4 : 7000                   	MOVEQ		#0,d0					; ensure longword clear
 1346/     8E6 : 0102                   	BTST		d0,d2					; test odd bit (fastest)
 1347/     8E8 : 6706                   	BEQ.s		LAB_142C				; branch if no bytes to fill
 1348/     8EA :                        
 1349/     8EA : 1180 2000              	MOVE.b	d0,(a0,d2.w)			; clear next byte
 1350/     8EE : 5242                   	ADDQ.w	#1,d2					; increment buffer save index
 1351/     8F0 :                        LAB_142C
 1352/     8F0 : 2180 2000              	MOVE.l	d0,(a0,d2.w)			; clear next line pointer, EOT in immediate mode
 1353/     8F4 : 4E75                   	RTS
 1354/     8F6 :                        
 1355/     8F6 :                        
 1356/     8F6 :                        ;************************************************************************************
 1357/     8F6 :                        ;
 1358/     8F6 :                        ; search Basic for d1 line number from start of mem
 1359/     8F6 :                        
 1360/     8F6 :                        LAB_SSLN
 1361/     8F6 : 206B 042E              	MOVEA.l	Smeml(a3),a0			; get start of program mem
 1362/     8FA : 6002                   	BRA.s		LAB_SCLN				; go search for required line from a0
 1363/     8FC :                        
 1364/     8FC :                        LAB_145F
 1365/     8FC : 2040                   	MOVEA.l	d0,a0					; copy next line pointer
 1366/     8FE :                        
 1367/     8FE :                        ; search Basic for d1 line number from a0
 1368/     8FE :                        ; returns Cb=0 if found
 1369/     8FE :                        ; returns a0 pointer to found or next higher (not found) line
 1370/     8FE :                        
 1371/     8FE :                        LAB_SCLN
 1372/     8FE : 2018                   	MOVE.l	(a0)+,d0				; get next line pointer and point to line #
 1373/     900 : 6708                   	BEQ.s		LAB_145E				; is end marker so we're done, do 'no line' exit
 1374/     902 :                        
 1375/     902 : B290                   	CMP.l		(a0),d1				; compare this line # with required line #
 1376/     904 : 6EF6                   	BGT.s		LAB_145F				; loop if required # > this #
 1377/     906 :                        
 1378/     906 : 5948                   	SUBQ.w	#4,a0					; adjust pointer, flags not changed
 1379/     908 : 4E75                   	RTS
 1380/     90A :                        
 1381/     90A :                        LAB_145E
 1382/     90A : 5948                   	SUBQ.w	#4,a0					; adjust pointer, flags not changed
 1383/     90C : 5380                   	SUBQ.l	#1,d0					; make end program found = -1, set carry
 1384/     90E : 4E75                   	RTS
 1385/     910 :                        
 1386/     910 :                        
 1387/     910 :                        ;************************************************************************************
 1388/     910 :                        ;
 1389/     910 :                        ; perform NEW
 1390/     910 :                        
 1391/     910 :                        LAB_NEW
 1392/     910 : 664E                   	BNE.s		RTS_005				; exit if not end of statement (do syntax error)
 1393/     912 :                        
 1394/     912 :                        LAB_1463
 1395/     912 : 206B 042E              	MOVEA.l	Smeml(a3),a0			; point to start of program memory
 1396/     916 : 7000                   	MOVEQ		#0,d0					; clear longword
 1397/     918 : 20C0                   	MOVE.l	d0,(a0)+				; clear first line, next line pointer
 1398/     91A : 2748 0432              	MOVE.l	a0,Sfncl(a3)			; set start of functions
 1399/     91E :                        
 1400/     91E :                        ; reset execution to start, clear variables and flush stack
 1401/     91E :                        
 1402/     91E :                        LAB_1477
 1403/     91E : 2A6B 042E              	MOVEA.l	Smeml(a3),a5			; reset BASIC execute pointer
 1404/     922 : 534D                   	SUBQ.w	#1,a5					; -1 (as end of previous line)
 1405/     924 :                        
 1406/     924 :                        ; "CLEAR" command gets here
 1407/     924 :                        
 1408/     924 :                        LAB_147A
 1409/     924 : 276B 044A 0446         	MOVE.l	Ememl(a3),Sstorl(a3)		; save end of mem as bottom of string space
 1410/     92A : 202B 0432              	MOVE.l	Sfncl(a3),d0			; get start of functions
 1411/     92E : 2740 0436              	MOVE.l	d0,Svarl(a3)			; start of variables
 1412/     932 : 2740 043A              	MOVE.l	d0,Sstrl(a3)			; start of strings
 1413/     936 : 2740 043E              	MOVE.l	d0,Sarryl(a3)			; set start of arrays
 1414/     93A : 2740 0442              	MOVE.l	d0,Earryl(a3)			; set end of arrays
 1415/     93E :                        LAB_1480
 1416/     93E : 7000                   	MOVEQ		#0,d0					; set Zb
 1417/     940 : 1740 05EA              	MOVE.b	d0,ccnull(a3)			; clear get byte countdown
 1418/     944 : 6100 01D0              	BSR		LAB_RESTORE				; perform RESTORE command
 1419/     948 :                        
 1420/     948 :                        ; flush stack & clear continue flag
 1421/     948 :                        
 1422/     948 :                        LAB_1491
 1423/     948 : 49EB 048E              	LEA		des_sk(a3),a4			; reset descriptor stack pointer
 1424/     94C :                        
 1425/     94C : 201F                   	MOVE.l	(sp)+,d0				; pull return address
 1426/     94E : 2E7C 0000 3F00         	MOVE.l	#ram_strt+ram_base,sp			; set stack to RAM start + 1k, flush stack
 1427/     954 : 2F00                   	MOVE.l	d0,-(sp)				; restore return address
 1428/     956 :                        
 1429/     956 : 7000                   	MOVEQ		#0,d0					; clear longword
 1430/     958 : 2740 045A              	MOVE.l	d0,Cpntrl(a3)			; clear continue pointer
 1431/     95C : 1740 05DF              	MOVE.b	d0,Sufnxf(a3)			; clear subscript/FNX flag
 1432/     960 :                        RTS_005
 1433/     960 : 4E75                   	RTS
 1434/     962 :                        
 1435/     962 :                        
 1436/     962 :                        ;************************************************************************************
 1437/     962 :                        ;
 1438/     962 :                        ; perform CLEAR
 1439/     962 :                        
 1440/     962 :                        LAB_CLEAR
 1441/     962 : 67C0                   	BEQ.s		LAB_147A				; if no following byte go do "CLEAR"
 1442/     964 :                        
 1443/     964 : 4E75                   	RTS							; was following byte (go do syntax error)
 1444/     966 :                        
 1445/     966 :                        
 1446/     966 :                        ;************************************************************************************
 1447/     966 :                        ;
 1448/     966 :                        ; perform LIST [n][-m]
 1449/     966 :                        
 1450/     966 :                        LAB_LIST
 1451/     966 : 6512                   	BCS.s		LAB_14BD				; branch if next character numeric (LIST n...)
 1452/     968 :                        
 1453/     968 : 72FF                   	MOVEQ		#-1,d1				; set end to $FFFFFFFF
 1454/     96A : 2741 042A              	MOVE.l	d1,Itemp(a3)			; save to Itemp
 1455/     96E :                        
 1456/     96E : 7200                   	MOVEQ		#0,d1					; set start to $00000000
 1457/     970 : 4A00                   	TST.b		d0					; test next byte
 1458/     972 : 670A                   	BEQ.s		LAB_14C0				; branch if next character [NULL] (LIST)
 1459/     974 :                        
 1460/     974 : B03C 00B3              	CMP.b		#TK_MINUS,d0			; compare with token for -
 1461/     978 : 66E6                   	BNE.s		RTS_005				; exit if not - (LIST -m)
 1462/     97A :                        
 1463/     97A :                        								; LIST [[n]-[m]] this sets the n, if present,
 1464/     97A :                        								; as the start and end
 1465/     97A :                        LAB_14BD
 1466/     97A : 6100 0396              	BSR		LAB_GFPN				; get fixed-point number into temp integer & d1
 1467/     97E :                        LAB_14C0
 1468/     97E : 6100 FF76              	BSR		LAB_SSLN				; search BASIC for d1 line number
 1469/     982 :                        								; (pointer in a0)
 1470/     982 : 6100 093A              	BSR		LAB_GBYT				; scan memory
 1471/     986 : 6716                   	BEQ.s		LAB_14D4				; branch if no more characters
 1472/     988 :                        
 1473/     988 :                        								; this bit checks the - is present
 1474/     988 : B03C 00B3              	CMP.b		#TK_MINUS,d0			; compare with token for -
 1475/     98C : 66D2                   	BNE.s		RTS_005				; return if not "-" (will be Syntax error)
 1476/     98E :                        
 1477/     98E : 72FF                   	MOVEQ		#-1,d1				; set end to $FFFFFFFF
 1478/     990 : 2741 042A              	MOVE.l	d1,Itemp(a3)			; save Itemp
 1479/     994 :                        
 1480/     994 :                        								; LIST [n]-[m] the - was there so see if
 1481/     994 :                        								; there is an m to set as the end value
 1482/     994 : 6100 0926              	BSR		LAB_IGBY				; increment & scan memory
 1483/     998 : 6704                   	BEQ.s		LAB_14D4				; branch if was [NULL] (LIST n-)
 1484/     99A :                        
 1485/     99A : 6100 0376              	BSR		LAB_GFPN				; get fixed-point number into temp integer & d1
 1486/     99E :                        LAB_14D4
 1487/     99E : 177C 0000 05DD         	MOVE.b	#$00,Oquote(a3)			; clear open quote flag
 1488/     9A4 : 6100 04EE              	BSR		LAB_CRLF				; print CR/LF
 1489/     9A8 : 2018                   	MOVE.l	(a0)+,d0				; get next line pointer
 1490/     9AA : 67B4                   	BEQ.s		RTS_005				; if null all done so exit
 1491/     9AC :                        
 1492/     9AC : 2240                   	MOVEA.l	d0,a1					; copy next line pointer
 1493/     9AE : 6100 012C              	BSR		LAB_1629				; do CRTL-C check vector
 1494/     9B2 :                        
 1495/     9B2 : 2018                   	MOVE.l	(a0)+,d0				; get this line #
 1496/     9B4 : B0AB 042A              	CMP.l		Itemp(a3),d0			; compare end line # with this line #
 1497/     9B8 : 62A6                   	BHI.s		RTS_005				; if this line greater all done so exit
 1498/     9BA :                        
 1499/     9BA :                        LAB_14E2
 1500/     9BA : 48E7 00C0              	MOVEM.l	a0-a1,-(sp)				; save registers
 1501/     9BE : 6100 181C              	BSR		LAB_295E				; print d0 as unsigned integer
 1502/     9C2 : 4CDF 0300              	MOVEM.l	(sp)+,a0-a1				; restore registers
 1503/     9C6 : 7020                   	MOVEQ		#$20,d0				; space is the next character
 1504/     9C8 :                        LAB_150C
 1505/     9C8 : 6100 0542              	BSR		LAB_PRNA				; go print the character
 1506/     9CC : B03C 0022              	CMP.b		#$22,d0				; was it " character
 1507/     9D0 : 6606                   	BNE.s		LAB_1519				; branch if not
 1508/     9D2 :                        
 1509/     9D2 :                        								; we're either entering or leaving quotes
 1510/     9D2 : 0A2B 00FF 05DD         	EOR.b		#$FF,Oquote(a3)			; toggle open quote flag
 1511/     9D8 :                        LAB_1519
 1512/     9D8 : 1018                   	MOVE.b	(a0)+,d0				; get byte and increment pointer
 1513/     9DA : 6608                   	BNE.s		LAB_152E				; branch if not [EOL] (go print)
 1514/     9DC :                        
 1515/     9DC :                        								; was [EOL]
 1516/     9DC : 2049                   	MOVEA.l	a1,a0					; copy next line pointer
 1517/     9DE : 2008                   	MOVE.l	a0,d0					; copy to set flags
 1518/     9E0 : 66BC                   	BNE.s		LAB_14D4				; go do next line if not [EOT]
 1519/     9E2 :                        
 1520/     9E2 : 4E75                   	RTS
 1521/     9E4 :                        
 1522/     9E4 :                        LAB_152E
 1523/     9E4 : 6AE2                   	BPL.s		LAB_150C				; just go print it if not token byte
 1524/     9E6 :                        
 1525/     9E6 :                        								; else it was a token byte so maybe uncrunch it
 1526/     9E6 : 4A2B 05DD              	TST.b		Oquote(a3)				; test the open quote flag
 1527/     9EA : 6BDC                   	BMI.s		LAB_150C				; just go print character if open quote set
 1528/     9EC :                        
 1529/     9EC :                        								; else uncrunch BASIC token
 1530/     9EC : 45FA 2AFE              	LEA		LAB_KEYT(pc),a2			; get keyword table address
 1531/     9F0 : 727F                   	MOVEQ		#$7F,d1				; mask into d1
 1532/     9F2 : C200                   	AND.b		d0,d1					; copy and mask token
 1533/     9F4 : E549                   	LSL.w		#2,d1					; *4
 1534/     9F6 : 45F2 1000              	LEA		(a2,d1.w),a2			; get keyword entry address
 1535/     9FA : 101A                   	MOVE.b	(a2)+,d0				; get byte from keyword table
 1536/     9FC : 6100 050E              	BSR		LAB_PRNA				; go print the first character
 1537/     A00 : 7200                   	MOVEQ		#0,d1					; clear d1
 1538/     A02 : 121A                   	MOVE.b	(a2)+,d1				; get remaining length byte from keyword table
 1539/     A04 : 6BD2                   	BMI.s		LAB_1519				; if -ve done so go get next byte
 1540/     A06 :                        
 1541/     A06 : 3012                   	MOVE.w	(a2),d0				; get offset to rest
 1542/     A08 : 45FA 2E0E              	LEA		TAB_STAR(pc),a2			; get keyword table address
 1543/     A0C : 45F2 0000              	LEA		(a2,d0.w),a2			; get address of rest
 1544/     A10 :                        LAB_1540
 1545/     A10 : 101A                   	MOVE.b	(a2)+,d0				; get byte from keyword table
 1546/     A12 : 6100 04F8              	BSR		LAB_PRNA				; go print the character
 1547/     A16 : 51C9 FFF8              	DBF		d1,LAB_1540				; decrement and loop if more to do
 1548/     A1A :                        
 1549/     A1A : 60BC                   	BRA.s		LAB_1519				; go get next byte
 1550/     A1C :                        
 1551/     A1C :                        
 1552/     A1C :                        ;************************************************************************************
 1553/     A1C :                        ;
 1554/     A1C :                        ; perform FOR
 1555/     A1C :                        
 1556/     A1C :                        LAB_FOR
 1557/     A1C : 6100 0396              	BSR		LAB_LET				; go do LET
 1558/     A20 :                        
 1559/     A20 : 202B 0472              	MOVE.l	Lvarpl(a3),d0			; get the loop variable pointer
 1560/     A24 : B0AB 043A              	CMP.l		Sstrl(a3),d0			; compare it with the end of vars memory
 1561/     A28 : 6C00 FC20              	BGE		LAB_TMER				; if greater go do type mismatch error
 1562/     A2C :                        
 1563/     A2C :                        ; test for not less than the start of variables memory if needed
 1564/     A2C :                        ;
 1565/     A2C :                        ;	CMP.l		Svarl(a3),d0			; compare it with the start of variables memory
 1566/     A2C :                        ;	BLT		LAB_TMER				; if not variables memory do type mismatch error
 1567/     A2C :                        
 1568/     A2C :                        ;	MOVEQ		#28,d0				; we need 28 bytes !
 1569/     A2C :                        ;	BSR.s		LAB_1212				; check room on stack for d0 bytes
 1570/     A2C :                        
 1571/     A2C : 6100 0214              	BSR		LAB_SNBS				; scan for next BASIC statement ([:] or [EOL])
 1572/     A30 :                        								; returns a0 as pointer to [:] or [EOL]
 1573/     A30 : 2E88                   	MOVE.l	a0,(sp)				; push onto stack (and dump the return address)
 1574/     A32 : 2F2B 0452              	MOVE.l	Clinel(a3),-(sp)			; push current line onto stack
 1575/     A36 :                        
 1576/     A36 : 70AA                   	MOVEQ		#TK_TO-$100,d0			; set "TO" token
 1577/     A38 : 6100 087A              	BSR		LAB_SCCA				; scan for CHR$(d0) else syntax error/warm start
 1578/     A3C : 6100 0708              	BSR		LAB_CTNM				; check if source is numeric, else type mismatch
 1579/     A40 : 1F2B 05B5              	MOVE.b	Dtypef(a3),-(sp)			; push the FOR variable data type onto stack
 1580/     A44 : 6100 06FE              	BSR		LAB_EVNM				; evaluate expression and check is numeric else
 1581/     A48 :                        								; do type mismatch
 1582/     A48 :                        
 1583/     A48 : 2F2B 0590              	MOVE.l	FAC1_m(a3),-(sp)			; push TO value mantissa
 1584/     A4C : 3F2B 0594              	MOVE.w	FAC1_e(a3),-(sp)			; push TO value exponent and sign
 1585/     A50 :                        
 1586/     A50 : 277C 8000 0000 0590    	MOVE.l	#$80000000,FAC1_m(a3)		; set default STEP size mantissa
 1587/     A58 : 377C 8100 0594         	MOVE.w	#$8100,FAC1_e(a3)			; set default STEP size exponent and sign
 1588/     A5E :                        
 1589/     A5E : 6100 085E              	BSR		LAB_GBYT				; scan memory
 1590/     A62 : B03C 00AF              	CMP.b		#TK_STEP,d0				; compare with STEP token
 1591/     A66 : 6608                   	BNE.s		LAB_15B3				; jump if not "STEP"
 1592/     A68 :                        
 1593/     A68 :                        								; was STEP token so ....
 1594/     A68 : 6100 0852              	BSR		LAB_IGBY				; increment & scan memory
 1595/     A6C : 6100 06D6              	BSR		LAB_EVNM				; evaluate expression & check is numeric
 1596/     A70 :                        								; else do type mismatch
 1597/     A70 :                        LAB_15B3
 1598/     A70 : 2F2B 0590              	MOVE.l	FAC1_m(a3),-(sp)			; push STEP value mantissa
 1599/     A74 : 3F2B 0594              	MOVE.w	FAC1_e(a3),-(sp)			; push STEP value exponent and sign
 1600/     A78 :                        
 1601/     A78 : 2F2B 0472              	MOVE.l	Lvarpl(a3),-(sp)			; push variable pointer for FOR/NEXT
 1602/     A7C : 3F3C 0081              	MOVE.w	#TK_FOR,-(sp)			; push FOR token on stack
 1603/     A80 :                        
 1604/     A80 : 6018                   	BRA.s		LAB_15C2				; go do interpreter inner loop
 1605/     A82 :                        
 1606/     A82 :                        LAB_15DC							; have reached [EOL]+1
 1607/     A82 : 300D                   	MOVE.w	a5,d0					; copy BASIC execute pointer
 1608/     A84 : C07C 0001              	AND.w		#1,d0					; and make line start address even
 1609/     A88 : DAC0                   	ADD.w		d0,a5					; add to BASIC execute pointer
 1610/     A8A : 201D                   	MOVE.l	(a5)+,d0				; get next line pointer
 1611/     A8C : 6700 FC18              	BEQ		LAB_1274				; if null go to immediate mode, no "BREAK"
 1612/     A90 :                        								; message (was immediate or [EOT] marker)
 1613/     A90 :                        
 1614/     A90 : 275D 0452              	MOVE.l	(a5)+,Clinel(a3)			; save (new) current line #
 1615/     A94 :                        LAB_15F6
 1616/     A94 : 6100 0828              	BSR		LAB_GBYT				; get BASIC byte
 1617/     A98 : 611A                   	BSR.s		LAB_15FF				; go interpret BASIC code from (a5)
 1618/     A9A :                        
 1619/     A9A :                        ; interpreter inner loop (re)entry point
 1620/     A9A :                        
 1621/     A9A :                        LAB_15C2
 1622/     A9A : 6140                   	BSR.s		LAB_1629				; do CRTL-C check vector
 1623/     A9C : 4A2B 0452              	TST.b		Clinel(a3)				; test current line #, is -ve for immediate mode
 1624/     AA0 : 6B04                   	BMI.s		LAB_15D1				; branch if immediate mode
 1625/     AA2 :                        
 1626/     AA2 : 274D 045A              	MOVE.l	a5,Cpntrl(a3)			; save BASIC execute pointer as continue pointer
 1627/     AA6 :                        LAB_15D1
 1628/     AA6 : 101D                   	MOVE.b	(a5)+,d0				; get this byte & increment pointer
 1629/     AA8 : 67D8                   	BEQ.s		LAB_15DC				; loop if [EOL]
 1630/     AAA :                        
 1631/     AAA : B03C 003A              	CMP.b		#$3A,d0				; compare with ":"
 1632/     AAE : 67E4                   	BEQ.s		LAB_15F6				; loop if was statement separator
 1633/     AB0 :                        
 1634/     AB0 : 6000 FBC4              	BRA		LAB_SNER				; else syntax error, then warm start
 1635/     AB4 :                        
 1636/     AB4 :                        
 1637/     AB4 :                        ;************************************************************************************
 1638/     AB4 :                        ;
 1639/     AB4 :                        ; interpret BASIC code from (a5)
 1640/     AB4 :                        
 1641/     AB4 :                        LAB_15FF
 1642/     AB4 : 6700 008C              	BEQ		RTS_006				; exit if zero [EOL]
 1643/     AB8 :                        
 1644/     AB8 :                        LAB_1602
 1645/     AB8 : 0A00 0080              	EORI.b	#$80,d0				; normalise token
 1646/     ABC : 6B00 02F6              	BMI		LAB_LET				; if not token, go do implied LET
 1647/     AC0 :                        
 1648/     AC0 : B03C 0028              	CMP.b		#(TK_TAB-$80),d0			; compare normalised token with TAB
 1649/     AC4 : 6400 FBB0              	BCC		LAB_SNER				; branch if d0>=TAB, syntax error/warm start
 1650/     AC8 :                        								; only tokens before TAB can start a statement
 1651/     AC8 :                        
 1652/     AC8 : 4880                   	EXT.w		d0					; byte to word (clear high byte)
 1653/     ACA : D040                   	ADD.w		d0,d0					; *2
 1654/     ACC : 41FA 287C              	LEA		LAB_CTBL(pc),a0			; get vector table base address
 1655/     AD0 : 3030 0000              	MOVE.w	(a0,d0.w),d0			; get offset to vector
 1656/     AD4 : 4870 0000              	PEA		(a0,d0.w)				; push vector
 1657/     AD8 : 6000 07E2              	BRA		LAB_IGBY				; get following byte & execute vector
 1658/     ADC :                        
 1659/     ADC :                        
 1660/     ADC :                        ;************************************************************************************
 1661/     ADC :                        ;
 1662/     ADC :                        ; CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
 1663/     ADC :                        ; key press is detected.
 1664/     ADC :                        
 1665/     ADC :                        LAB_1629
 1666/     ADC : 4EEB 0424              	JMP		V_CTLC(a3)				; ctrl c check vector
 1667/     AE0 :                        
 1668/     AE0 :                        ; if there was a key press it gets back here .....
 1669/     AE0 :                        
 1670/     AE0 :                        LAB_1636
 1671/     AE0 : B03C 0003              	CMP.b		#$03,d0				; compare with CTRL-C
 1672/     AE4 : 670C                   	BEQ.s		LAB_163B				; STOP if was CTRL-C
 1673/     AE6 :                        
 1674/     AE6 :                        LAB_1639
 1675/     AE6 : 4E75                   	RTS
 1676/     AE8 :                        
 1677/     AE8 :                        
 1678/     AE8 :                        ;************************************************************************************
 1679/     AE8 :                        ;
 1680/     AE8 :                        ; perform END
 1681/     AE8 :                        
 1682/     AE8 :                        LAB_END
 1683/     AE8 : 66FC                   	BNE.s		LAB_1639				; exit if something follows STOP
 1684/     AEA : 177C 0000 05DC         	MOVE.b	#0,Breakf(a3)			; clear break flag, indicate program end
 1685/     AF0 :                        
 1686/     AF0 :                        
 1687/     AF0 :                        ;************************************************************************************
 1688/     AF0 :                        ;
 1689/     AF0 :                        ; perform STOP
 1690/     AF0 :                        
 1691/     AF0 :                        LAB_STOP
 1692/     AF0 : 66F4                   	BNE.s		LAB_1639				; exit if something follows STOP
 1693/     AF2 :                        
 1694/     AF2 :                        LAB_163B
 1695/     AF2 : 43EB 0590              	LEA		Ibuffe(a3),a1			; get buffer end
 1696/     AF6 : BBC9                   	CMPA.l	a1,a5					; compare execute address with buffer end
 1697/     AF8 : 650A                   	BCS.s		LAB_164F				; branch if BASIC pointer is in buffer
 1698/     AFA :                        								; can't continue in immediate mode
 1699/     AFA :                        
 1700/     AFA :                        								; else...
 1701/     AFA : 274D 045A              	MOVE.l	a5,Cpntrl(a3)			; save BASIC execute pointer as continue pointer
 1702/     AFE :                        LAB_1647
 1703/     AFE : 276B 0452 0456         	MOVE.l	Clinel(a3),Blinel(a3)		; save break line
 1704/     B04 :                        LAB_164F
 1705/     B04 : 584F                   	ADDQ.w	#4,sp					; dump return address, don't return to execute
 1706/     B06 :                        								; loop
 1707/     B06 : 102B 05DC              	MOVE.b	Breakf(a3),d0			; get break flag
 1708/     B0A : 6700 FB9A              	BEQ		LAB_1274				; go do warm start if was program end
 1709/     B0E :                        
 1710/     B0E : 41FA 2EB3              	LEA		LAB_BMSG(pc),a0			; point to "Break"
 1711/     B12 : 6000 FB84              	BRA		LAB_1269				; print "Break" and do warm start
 1712/     B16 :                        
 1713/     B16 :                        
 1714/     B16 :                        ;************************************************************************************
 1715/     B16 :                        ;
 1716/     B16 :                        ; perform RESTORE
 1717/     B16 :                        
 1718/     B16 :                        LAB_RESTORE
 1719/     B16 : 206B 042E              	MOVEA.l	Smeml(a3),a0			; copy start of memory
 1720/     B1A : 6720                   	BEQ.s		LAB_1624				; branch if next character null (RESTORE)
 1721/     B1C :                        
 1722/     B1C : 6100 01F4              	BSR		LAB_GFPN				; get fixed-point number into temp integer & d1
 1723/     B20 : B2AB 0452              	CMP.l		Clinel(a3),d1			; compare current line # with required line #
 1724/     B24 : 630E                   	BLS.s		LAB_GSCH				; branch if >= (start search from beginning)
 1725/     B26 :                        
 1726/     B26 : 204D                   	MOVEA.l	a5,a0					; copy BASIC execute pointer
 1727/     B28 :                        LAB_RESs
 1728/     B28 : 4A18                   	TST.b		(a0)+					; test next byte & increment pointer
 1729/     B2A : 66FC                   	BNE.s		LAB_RESs				; loop if not EOL
 1730/     B2C :                        
 1731/     B2C : 3008                   	MOVE.w	a0,d0					; copy pointer
 1732/     B2E : C07C 0001              	AND.w		#1,d0					; mask odd bit
 1733/     B32 : D0C0                   	ADD.w		d0,a0					; add pointer
 1734/     B34 :                        								; search for line in Itemp from (a0)
 1735/     B34 :                        LAB_GSCH
 1736/     B34 : 6100 FDC8              	BSR		LAB_SCLN				; search for d1 line number from a0
 1737/     B38 :                        								; returns Cb=0 if found
 1738/     B38 : 6500 FB24              	BCS		LAB_USER				; go do "Undefined statement" error if not found
 1739/     B3C :                        
 1740/     B3C :                        LAB_1624
 1741/     B3C : 4A20                   	TST.b		-(a0)					; decrement pointer (faster)
 1742/     B3E : 2748 0462              	MOVE.l	a0,Dptrl(a3)			; save DATA pointer
 1743/     B42 :                        RTS_006
 1744/     B42 : 4E75                   	RTS
 1745/     B44 :                        
 1746/     B44 :                        
 1747/     B44 :                        ;************************************************************************************
 1748/     B44 :                        ;
 1749/     B44 :                        ; perform NULL
 1750/     B44 :                        
 1751/     B44 :                        LAB_NULL
 1752/     B44 : 6100 10E2              	BSR		LAB_GTBY				; get byte parameter, result in d0 and Itemp
 1753/     B48 : 1740 05E4              	MOVE.b	d0,Nullct(a3)			; save new NULL count
 1754/     B4C : 4E75                   	RTS
 1755/     B4E :                        
 1756/     B4E :                        
 1757/     B4E :                        ;************************************************************************************
 1758/     B4E :                        ;
 1759/     B4E :                        ; perform CONT
 1760/     B4E :                        
 1761/     B4E :                        LAB_CONT
 1762/     B4E : 6600 FB26              	BNE		LAB_SNER				; if following byte exit to do syntax error
 1763/     B52 :                        
 1764/     B52 : 4A2B 0452              	TST.b		Clinel(a3)				; test current line #, is -ve for immediate mode
 1765/     B56 : 6A00 FAE6              	BPL		LAB_CCER				; if running go do can't continue error
 1766/     B5A :                        
 1767/     B5A : 202B 045A              	MOVE.l	Cpntrl(a3),d0			; get continue pointer
 1768/     B5E : 6700 FADE              	BEQ		LAB_CCER				; go do can't continue error if we can't
 1769/     B62 :                        
 1770/     B62 :                        								; we can continue so ...
 1771/     B62 : 2A40                   	MOVEA.l	d0,a5					; save continue pointer as BASIC execute pointer
 1772/     B64 : 276B 0456 0452         	MOVE.l	Blinel(a3),Clinel(a3)		; set break line as current line
 1773/     B6A : 4E75                   	RTS
 1774/     B6C :                        
 1775/     B6C :                        
 1776/     B6C :                        ;************************************************************************************
 1777/     B6C :                        ;
 1778/     B6C :                        ; perform RUN
 1779/     B6C :                        
 1780/     B6C :                        LAB_RUN
 1781/     B6C : 660C                   	BNE.s		LAB_RUNn				; if following byte do RUN n
 1782/     B6E :                        
 1783/     B6E : 6100 FDAE              	BSR		LAB_1477				; execution to start, clear vars & flush stack
 1784/     B72 : 274D 045A              	MOVE.l	a5,Cpntrl(a3)			; save as continue pointer
 1785/     B76 : 6000 FF22              	BRA		LAB_15C2				; go do interpreter inner loop
 1786/     B7A :                        								; (can't RTS, we flushed the stack!)
 1787/     B7A :                        
 1788/     B7A :                        LAB_RUNn
 1789/     B7A : 6100 FDA8              	BSR		LAB_147A				; go do "CLEAR"
 1790/     B7E : 601C                   	BRA.s		LAB_16B0				; get n and do GOTO n
 1791/     B80 :                        
 1792/     B80 :                        
 1793/     B80 :                        ;************************************************************************************
 1794/     B80 :                        ;
 1795/     B80 :                        ; perform DO
 1796/     B80 :                        
 1797/     B80 :                        LAB_DO
 1798/     B80 :                        ;	MOVE.l	#$05,d0				; need 5 bytes for DO
 1799/     B80 :                        ;	BSR.s		LAB_1212				; check room on stack for A bytes
 1800/     B80 : 2F0D                   	MOVE.l	a5,-(sp)				; push BASIC execute pointer on stack
 1801/     B82 : 2F2B 0452              	MOVE.l	Clinel(a3),-(sp)			; push current line on stack
 1802/     B86 : 3F3C 009C              	MOVE.w	#TK_DO,-(sp)			; push token for DO on stack
 1803/     B8A : 487A FF0E              	PEA		LAB_15C2(pc)			; set return address
 1804/     B8E : 6000 072E              	BRA		LAB_GBYT				; scan memory & return to interpreter inner loop
 1805/     B92 :                        
 1806/     B92 :                        
 1807/     B92 :                        ;************************************************************************************
 1808/     B92 :                        ;
 1809/     B92 :                        ; perform GOSUB
 1810/     B92 :                        
 1811/     B92 :                        LAB_GOSUB
 1812/     B92 :                        ;	MOVE.l	#10,d0				; need 10 bytes for GOSUB
 1813/     B92 :                        ;	BSR.s		LAB_1212				; check room on stack for d0 bytes
 1814/     B92 : 2F0D                   	MOVE.l	a5,-(sp)				; push BASIC execute pointer
 1815/     B94 : 2F2B 0452              	MOVE.l	Clinel(a3),-(sp)			; push current line
 1816/     B98 : 3F3C 008D              	MOVE.w	#TK_GOSUB,-(sp)			; push token for GOSUB
 1817/     B9C :                        LAB_16B0
 1818/     B9C : 6100 0720              	BSR		LAB_GBYT				; scan memory
 1819/     BA0 : 487A FEF8              	PEA		LAB_15C2(pc)			; return to interpreter inner loop after GOTO n
 1820/     BA4 :                        
 1821/     BA4 :                        ; this PEA is needed because either we just cleared the stack and have nowhere to return
 1822/     BA4 :                        ; to or, in the case of GOSUB, we have just dropped a load on the stack and the address
 1823/     BA4 :                        ; we whould have returned to is buried. This burried return address will be unstacked by
 1824/     BA4 :                        ; the corresponding RETURN command
 1825/     BA4 :                        
 1826/     BA4 :                        
 1827/     BA4 :                        ;************************************************************************************
 1828/     BA4 :                        ;
 1829/     BA4 :                        ; perform GOTO
 1830/     BA4 :                        
 1831/     BA4 :                        LAB_GOTO
 1832/     BA4 : 6100 016C              	BSR		LAB_GFPN				; get fixed-point number into temp integer & d1
 1833/     BA8 : 206B 042E              	MOVEA.l	Smeml(a3),a0			; get start of memory
 1834/     BAC : B2AB 0452              	CMP.l		Clinel(a3),d1			; compare current line with wanted #
 1835/     BB0 : 630E                   	BLS.s		LAB_16D0				; branch if current # => wanted #
 1836/     BB2 :                        
 1837/     BB2 : 204D                   	MOVEA.l	a5,a0					; copy BASIC execute pointer
 1838/     BB4 :                        LAB_GOTs
 1839/     BB4 : 4A18                   	TST.b		(a0)+					; test next byte & increment pointer
 1840/     BB6 : 66FC                   	BNE.s		LAB_GOTs				; loop if not EOL
 1841/     BB8 :                        
 1842/     BB8 : 3008                   	MOVE.w	a0,d0					; past pad byte(s)
 1843/     BBA : C07C 0001              	AND.w		#1,d0					; mask odd bit
 1844/     BBE : D0C0                   	ADD.w		d0,a0					; add to pointer
 1845/     BC0 :                        
 1846/     BC0 :                        LAB_16D0
 1847/     BC0 : 6100 FD3C              	BSR		LAB_SCLN				; search for d1 line number from a0
 1848/     BC4 :                        								; returns Cb=0 if found
 1849/     BC4 : 6500 FA98              	BCS		LAB_USER				; if carry set go do "Undefined statement" error
 1850/     BC8 :                        
 1851/     BC8 : 2A48                   	MOVEA.l	a0,a5					; copy to basic execute pointer
 1852/     BCA : 534D                   	SUBQ.w	#1,a5					; decrement pointer
 1853/     BCC : 274D 045A              	MOVE.l	a5,Cpntrl(a3)			; save as continue pointer
 1854/     BD0 : 4E75                   	RTS
 1855/     BD2 :                        
 1856/     BD2 :                        
 1857/     BD2 :                        ;************************************************************************************
 1858/     BD2 :                        ;
 1859/     BD2 :                        ; perform LOOP
 1860/     BD2 :                        
 1861/     BD2 :                        LAB_LOOP
 1862/     BD2 : 0C6F 009C 0004         	CMP.w		#TK_DO,4(sp)			; compare token on stack with DO token
 1863/     BD8 : 6600 FA5C              	BNE		LAB_LDER				; branch if no matching DO
 1864/     BDC :                        
 1865/     BDC : 1E00                   	MOVE.b	d0,d7					; copy following token (byte)
 1866/     BDE : 672E                   	BEQ.s		LoopAlways				; if no following token loop forever
 1867/     BE0 :                        
 1868/     BE0 : BE3C 003A              	CMP.b		#':',d7				; compare with ":"
 1869/     BE4 : 6728                   	BEQ.s		LoopAlways				; if no following token loop forever
 1870/     BE6 :                        
 1871/     BE6 : 9E3C 00B0              	SUB.b		#TK_UNTIL,d7			; subtract token for UNTIL
 1872/     BEA : 6708                   	BEQ.s		DoRest				; branch if was UNTIL
 1873/     BEC :                        
 1874/     BEC : 5307                   	SUBQ.b	#1,d7					; decrement result
 1875/     BEE : 6600 FA86              	BNE		LAB_SNER				; if not WHILE go do syntax error & warm start
 1876/     BF2 :                        								; only if the token was WHILE will this fail
 1877/     BF2 :                        
 1878/     BF2 : 7EFF                   	MOVEQ		#-1,d7				; set invert result longword
 1879/     BF4 :                        DoRest
 1880/     BF4 : 6100 06C6              	BSR		LAB_IGBY				; increment & scan memory
 1881/     BF8 : 6100 0562              	BSR		LAB_EVEX				; evaluate expression
 1882/     BFC : 4A2B 0594              	TST.b		FAC1_e(a3)				; test FAC1 exponent
 1883/     C00 : 6706                   	BEQ.s		DoCmp					; if = 0 go do straight compare
 1884/     C02 :                        
 1885/     C02 : 177C 00FF 0594         	MOVE.b	#$FF,FAC1_e(a3)			; else set all bits
 1886/     C08 :                        DoCmp
 1887/     C08 : BF2B 0594              	EOR.b		d7,FAC1_e(a3)			; EOR with invert byte
 1888/     C0C : 6614                   	BNE.s		LoopDone				; if <> 0 clear stack & back to interpreter loop
 1889/     C0E :                        
 1890/     C0E :                        								; loop condition wasn't met so do it again
 1891/     C0E :                        LoopAlways
 1892/     C0E : 276F 0006 0452         	MOVE.l	6(sp),Clinel(a3)			; copy DO current line
 1893/     C14 : 2A6F 000A              	MOVE.l	10(sp),a5				; save BASIC execute pointer
 1894/     C18 :                        
 1895/     C18 : 41FA FE80              	LEA		LAB_15C2(pc),a0			; get return address
 1896/     C1C : 2E88                   	MOVE.l	a0,(sp)				; dump the call to this routine and set the
 1897/     C1E :                        								; return address
 1898/     C1E : 6000 069E              	BRA		LAB_GBYT				; scan memory and return to interpreter inner
 1899/     C22 :                        								; loop
 1900/     C22 :                        
 1901/     C22 :                        								; clear stack & back to interpreter loop
 1902/     C22 :                        LoopDone
 1903/     C22 : 4FEF 000E              	LEA		14(sp),sp				; dump structure and call from stack
 1904/     C26 : 6014                   	BRA.s		LAB_DATA				; go perform DATA (find : or [EOL])
 1905/     C28 :                        
 1906/     C28 :                        
 1907/     C28 :                        ;************************************************************************************
 1908/     C28 :                        ;
 1909/     C28 :                        ; perform RETURN
 1910/     C28 :                        
 1911/     C28 :                        LAB_RETURN
 1912/     C28 : 6616                   	BNE.s		RTS_007				; exit if following token to allow syntax error
 1913/     C2A :                        
 1914/     C2A : 0C6F 008D 0004         	CMP.w		#TK_GOSUB,4(sp)			; compare token from stack with GOSUB
 1915/     C30 : 6600 FA40              	BNE		LAB_RGER				; do RETURN without GOSUB error if no matching
 1916/     C34 :                        								; GOSUB
 1917/     C34 :                        
 1918/     C34 : 5C4F                   	ADDQ.w	#6,sp					; dump calling address & token
 1919/     C36 : 275F 0452              	MOVE.l	(sp)+,Clinel(a3)			; pull current line
 1920/     C3A : 2A5F                   	MOVE.l	(sp)+,a5				; pull BASIC execute pointer
 1921/     C3C :                        								; now do perform "DATA" statement as we could be
 1922/     C3C :                        								; returning into the middle of an ON <var> GOSUB
 1923/     C3C :                        								; n,m,p,q line (the return address used by the
 1924/     C3C :                        								; DATA statement is the one pushed before the
 1925/     C3C :                        								; GOSUB was executed!)
 1926/     C3C :                        
 1927/     C3C :                        
 1928/     C3C :                        ;************************************************************************************
 1929/     C3C :                        ;
 1930/     C3C :                        ; perform DATA
 1931/     C3C :                        
 1932/     C3C :                        LAB_DATA
 1933/     C3C : 6104                   	BSR.s		LAB_SNBS				; scan for next BASIC statement ([:] or [EOL])
 1934/     C3E :                        								; returns a0 as pointer to [:] or [EOL]
 1935/     C3E : 2A48                   	MOVEA.l	a0,a5					; skip rest of statement
 1936/     C40 :                        RTS_007
 1937/     C40 : 4E75                   	RTS
 1938/     C42 :                        
 1939/     C42 :                        
 1940/     C42 :                        ;************************************************************************************
 1941/     C42 :                        ;
 1942/     C42 :                        ; scan for next BASIC statement ([:] or [EOL])
 1943/     C42 :                        ; returns a0 as pointer to [:] or [EOL]
 1944/     C42 :                        
 1945/     C42 :                        LAB_SNBS
 1946/     C42 : 204D                   	MOVEA.l	a5,a0					; copy BASIC execute pointer
 1947/     C44 : 7222                   	MOVEQ		#$22,d1				; set string quote character
 1948/     C46 : 743A                   	MOVEQ		#$3A,d2				; set look for character = ":"
 1949/     C48 : 6008                   	BRA.s		LAB_172D				; go do search
 1950/     C4A :                        
 1951/     C4A :                        LAB_172C
 1952/     C4A : B400                   	CMP.b		d0,d2					; compare with ":"
 1953/     C4C : 6708                   	BEQ.s		RTS_007a				; exit if found
 1954/     C4E :                        
 1955/     C4E : B200                   	CMP.b		d0,d1					; compare with '"'
 1956/     C50 : 670C                   	BEQ.s		LAB_1725				; if found go search for [EOL]
 1957/     C52 :                        
 1958/     C52 :                        LAB_172D
 1959/     C52 : 1018                   	MOVE.b	(a0)+,d0				; get next byte
 1960/     C54 : 66F4                   	BNE.s		LAB_172C				; loop if not null [EOL]
 1961/     C56 :                        
 1962/     C56 :                        RTS_007a
 1963/     C56 : 5348                   	SUBQ.w	#1,a0					; correct pointer
 1964/     C58 : 4E75                   	RTS
 1965/     C5A :                        
 1966/     C5A :                        LAB_1723
 1967/     C5A : B200                   	CMP.b		d0,d1					; compare with '"'
 1968/     C5C : 67F4                   	BEQ.s		LAB_172D				; if found go search for ":" or [EOL]
 1969/     C5E :                        
 1970/     C5E :                        LAB_1725
 1971/     C5E : 1018                   	MOVE.b	(a0)+,d0				; get next byte
 1972/     C60 : 66F8                   	BNE.s		LAB_1723				; loop if not null [EOL]
 1973/     C62 :                        
 1974/     C62 : 60F2                   	BRA.s		RTS_007a				; correct pointer & return
 1975/     C64 :                        
 1976/     C64 :                        
 1977/     C64 :                        ;************************************************************************************
 1978/     C64 :                        ;
 1979/     C64 :                        ; perform IF
 1980/     C64 :                        
 1981/     C64 :                        LAB_IF
 1982/     C64 : 6100 04F6              	BSR		LAB_EVEX				; evaluate expression
 1983/     C68 : 6100 0654              	BSR		LAB_GBYT				; scan memory
 1984/     C6C : B03C 00AD              	CMP.b		#TK_THEN,d0				; compare with THEN token
 1985/     C70 : 6714                   	BEQ.s		LAB_174B				; if it was THEN then continue
 1986/     C72 :                        
 1987/     C72 :                        								; wasn't IF .. THEN so must be IF .. GOTO
 1988/     C72 : B03C 0089              	CMP.b		#TK_GOTO,d0				; compare with GOTO token
 1989/     C76 : 6600 F9FE              	BNE		LAB_SNER				; if not GOTO token do syntax error/warm start
 1990/     C7A :                        
 1991/     C7A :                        								; was GOTO so check for GOTO <n>
 1992/     C7A : 204D                   	MOVE.l	a5,a0					; save the execute pointer
 1993/     C7C : 6100 063E              	BSR		LAB_IGBY				; scan memory, test for a numeric character
 1994/     C80 : 2A48                   	MOVE.l	a0,a5					; restore the execute pointer
 1995/     C82 : 6400 F9F2              	BCC		LAB_SNER				; if not numeric do syntax error/warm start
 1996/     C86 :                        
 1997/     C86 :                        LAB_174B
 1998/     C86 : 102B 0594              	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
 1999/     C8A : 671E                   	BEQ.s		LAB_174E				; if result was zero go look for an ELSE
 2000/     C8C :                        
 2001/     C8C : 6100 062E              	BSR		LAB_IGBY				; increment & scan memory
 2002/     C90 : 6500 FF12              	BCS		LAB_GOTO				; if numeric do GOTO n
 2003/     C94 :                        								; a GOTO <n> will never return to the IF
 2004/     C94 :                        								; statement so there is no need to return
 2005/     C94 :                        								; to this code
 2006/     C94 :                        
 2007/     C94 : B03C 008E              	CMP.b		#TK_RETURN,d0			; compare with RETURN token
 2008/     C98 : 6700 FE1E              	BEQ		LAB_1602				; if RETURN then interpret BASIC code from (a5)
 2009/     C9C :                        								; and don't return here
 2010/     C9C :                        
 2011/     C9C : 6100 FE16              	BSR		LAB_15FF				; else interpret BASIC code from (a5)
 2012/     CA0 :                        
 2013/     CA0 :                        ; the IF was executed and there may be a following ELSE so the code needs to return
 2014/     CA0 :                        ; here to check and ignore the ELSE if present
 2015/     CA0 :                        
 2016/     CA0 : 1015                   	MOVE.b	(a5),d0				; get the next basic byte
 2017/     CA2 : B03C 00A9              	CMP.b		#TK_ELSE,d0				; compare it with the token for ELSE
 2018/     CA6 : 6794                   	BEQ		LAB_DATA				; if ELSE ignore the following statement
 2019/     CA8 :                        
 2020/     CA8 :                        ; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
 2021/     CA8 :                        ; following ELSE will, correctly, cause a syntax error
 2022/     CA8 :                        
 2023/     CA8 : 4E75                   	RTS							; else return to interpreter inner loop
 2024/     CAA :                        
 2025/     CAA :                        ; perform ELSE after IF
 2026/     CAA :                        
 2027/     CAA :                        LAB_174E
 2028/     CAA : 101D                   	MOVE.b	(a5)+,d0				; faster increment past THEN
 2029/     CAC : 163C 00A9              	MOVE.b		#TK_ELSE,d3				; set search for ELSE token
 2030/     CB0 : 183C 008B              	MOVE.b		#TK_IF,d4				; set search for IF token
 2031/     CB4 : 7A00                   	MOVEQ		#0,d5					; clear the nesting depth
 2032/     CB6 :                        LAB_1750
 2033/     CB6 : 101D                   	MOVE.b	(a5)+,d0				; get next BASIC byte & increment ptr
 2034/     CB8 : 6720                   	BEQ.s		LAB_1754				; if EOL correct the pointer and return
 2035/     CBA :                        
 2036/     CBA : B004                   	CMP.b		d4,d0					; compare with "IF" token
 2037/     CBC : 6604                   	BNE.s		LAB_1752				; skip if not nested IF
 2038/     CBE :                        
 2039/     CBE : 5245                   	ADDQ.w	#1,d5					; else increment the nesting depth ..
 2040/     CC0 : 60F4                   	BRA.s		LAB_1750				; .. and continue looking
 2041/     CC2 :                        
 2042/     CC2 :                        LAB_1752
 2043/     CC2 : B003                   	CMP.b		d3,d0					; compare with ELSE token
 2044/     CC4 : 66F0                   	BNE.s		LAB_1750				; if not ELSE continue looking
 2045/     CC6 :                        
 2046/     CC6 :                        LAB_1756
 2047/     CC6 : 51CD FFEE              	DBF		d5,LAB_1750				; loop if still nested
 2048/     CCA :                        
 2049/     CCA :                        ; found the matching ELSE, now do <{n|statement}>
 2050/     CCA :                        
 2051/     CCA : 6100 05F2              	BSR		LAB_GBYT				; scan memory
 2052/     CCE : 6500 FED4              	BCS		LAB_GOTO				; if numeric do GOTO n
 2053/     CD2 :                        								; code will return to the interpreter loop
 2054/     CD2 :                        								; at the tail end of the GOTO <n>
 2055/     CD2 :                        
 2056/     CD2 : 6000 FDE0              	BRA		LAB_15FF				; else interpret BASIC code from (a5)
 2057/     CD6 :                        								; code will return to the interpreter loop
 2058/     CD6 :                        								; at the tail end of the <statement>
 2059/     CD6 :                        
 2060/     CD6 :                        
 2061/     CD6 :                        ;************************************************************************************
 2062/     CD6 :                        ;
 2063/     CD6 :                        ; perform REM, skip (rest of) line
 2064/     CD6 :                        
 2065/     CD6 :                        LAB_REM
 2066/     CD6 : 4A1D                   	TST.b		(a5)+					; test byte & increment pointer
 2067/     CD8 : 66FC                   	BNE.s		LAB_REM				; loop if not EOL
 2068/     CDA :                        
 2069/     CDA :                        LAB_1754
 2070/     CDA : 534D                   	SUBQ.w	#1,a5					; correct the execute pointer
 2071/     CDC : 4E75                   	RTS
 2072/     CDE :                        
 2073/     CDE :                        
 2074/     CDE :                        ;************************************************************************************
 2075/     CDE :                        ;
 2076/     CDE :                        ; perform ON
 2077/     CDE :                        
 2078/     CDE :                        LAB_ON
 2079/     CDE : 6100 0F48              	BSR		LAB_GTBY				; get byte parameter, result in d0 and Itemp
 2080/     CE2 : 1400                   	MOVE.b	d0,d2					; copy byte
 2081/     CE4 : 6100 05D8              	BSR		LAB_GBYT				; restore BASIC byte
 2082/     CE8 : 3F00                   	MOVE.w	d0,-(sp)				; push GOTO/GOSUB token
 2083/     CEA : B03C 008D              	CMP.b		#TK_GOSUB,d0			; compare with GOSUB token
 2084/     CEE : 6708                   	BEQ.s		LAB_176C				; branch if GOSUB
 2085/     CF0 :                        
 2086/     CF0 : B03C 0089              	CMP.b		#TK_GOTO,d0				; compare with GOTO token
 2087/     CF4 : 6600 F980              	BNE		LAB_SNER				; if not GOTO do syntax error, then warm start
 2088/     CF8 :                        
 2089/     CF8 :                        ; next character was GOTO or GOSUB
 2090/     CF8 :                        
 2091/     CF8 :                        LAB_176C
 2092/     CF8 : 5302                   	SUBQ.b	#1,d2					; decrement index (byte value)
 2093/     CFA : 6606                   	BNE.s		LAB_1773				; branch if not zero
 2094/     CFC :                        
 2095/     CFC : 301F                   	MOVE.w	(sp)+,d0				; pull GOTO/GOSUB token
 2096/     CFE : 6000 FDB8              	BRA		LAB_1602				; go execute it
 2097/     D02 :                        
 2098/     D02 :                        LAB_1773
 2099/     D02 : 6100 05B8              	BSR		LAB_IGBY				; increment & scan memory
 2100/     D06 : 610A                   	BSR.s		LAB_GFPN				; get fixed-point number into temp integer & d1
 2101/     D08 :                        								; (skip this n)
 2102/     D08 : B03C 002C              	CMP.b		#$2C,d0				; compare next character with ","
 2103/     D0C : 67EA                   	BEQ.s		LAB_176C				; loop if ","
 2104/     D0E :                        
 2105/     D0E : 301F                   	MOVE.w	(sp)+,d0				; pull GOTO/GOSUB token (run out of options)
 2106/     D10 : 4E75                   	RTS							; and exit
 2107/     D12 :                        
 2108/     D12 :                        
 2109/     D12 :                        ;************************************************************************************
 2110/     D12 :                        ;
 2111/     D12 :                        ; get fixed-point number into temp integer & d1
 2112/     D12 :                        ; interpret number from (a5), leave (a5) pointing to byte after #
 2113/     D12 :                        
 2114/     D12 :                        LAB_GFPN
 2115/     D12 : 7200                   	MOVEQ		#$00,d1				; clear integer register
 2116/     D14 : 2001                   	MOVE.l	d1,d0					; clear d0
 2117/     D16 : 6100 05A6              	BSR		LAB_GBYT				; scan memory, Cb=1 if "0"-"9", & get byte
 2118/     D1A : 642E                   	BCC.s		LAB_1786				; return if carry clear, chr was not "0"-"9"
 2119/     D1C :                        
 2120/     D1C : 2F02                   	MOVE.l	d2,-(sp)				; save d2
 2121/     D1E :                        LAB_1785
 2122/     D1E : 2401                   	MOVE.l	d1,d2					; copy integer register
 2123/     D20 : D281                   	ADD.l		d1,d1					; *2
 2124/     D22 : 6500 F952              	BCS		LAB_SNER				; if overflow do syntax error, then warm start
 2125/     D26 :                        
 2126/     D26 : D281                   	ADD.l		d1,d1					; *4
 2127/     D28 : 6500 F94C              	BCS		LAB_SNER				; if overflow do syntax error, then warm start
 2128/     D2C :                        
 2129/     D2C : D282                   	ADD.l		d2,d1					; *1 + *4
 2130/     D2E : 6500 F946              	BCS		LAB_SNER				; if overflow do syntax error, then warm start
 2131/     D32 :                        
 2132/     D32 : D281                   	ADD.l		d1,d1					; *10
 2133/     D34 : 6500 F940              	BCS		LAB_SNER				; if overflow do syntax error, then warm start
 2134/     D38 :                        
 2135/     D38 : 903C 0030              	SUB.b		#$30,d0				; subtract $30 from byte
 2136/     D3C : D280                   	ADD.l		d0,d1					; add to integer register, the top 24 bits are
 2137/     D3E :                        								; always clear
 2138/     D3E : 6900 F936              	BVS		LAB_SNER				; if overflow do syntax error, then warm start
 2139/     D42 :                        								; this makes the maximum line number 2147483647
 2140/     D42 : 6100 0578              	BSR		LAB_IGBY				; increment & scan memory
 2141/     D46 : 65D6                   	BCS.s		LAB_1785				; loop for next character if "0"-"9"
 2142/     D48 :                        
 2143/     D48 : 241F                   	MOVE.l	(sp)+,d2				; restore d2
 2144/     D4A :                        LAB_1786
 2145/     D4A : 2741 042A              	MOVE.l	d1,Itemp(a3)			; save Itemp
 2146/     D4E : 4E75                   	RTS
 2147/     D50 :                        
 2148/     D50 :                        
 2149/     D50 :                        ;************************************************************************************
 2150/     D50 :                        ;
 2151/     D50 :                        ; perform DEC
 2152/     D50 :                        
 2153/     D50 :                        LAB_DEC
 2154/     D50 : 3F3C 8180              	MOVE.w	#$8180,-(sp)			; set -1 sign/exponent
 2155/     D54 : 600A                   	BRA.s		LAB_17B7				; go do DEC
 2156/     D56 :                        
 2157/     D56 :                        
 2158/     D56 :                        ;************************************************************************************
 2159/     D56 :                        ;
 2160/     D56 :                        ; perform INC
 2161/     D56 :                        
 2162/     D56 :                        LAB_INC
 2163/     D56 : 3F3C 8100              	MOVE.w	#$8100,-(sp)			; set 1 sign/exponent
 2164/     D5A : 6004                   	BRA.s		LAB_17B7				; go do INC
 2165/     D5C :                        
 2166/     D5C :                        								; was "," so another INCR variable to do
 2167/     D5C :                        LAB_17B8
 2168/     D5C : 6100 055E              	BSR		LAB_IGBY				; increment and scan memory
 2169/     D60 :                        LAB_17B7
 2170/     D60 : 6100 076C              	BSR		LAB_GVAR				; get variable address in a0
 2171/     D64 :                        
 2172/     D64 : 6732                   	BEQ.s		LAB_INCT				; if variable not found skip the inc/dec
 2173/     D66 : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
 2174/     D6A :                        								; $00=float
 2175/     D6A : 6B00 F8DE              	BMI		LAB_TMER				; if string do "Type mismatch" error/warm start
 2176/     D6E :                        
 2177/     D6E : 6636                   	BNE.s		LAB_INCI				; go do integer INC/DEC
 2178/     D70 :                        
 2179/     D70 : 2748 0472              	MOVE.l	a0,Lvarpl(a3)			; save var address
 2180/     D74 : 6100 130E              	BSR		LAB_UFAC				; unpack memory (a0) into FAC1
 2181/     D78 : 277C 8000 0000 0598    	MOVE.l	#$80000000,FAC2_m(a3)		; set FAC2 mantissa for 1
 2182/     D80 : 3017                   	MOVE.w	(sp),d0				; move exponent & sign to d0
 2183/     D82 : 3740 059C              	MOVE.w	d0,FAC2_e(a3)			; move exponent & sign to FAC2
 2184/     D86 : 176B 0595 059E         	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; make sign compare = FAC1 sign
 2185/     D8C : B12B 059E              	EOR.b		d0,FAC_sc(a3)			; make sign compare (FAC1_s EOR FAC2_s)
 2186/     D90 : 6100 100E              	BSR		LAB_ADD				; add FAC2 to FAC1
 2187/     D94 : 6100 130A              	BSR		LAB_PFAC				; pack FAC1 into variable (Lvarpl)
 2188/     D98 :                        LAB_INCT
 2189/     D98 : 6100 0524              	BSR		LAB_GBYT				; scan memory
 2190/     D9C : 0C00 002C              	CMPI.b	#$2C,d0				; compare with ","
 2191/     DA0 : 67BA                   	BEQ.s		LAB_17B8				; continue if "," (another variable to do)
 2192/     DA2 :                        
 2193/     DA2 : 544F                   	ADDQ.w	#2,sp					; else dump sign & exponent
 2194/     DA4 : 4E75                   	RTS
 2195/     DA6 :                        
 2196/     DA6 :                        LAB_INCI
 2197/     DA6 : 4A2F 0001              	TST.b		1(sp)					; test sign
 2198/     DAA : 6604                   	BNE.s		LAB_DECI				; branch if DEC
 2199/     DAC :                        
 2200/     DAC : 5290                   	ADDQ.l	#1,(a0)				; increment variable
 2201/     DAE : 60E8                   	BRA.s		LAB_INCT				; go scan for more
 2202/     DB0 :                        
 2203/     DB0 :                        LAB_DECI
 2204/     DB0 : 5390                   	SUBQ.l	#1,(a0)				; decrement variable
 2205/     DB2 : 60E4                   	BRA.s		LAB_INCT				; go scan for more
 2206/     DB4 :                        
 2207/     DB4 :                        
 2208/     DB4 :                        ;************************************************************************************
 2209/     DB4 :                        ;
 2210/     DB4 :                        ; perform LET
 2211/     DB4 :                        
 2212/     DB4 :                        LAB_LET
 2213/     DB4 : 6100 0714              	BSR		LAB_SVAR				; search for or create a variable
 2214/     DB8 :                        								; return the variable address in a0
 2215/     DB8 : 2748 0472              	MOVE.l	a0,Lvarpl(a3)			; save variable address
 2216/     DBC : 1F2B 05B5              	MOVE.b	Dtypef(a3),-(sp)			; push var data type, $80=string, $40=integer,
 2217/     DC0 :                        								; $00=float
 2218/     DC0 : 70BD                   	MOVEQ		#TK_EQUAL-$100,d0			; get = token
 2219/     DC2 : 6100 04F0              	BSR		LAB_SCCA				; scan for CHR$(d0), else do syntax error/warm
 2220/     DC6 :                        								; start
 2221/     DC6 : 6100 0394              	BSR		LAB_EVEX				; evaluate expression
 2222/     DCA : 102B 05B5              	MOVE.b	Dtypef(a3),d0			; copy expression data type
 2223/     DCE : 175F 05B5              	MOVE.b	(sp)+,Dtypef(a3)			; pop variable data type
 2224/     DD2 : E318                   	ROL.b		#1,d0					; set carry if expression type = string
 2225/     DD4 : 6100 0372              	BSR		LAB_CKTM				; type match check, set C for string
 2226/     DD8 : 6700 12C6              	BEQ		LAB_PFAC				; if number pack FAC1 into variable Lvarpl & RET
 2227/     DDC :                        
 2228/     DDC :                        ; string LET
 2229/     DDC :                        
 2230/     DDC :                        LAB_17D5
 2231/     DDC : 246B 0472              	MOVEA.l	Lvarpl(a3),a2			; get pointer to variable
 2232/     DE0 :                        LAB_17D6
 2233/     DE0 : 206B 0590              	MOVEA.l	FAC1_m(a3),a0			; get descriptor pointer
 2234/     DE4 : 2250                   	MOVEA.l	(a0),a1				; get string pointer
 2235/     DE6 : B3EB 0446              	CMP.l		Sstorl(a3),a1			; compare string memory start with string
 2236/     DEA :                        								; pointer
 2237/     DEA : 6516                   	BCS.s		LAB_1811				; if it was in program memory assign the value
 2238/     DEC :                        								; and exit
 2239/     DEC :                        
 2240/     DEC : B1EB 0432              	CMPA.l	Sfncl(a3),a0			; compare functions start with descriptor
 2241/     DF0 :                        								; pointer
 2242/     DF0 : 6510                   	BCS.s		LAB_1811				; branch if >= (string is on stack)
 2243/     DF2 :                        
 2244/     DF2 :                        								; string is variable$ make space and copy string
 2245/     DF2 :                        LAB_1810
 2246/     DF2 : 7200                   	MOVEQ		#0,d1					; clear length
 2247/     DF4 : 3228 0004              	MOVE.w	4(a0),d1				; get string length
 2248/     DF8 : 2050                   	MOVEA.l	(a0),a0				; get string pointer
 2249/     DFA : 6100 0B06              	BSR		LAB_20C9				; copy string
 2250/     DFE : 206B 0590              	MOVEA.l	FAC1_m(a3),a0			; get descriptor pointer back
 2251/     E02 :                        								; clean stack & assign value to string variable
 2252/     E02 :                        LAB_1811
 2253/     E02 : B9C8                   	CMPA.l	a0,a4					; is string on the descriptor stack
 2254/     E04 : 6602                   	BNE.s		LAB_1813				; skip pop if not
 2255/     E06 :                        
 2256/     E06 : 5C4C                   	ADDQ.w	#$06,a4				; else update stack pointer
 2257/     E08 :                        LAB_1813
 2258/     E08 : 24D8                   	MOVE.l	(a0)+,(a2)+				; save pointer to variable
 2259/     E0A : 3490                   	MOVE.w	(a0),(a2)				; save length to variable
 2260/     E0C :                        RTS_008
 2261/     E0C : 4E75                   	RTS
 2262/     E0E :                        
 2263/     E0E :                        
 2264/     E0E :                        ;************************************************************************************
 2265/     E0E :                        ;
 2266/     E0E :                        ; perform GET
 2267/     E0E :                        
 2268/     E0E :                        LAB_GET
 2269/     E0E : 6100 06BA              	BSR		LAB_SVAR				; search for or create a variable
 2270/     E12 :                        								; return the variable address in a0
 2271/     E12 : 2748 0472              	MOVE.l	a0,Lvarpl(a3)			; save variable address as GET variable
 2272/     E16 : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
 2273/     E1A :                        								; $00=float
 2274/     E1A : 6B0C                   	BMI.s		LAB_GETS				; go get string character
 2275/     E1C :                        
 2276/     E1C :                        								; was numeric get
 2277/     E1C : 6100 1DF2              	BSR		INGET					; get input byte
 2278/     E20 : 6100 09BC              	BSR		LAB_1FD0				; convert d0 to unsigned byte in FAC1
 2279/     E24 : 6000 127A              	BRA		LAB_PFAC				; pack FAC1 into variable (Lvarpl) & return
 2280/     E28 :                        
 2281/     E28 :                        LAB_GETS
 2282/     E28 : 7200                   	MOVEQ		#$00,d1				; assume no byte
 2283/     E2A : 2041                   	MOVE.l	d1,a0					; assume null string
 2284/     E2C : 6100 1DE2              	BSR		INGET					; get input byte
 2285/     E30 : 6408                   	BCC.s		LAB_NoSt				; branch if no byte received
 2286/     E32 :                        
 2287/     E32 : 7201                   	MOVEQ		#$01,d1				; string is single byte
 2288/     E34 : 6100 0AFE              	BSR		LAB_2115				; make string space d1 bytes long
 2289/     E38 :                        								; return a0 = pointer, other registers unchanged
 2290/     E38 :                        
 2291/     E38 : 1080                   	MOVE.b	d0,(a0)				; save byte in string (byte IS string!)
 2292/     E3A :                        LAB_NoSt
 2293/     E3A : 6100 0ADE              	BSR		LAB_RTST				; push string on descriptor stack
 2294/     E3E :                        								; a0 = pointer, d1 = length
 2295/     E3E :                        
 2296/     E3E : 609C                   	BRA.s		LAB_17D5				; do string LET & return
 2297/     E40 :                        
 2298/     E40 :                        
 2299/     E40 :                        ;************************************************************************************
 2300/     E40 :                        ;
 2301/     E40 :                        ; PRINT
 2302/     E40 :                        
 2303/     E40 :                        LAB_1829
 2304/     E40 : 6100 00B4              	BSR		LAB_18C6				; print string from stack
 2305/     E44 :                        LAB_182C
 2306/     E44 : 6100 0478              	BSR		LAB_GBYT				; scan memory
 2307/     E48 :                        
 2308/     E48 :                        ; perform PRINT
 2309/     E48 :                        
 2310/     E48 :                        LAB_PRINT
 2311/     E48 : 674A                   	BEQ.s		LAB_CRLF				; if nothing following just print CR/LF
 2312/     E4A :                        
 2313/     E4A :                        LAB_1831
 2314/     E4A : B03C 00A8              	CMP.b		#TK_TAB,d0				; compare with TAB( token
 2315/     E4E : 6764                   	BEQ.s		LAB_18A2				; go do TAB/SPC
 2316/     E50 :                        
 2317/     E50 : B03C 00AC              	CMP.b		#TK_SPC,d0				; compare with SPC( token
 2318/     E54 : 675E                   	BEQ.s		LAB_18A2				; go do TAB/SPC
 2319/     E56 :                        
 2320/     E56 : B03C 002C              	CMP.b		#',',d0				; compare with ","
 2321/     E5A : 6740                   	BEQ.s		LAB_188B				; go do move to next TAB mark
 2322/     E5C :                        
 2323/     E5C : B03C 003B              	CMP.b		#';',d0				; compare with ";"
 2324/     E60 : 6700 0086              	BEQ		LAB_18BD				; if ";" continue with PRINT processing
 2325/     E64 :                        
 2326/     E64 : 6100 02F6              	BSR		LAB_EVEX				; evaluate expression
 2327/     E68 : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
 2328/     E6C :                        								; $00=float
 2329/     E6C : 6BD2                   	BMI.s		LAB_1829				; branch if string
 2330/     E6E :                        
 2331/     E6E :                        ; replace the two lines above with this code
 2332/     E6E :                        
 2333/     E6E :                        ;	MOVE.b	Dtypef(a3),d0			; get data type flag, $80=string, $00=numeric
 2334/     E6E :                        ;	BMI.s		LAB_1829				; branch if string
 2335/     E6E :                        
 2336/     E6E : 6100 13B2              	BSR		LAB_2970				; convert FAC1 to string
 2337/     E72 : 6100 0A60              	BSR		LAB_20AE				; print " terminated string to FAC1 stack
 2338/     E76 :                        
 2339/     E76 :                        ; don't check fit if terminal width byte is zero
 2340/     E76 :                        
 2341/     E76 : 7000                   	MOVEQ		#0,d0					; clear d0
 2342/     E78 : 102B 05E6              	MOVE.b	TWidth(a3),d0			; get terminal width byte
 2343/     E7C : 670C                   	BEQ.s		LAB_185E				; skip check if zero
 2344/     E7E :                        
 2345/     E7E : 902C 0007              	SUB.b		7(a4),d0				; subtract string length
 2346/     E82 : 902B 05E5              	SUB.b		TPos(a3),d0				; subtract terminal position
 2347/     E86 : 6402                   	BCC		LAB_185E				; branch if less than terminal width
 2348/     E88 :                        
 2349/     E88 : 610A                   	BSR.s		LAB_CRLF				; else print CR/LF
 2350/     E8A :                        LAB_185E
 2351/     E8A : 616A                   	BSR.s		LAB_18C6				; print string from stack
 2352/     E8C : 60B6                   	BRA.s		LAB_182C				; always go continue processing line
 2353/     E8E :                        
 2354/     E8E :                        
 2355/     E8E :                        ;************************************************************************************
 2356/     E8E :                        ;
 2357/     E8E :                        ; CR/LF return to BASIC from BASIC input handler
 2358/     E8E :                        ; leaves a0 pointing to the buffer start
 2359/     E8E :                        
 2360/     E8E :                        LAB_1866
 2361/     E8E : 11BC 0000 1000         	MOVE.b	#$00,(a0,d1.w)			; null terminate input
 2362/     E94 :                        
 2363/     E94 :                        ; print CR/LF
 2364/     E94 :                        
 2365/     E94 :                        LAB_CRLF
 2366/     E94 : 700D                   	MOVEQ		#$0D,d0				; load [CR]
 2367/     E96 : 6174                   	BSR.s		LAB_PRNA				; go print the character
 2368/     E98 : 700A                   	MOVEQ		#$0A,d0				; load [LF]
 2369/     E9A : 6070                   	BRA.s		LAB_PRNA				; go print the character & return
 2370/     E9C :                        
 2371/     E9C :                        LAB_188B
 2372/     E9C : 142B 05E5              	MOVE.b	TPos(a3),d2				; get terminal position
 2373/     EA0 : B42B 05E7              	CMP.b		Iclim(a3),d2			; compare with input column limit
 2374/     EA4 : 6504                   	BCS.s		LAB_1898				; branch if less than Iclim
 2375/     EA6 :                        
 2376/     EA6 : 61EC                   	BSR.s		LAB_CRLF				; else print CR/LF (next line)
 2377/     EA8 : 603E                   	BRA.s		LAB_18BD				; continue with PRINT processing
 2378/     EAA :                        
 2379/     EAA :                        LAB_1898
 2380/     EAA : 942B 05E2              	SUB.b		TabSiz(a3),d2			; subtract TAB size
 2381/     EAE : 64FA                   	BCC.s		LAB_1898				; loop if result was >= 0
 2382/     EB0 :                        
 2383/     EB0 : 4402                   	NEG.b		d2					; twos complement it
 2384/     EB2 : 6022                   	BRA.s		LAB_18B7				; print d2 spaces
 2385/     EB4 :                        
 2386/     EB4 :                        								; do TAB/SPC
 2387/     EB4 :                        LAB_18A2
 2388/     EB4 : 3F00                   	MOVE.w	d0,-(sp)				; save token
 2389/     EB6 : 6100 0D6C              	BSR		LAB_SGBY				; increment and get byte, result in d0 and Itemp
 2390/     EBA : 3400                   	MOVE.w	d0,d2					; copy byte
 2391/     EBC : 6100 0400              	BSR		LAB_GBYT				; get basic byte back
 2392/     EC0 : B03C 0029              	CMP.b		#$29,d0				; is next character ")"
 2393/     EC4 : 6600 F7B0              	BNE		LAB_SNER				; if not do syntax error, then warm start
 2394/     EC8 :                        
 2395/     EC8 : 301F                   	MOVE.w	(sp)+,d0				; get token back
 2396/     ECA : B03C 00A8              	CMP.b		#TK_TAB,d0				; was it TAB ?
 2397/     ECE : 6606                   	BNE.s		LAB_18B7				; branch if not (was SPC)
 2398/     ED0 :                        
 2399/     ED0 :                        								; calculate TAB offset
 2400/     ED0 : 942B 05E5              	SUB.b		TPos(a3),d2				; subtract terminal position
 2401/     ED4 : 6312                   	BLS.s		LAB_18BD				; branch if result was <= 0
 2402/     ED6 :                        								; can't TAB backwards or already there
 2403/     ED6 :                        
 2404/     ED6 :                        								; print d2.b spaces
 2405/     ED6 :                        LAB_18B7
 2406/     ED6 : 7000                   	MOVEQ		#0,d0					; clear longword
 2407/     ED8 : 5300                   	SUBQ.b	#1,d0					; make d0 = $FF
 2408/     EDA : C480                   	AND.l		d0,d2					; mask for byte only
 2409/     EDC : 670A                   	BEQ.s		LAB_18BD				; branch if zero
 2410/     EDE :                        
 2411/     EDE : 7020                   	MOVEQ		#$20,d0				; load " "
 2412/     EE0 : 5302                   	SUBQ.b	#1,d2					; adjust for DBF loop
 2413/     EE2 :                        LAB_18B8
 2414/     EE2 : 6128                   	BSR.s		LAB_PRNA				; go print
 2415/     EE4 : 51CA FFFC              	DBF		d2,LAB_18B8				; decrement count and loop if not all done
 2416/     EE8 :                        
 2417/     EE8 :                        								; continue with PRINT processing
 2418/     EE8 :                        LAB_18BD
 2419/     EE8 : 6100 03D2              	BSR		LAB_IGBY				; increment & scan memory
 2420/     EEC : 6600 FF5C              	BNE		LAB_1831				; if byte continue executing PRINT
 2421/     EF0 :                        
 2422/     EF0 : 4E75                   	RTS							; exit if nothing more to print
 2423/     EF2 :                        
 2424/     EF2 :                        
 2425/     EF2 :                        ;************************************************************************************
 2426/     EF2 :                        ;
 2427/     EF2 :                        ; print null terminated string from a0
 2428/     EF2 :                        
 2429/     EF2 :                        LAB_18C3
 2430/     EF2 : 6100 09E0              	BSR		LAB_20AE				; print terminated string to FAC1/stack
 2431/     EF6 :                        
 2432/     EF6 :                        ; print string from stack
 2433/     EF6 :                        
 2434/     EF6 :                        LAB_18C6
 2435/     EF6 : 6100 0BD0              	BSR		LAB_22B6				; pop string off descriptor stack or from memory
 2436/     EFA :                        								; returns with d0 = length, a0 = pointer
 2437/     EFA : 670C                   	BEQ.s		RTS_009				; exit (RTS) if null string
 2438/     EFC :                        
 2439/     EFC : 3200                   	MOVE.w	d0,d1					; copy length & set Z flag
 2440/     EFE : 5341                   	SUBQ.w	#1,d1					; -1 for BF loop
 2441/     F00 :                        LAB_18CD
 2442/     F00 : 1018                   	MOVE.b	(a0)+,d0				; get byte from string
 2443/     F02 : 6108                   	BSR.s		LAB_PRNA				; go print the character
 2444/     F04 : 51C9 FFFA              	DBF		d1,LAB_18CD				; decrement count and loop if not done yet
 2445/     F08 :                        
 2446/     F08 :                        RTS_009
 2447/     F08 : 4E75                   	RTS
 2448/     F0A :                        
 2449/     F0A :                        
 2450/     F0A :                        ;************************************************************************************
 2451/     F0A :                        ;
 2452/     F0A :                        ; print "?" character
 2453/     F0A :                        
 2454/     F0A :                        LAB_18E3
 2455/     F0A : 703F                   	MOVEQ		#$3F,d0				; load "?" character
 2456/     F0C :                        
 2457/     F0C :                        
 2458/     F0C :                        ;************************************************************************************
 2459/     F0C :                        ;
 2460/     F0C :                        ; print character in d0, includes the null handler and infinite line length code
 2461/     F0C :                        ; changes no registers
 2462/     F0C :                        
 2463/     F0C :                        LAB_PRNA
 2464/     F0C : 2F01                   	MOVE.l	d1,-(sp)				; save d1
 2465/     F0E : B03C 0020              	CMP.b		#$20,d0				; compare with " "
 2466/     F12 : 6528                   	BCS.s		LAB_18F9				; branch if less, non printing character
 2467/     F14 :                        
 2468/     F14 :                        								; don't check fit if terminal width byte is zero
 2469/     F14 : 122B 05E6              	MOVE.b	TWidth(a3),d1			; get terminal width
 2470/     F18 : 6610                   	BNE.s		LAB_18F0				; branch if not zero (not infinite length)
 2471/     F1A :                        
 2472/     F1A :                        								; is "infinite line" so check TAB position
 2473/     F1A : 122B 05E5              	MOVE.b	TPos(a3),d1				; get position
 2474/     F1E : 922B 05E2              	SUB.b		TabSiz(a3),d1			; subtract TAB size
 2475/     F22 : 6614                   	BNE.s		LAB_18F7				; skip reset if different
 2476/     F24 :                        
 2477/     F24 : 1741 05E5              	MOVE.b	d1,TPos(a3)				; else reset position
 2478/     F28 : 600E                   	BRA.s		LAB_18F7				; go print character
 2479/     F2A :                        
 2480/     F2A :                        LAB_18F0
 2481/     F2A : B22B 05E5              	CMP.b		TPos(a3),d1				; compare with terminal character position
 2482/     F2E : 6608                   	BNE.s		LAB_18F7				; branch if not at end of line
 2483/     F30 :                        
 2484/     F30 : 2F00                   	MOVE.l	d0,-(sp)				; save d0
 2485/     F32 : 6100 FF60              	BSR		LAB_CRLF				; else print CR/LF
 2486/     F36 : 201F                   	MOVE.l	(sp)+,d0				; restore d0
 2487/     F38 :                        LAB_18F7
 2488/     F38 : 522B 05E5              	ADDQ.b	#$01,TPos(a3)			; increment terminal position
 2489/     F3C :                        LAB_18F9
 2490/     F3C : 4EAB 0412              	JSR		V_OUTP(a3)				; output byte via output vector
 2491/     F40 : B03C 000D              	CMP.b		#$0D,d0				; compare with [CR]
 2492/     F44 : 6618                   	BNE.s		LAB_188A				; branch if not [CR]
 2493/     F46 :                        
 2494/     F46 :                        								; else print nullct nulls after the [CR]
 2495/     F46 : 7200                   	MOVEQ		#$00,d1				; clear d1
 2496/     F48 : 122B 05E4              	MOVE.b	Nullct(a3),d1			; get null count
 2497/     F4C : 670C                   	BEQ.s		LAB_1886				; branch if no nulls
 2498/     F4E :                        
 2499/     F4E : 7000                   	MOVEQ		#$00,d0				; load [NULL]
 2500/     F50 :                        LAB_1880
 2501/     F50 : 4EAB 0412              	JSR		V_OUTP(a3)				; go print the character
 2502/     F54 : 51C9 FFFA              	DBF		d1,LAB_1880				; decrement count and loop if not all done
 2503/     F58 :                        
 2504/     F58 : 700D                   	MOVEQ		#$0D,d0				; restore the character
 2505/     F5A :                        LAB_1886
 2506/     F5A : 1741 05E5              	MOVE.b	d1,TPos(a3)				; clear terminal position
 2507/     F5E :                        LAB_188A
 2508/     F5E : 221F                   	MOVE.l	(sp)+,d1				; restore d1
 2509/     F60 : 4E75                   	RTS
 2510/     F62 :                        
 2511/     F62 :                        
 2512/     F62 :                        ;************************************************************************************
 2513/     F62 :                        ;
 2514/     F62 :                        ; handle bad input data
 2515/     F62 :                        
 2516/     F62 :                        LAB_1904
 2517/     F62 : 2A5F                   	MOVEA.l	(sp)+,a5				; restore execute pointer
 2518/     F64 : 4A2B 05E0              	TST.b		Imode(a3)				; test input mode flag, $00=INPUT, $98=READ
 2519/     F68 : 6A0A                   	BPL.s		LAB_1913				; branch if INPUT (go do redo)
 2520/     F6A :                        
 2521/     F6A : 276B 045E 0452         	MOVE.l	Dlinel(a3),Clinel(a3)		; save DATA line as current line
 2522/     F70 : 6000 F6D8              	BRA		LAB_TMER				; do type mismatch error, then warm start
 2523/     F74 :                        
 2524/     F74 :                        								; mode was INPUT
 2525/     F74 :                        LAB_1913
 2526/     F74 : 41FA 2A76              	LEA		LAB_REDO(pc),a0			; point to redo message
 2527/     F78 : 6100 FF78              	BSR		LAB_18C3				; print null terminated string from memory
 2528/     F7C : 2A6B 045A              	MOVEA.l	Cpntrl(a3),a5			; save continue pointer as BASIC execute pointer
 2529/     F80 : 4E75                   	RTS
 2530/     F82 :                        
 2531/     F82 :                        
 2532/     F82 :                        ;************************************************************************************
 2533/     F82 :                        ;
 2534/     F82 :                        ; perform INPUT
 2535/     F82 :                        
 2536/     F82 :                        LAB_INPUT
 2537/     F82 : 6100 0862              	BSR		LAB_CKRN				; check not direct (back here if ok)
 2538/     F86 : B03C 0022              	CMP.b		#'"',d0				; compare the next byte with open quote
 2539/     F8A : 660E                   	BNE.s		LAB_1934				; if no prompt string just go get the input
 2540/     F8C :                        
 2541/     F8C : 6100 0306              	BSR		LAB_1BC1				; print "..." string
 2542/     F90 : 703B                   	MOVEQ		#';',d0				; set the search character to ";"
 2543/     F92 : 6100 0320              	BSR		LAB_SCCA				; scan for CHR$(d0), else do syntax error/warm
 2544/     F96 :                        								; start
 2545/     F96 : 6100 FF5E              	BSR		LAB_18C6				; print string from Sutill/Sutilh
 2546/     F9A :                        								; finished the prompt, now read the data
 2547/     F9A :                        LAB_1934
 2548/     F9A : 6100 F804              	BSR		LAB_INLN				; print "? " and get BASIC input
 2549/     F9E :                        								; return a0 pointing to the buffer start
 2550/     F9E : 7000                   	MOVEQ		#0,d0					; flag INPUT
 2551/     FA0 : 4A10                   	TST.b		(a0)					; test first byte from buffer
 2552/     FA2 : 660A                   	BNE.s		LAB_1953				; branch if not null input
 2553/     FA4 :                        
 2554/     FA4 : 6000 FB58              	BRA		LAB_1647				; go do BREAK exit
 2555/     FA8 :                        
 2556/     FA8 :                        
 2557/     FA8 :                        ;************************************************************************************
 2558/     FA8 :                        ;
 2559/     FA8 :                        ; perform READ
 2560/     FA8 :                        
 2561/     FA8 :                        LAB_READ
 2562/     FA8 : 206B 0462              	MOVEA.l	Dptrl(a3),a0			; get the DATA pointer
 2563/     FAC : 7098                   	MOVEQ		#$98-$100,d0			; flag READ
 2564/     FAE :                        LAB_1953
 2565/     FAE : 1740 05E0              	MOVE.b	d0,Imode(a3)			; set input mode flag, $00=INPUT, $98=READ
 2566/     FB2 : 2748 0466              	MOVE.l	a0,Rdptrl(a3)			; save READ pointer
 2567/     FB6 :                        
 2568/     FB6 :                        								; READ or INPUT the next variable from list
 2569/     FB6 :                        LAB_195B
 2570/     FB6 : 6100 0512              	BSR		LAB_SVAR				; search for or create a variable
 2571/     FBA :                        								; return the variable address in a0
 2572/     FBA : 2748 0472              	MOVE.l	a0,Lvarpl(a3)			; save variable address as LET variable
 2573/     FBE : 2F0D                   	MOVE.l	a5,-(sp)				; save BASIC execute pointer
 2574/     FC0 :                        LAB_1961
 2575/     FC0 : 2A6B 0466              	MOVEA.l	Rdptrl(a3),a5			; set READ pointer as BASIC execute pointer
 2576/     FC4 : 6100 02F8              	BSR		LAB_GBYT				; scan memory
 2577/     FC8 : 661E                   	BNE.s		LAB_1986				; if not null go get the value
 2578/     FCA :                        
 2579/     FCA :                        								; the pointer was to a null entry
 2580/     FCA : 4A2B 05E0              	TST.b		Imode(a3)				; test input mode flag, $00=INPUT, $98=READ
 2581/     FCE : 6B72                   	BMI.s		LAB_19DD				; branch if READ (go find the next statement)
 2582/     FD0 :                        
 2583/     FD0 :                        								; else the mode was INPUT so get more
 2584/     FD0 : 6100 FF38              	BSR		LAB_18E3				; print a "?" character
 2585/     FD4 : 6100 F7CA              	BSR		LAB_INLN				; print "? " and get BASIC input
 2586/     FD8 :                        								; return a0 pointing to the buffer start
 2587/     FD8 : 4A10                   	TST.b		(a0)					; test the first byte from the buffer
 2588/     FDA : 6604                   	BNE.s		LAB_1984				; if not null input go handle it
 2589/     FDC :                        
 2590/     FDC : 6000 FB20              	BRA		LAB_1647				; else go do the BREAK exit
 2591/     FE0 :                        
 2592/     FE0 :                        LAB_1984
 2593/     FE0 : 2A48                   	MOVEA.l	a0,a5					; set the execute pointer to the buffer
 2594/     FE2 : 534D                   	SUBQ.w	#1,a5					; decrement the execute pointer
 2595/     FE4 :                        
 2596/     FE4 :                        LAB_1985
 2597/     FE4 : 6100 02D6              	BSR		LAB_IGBY				; increment & scan memory
 2598/     FE8 :                        LAB_1986
 2599/     FE8 : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
 2600/     FEC :                        								; $00=float
 2601/     FEC : 6A20                   	BPL.s		LAB_19B0				; branch if numeric
 2602/     FEE :                        
 2603/     FEE :                        								; else get string
 2604/     FEE : 1400                   	MOVE.b	d0,d2					; save search character
 2605/     FF0 : B03C 0022              	CMP.b		#$22,d0				; was it " ?
 2606/     FF4 : 6706                   	BEQ.s		LAB_1999				; branch if so
 2607/     FF6 :                        
 2608/     FF6 : 743A                   	MOVEQ		#':',d2				; set new search character
 2609/     FF8 : 702C                   	MOVEQ		#',',d0				; other search character is ","
 2610/     FFA : 534D                   	SUBQ.w	#1,a5					; decrement BASIC execute pointer
 2611/     FFC :                        LAB_1999
 2612/     FFC : 524D                   	ADDQ.w	#1,a5					; increment BASIC execute pointer
 2613/     FFE : 1600                   	MOVE.b	d0,d3					; set second search character
 2614/    1000 : 204D                   	MOVEA.l	a5,a0					; BASIC execute pointer is source
 2615/    1002 :                        
 2616/    1002 : 6100 08D4              	BSR		LAB_20B4				; print d2/d3 terminated string to FAC1 stack
 2617/    1006 :                        								; d2 = Srchc, d3 = Asrch, a0 is source
 2618/    1006 : 2A4A                   	MOVEA.l	a2,a5					; copy end of string to BASIC execute pointer
 2619/    1008 : 6100 FDD2              	BSR		LAB_17D5				; go do string LET
 2620/    100C : 6010                   	BRA.s		LAB_19B6				; go check string terminator
 2621/    100E :                        
 2622/    100E :                        								; get numeric INPUT
 2623/    100E :                        LAB_19B0
 2624/    100E : 1F2B 05B5              	MOVE.b	Dtypef(a3),-(sp)			; save variable data type
 2625/    1012 : 6100 1DA6              	BSR		LAB_2887				; get FAC1 from string
 2626/    1016 : 175F 05B5              	MOVE.b	(sp)+,Dtypef(a3)			; restore variable data type
 2627/    101A : 6100 1084              	BSR		LAB_PFAC				; pack FAC1 into (Lvarpl)
 2628/    101E :                        LAB_19B6
 2629/    101E : 6100 029E              	BSR		LAB_GBYT				; scan memory
 2630/    1022 : 670A                   	BEQ.s		LAB_19C2				; branch if null (last entry)
 2631/    1024 :                        
 2632/    1024 : B03C 002C              	CMP.b		#',',d0				; else compare with ","
 2633/    1028 : 6600 FF38              	BNE		LAB_1904				; if not "," go handle bad input data
 2634/    102C :                        
 2635/    102C : 524D                   	ADDQ.w	#1,a5					; else was "," so point to next chr
 2636/    102E :                        								; got good input data
 2637/    102E :                        LAB_19C2
 2638/    102E : 274D 0466              	MOVE.l	a5,Rdptrl(a3)			; save the read pointer for now
 2639/    1032 : 2A5F                   	MOVEA.l	(sp)+,a5				; restore the execute pointer
 2640/    1034 : 6100 0288              	BSR		LAB_GBYT				; scan the memory
 2641/    1038 : 6736                   	BEQ.s		LAB_1A03				; if null go do extra ignored message
 2642/    103A :                        
 2643/    103A : 487A FF7A              	PEA		LAB_195B(pc)			; set return address
 2644/    103E : 6000 0272              	BRA		LAB_1C01				; scan for "," else do syntax error/warm start
 2645/    1042 :                        								; then go INPUT next variable from list
 2646/    1042 :                        
 2647/    1042 :                        								; find next DATA statement or do "Out of Data"
 2648/    1042 :                        								; error
 2649/    1042 :                        LAB_19DD
 2650/    1042 : 6100 FBFE              	BSR		LAB_SNBS				; scan for next BASIC statement ([:] or [EOL])
 2651/    1046 :                        								; returns a0 as pointer to [:] or [EOL]
 2652/    1046 : 2A48                   	MOVEA.l	a0,a5					; add index, now = pointer to [EOL]/[EOS]
 2653/    1048 : 524D                   	ADDQ.w	#1,a5					; pointer to next character
 2654/    104A : B03C 003A              	CMP.b		#':',d0				; was it statement end?
 2655/    104E : 6712                   	BEQ.s		LAB_19F6				; branch if [:]
 2656/    1050 :                        
 2657/    1050 :                        								; was [EOL] so find next line
 2658/    1050 :                        
 2659/    1050 : 320D                   	MOVE.w	a5,d1					; past pad byte(s)
 2660/    1052 : C27C 0001              	AND.w		#1,d1					; mask odd bit
 2661/    1056 : DAC1                   	ADD.w		d1,a5					; add pointer
 2662/    1058 : 241D                   	MOVE.l	(a5)+,d2				; get next line pointer
 2663/    105A : 6700 F612              	BEQ		LAB_ODER				; branch if end of program
 2664/    105E :                        
 2665/    105E : 275D 045E              	MOVE.l	(a5)+,Dlinel(a3)			; save current DATA line
 2666/    1062 :                        LAB_19F6
 2667/    1062 : 6100 025A              	BSR		LAB_GBYT				; scan memory
 2668/    1066 : B03C 0083              	CMP.b		#TK_DATA,d0				; compare with "DATA" token
 2669/    106A : 6700 FF78              	BEQ		LAB_1985				; was "DATA" so go do next READ
 2670/    106E :                        
 2671/    106E : 60D2                   	BRA.s		LAB_19DD				; go find next statement if not "DATA"
 2672/    1070 :                        
 2673/    1070 :                        ; end of INPUT/READ routine
 2674/    1070 :                        
 2675/    1070 :                        LAB_1A03
 2676/    1070 : 206B 0466              	MOVEA.l	Rdptrl(a3),a0			; get temp READ pointer
 2677/    1074 : 4A2B 05E0              	TST.b		Imode(a3)				; get input mode flag, $00=INPUT, $98=READ
 2678/    1078 : 6A06                   	BPL.s		LAB_1A0E				; branch if INPUT
 2679/    107A :                        
 2680/    107A : 2748 0462              	MOVE.l	a0,Dptrl(a3)			; else save temp READ pointer as DATA pointer
 2681/    107E : 4E75                   	RTS
 2682/    1080 :                        
 2683/    1080 :                        								; we were getting INPUT
 2684/    1080 :                        LAB_1A0E
 2685/    1080 : 4A10                   	TST.b		(a0)					; test next byte
 2686/    1082 : 6602                   	BNE.s		LAB_1A1B				; error if not end of INPUT
 2687/    1084 :                        
 2688/    1084 : 4E75                   	RTS
 2689/    1086 :                        								; user typed too much
 2690/    1086 :                        LAB_1A1B
 2691/    1086 : 41FA 2954              	LEA		LAB_IMSG(pc),a0			; point to extra ignored message
 2692/    108A : 6000 FE66              	BRA		LAB_18C3				; print null terminated string from memory & RTS
 2693/    108E :                        
 2694/    108E :                        
 2695/    108E :                        ;************************************************************************************
 2696/    108E :                        ;
 2697/    108E :                        ; perform NEXT
 2698/    108E :                        
 2699/    108E :                        LAB_NEXT
 2700/    108E : 6610                   	BNE.s		LAB_1A46				; branch if NEXT var
 2701/    1090 :                        
 2702/    1090 : 584F                   	ADDQ.w	#4,sp					; back past return address
 2703/    1092 : 0C57 0081              	CMP.w		#TK_FOR,(sp)			; is FOR token on stack?
 2704/    1096 : 6600 F5E2              	BNE		LAB_NFER				; if not do NEXT without FOR err/warm start
 2705/    109A :                        
 2706/    109A : 206F 0002              	MOVEA.l	2(sp),a0				; get stacked FOR variable pointer
 2707/    109E : 601C                   	BRA.s		LAB_11BD				; branch always (no variable to search for)
 2708/    10A0 :                        
 2709/    10A0 :                        ; NEXT var
 2710/    10A0 :                        
 2711/    10A0 :                        LAB_1A46
 2712/    10A0 : 6100 042C              	BSR		LAB_GVAR				; get variable address in a0
 2713/    10A4 : 584F                   	ADDQ.w	#4,sp					; back past return address
 2714/    10A6 : 303C 0081              	MOVE.w	#TK_FOR,d0				; set for FOR token
 2715/    10AA : 721C                   	MOVEQ		#$1C,d1				; set for FOR use size
 2716/    10AC : 6002                   	BRA.s		LAB_11A6				; enter loop for next variable search
 2717/    10AE :                        
 2718/    10AE :                        LAB_11A5
 2719/    10AE : DFC1                   	ADDA.l	d1,sp					; add FOR stack use size
 2720/    10B0 :                        LAB_11A6
 2721/    10B0 : B057                   	CMP.w		(sp),d0				; is FOR token on stack?
 2722/    10B2 : 6600 F5C6              	BNE		LAB_NFER				; if not found do NEXT without FOR error and
 2723/    10B6 :                        								; warm start
 2724/    10B6 :                        
 2725/    10B6 :                        								; was FOR token
 2726/    10B6 : B1EF 0002              	CMPA.l	2(sp),a0				; compare var pointer with stacked var pointer
 2727/    10BA : 66F2                   	BNE.s		LAB_11A5				; loop if no match found
 2728/    10BC :                        
 2729/    10BC :                        LAB_11BD
 2730/    10BC : 376F 0006 059C         	MOVE.w	6(sp),FAC2_e(a3)			; get STEP value exponent and sign
 2731/    10C2 : 276F 0008 0598         	MOVE.l	8(sp),FAC2_m(a3)			; get STEP value mantissa
 2732/    10C8 :                        
 2733/    10C8 : 176F 0012 05B5         	MOVE.b	18(sp),Dtypef(a3)			; restore FOR variable data type
 2734/    10CE : 6100 021E              	BSR		LAB_1C19				; check type and unpack (a0)
 2735/    10D2 :                        
 2736/    10D2 : 176B 059D 059E         	MOVE.b	FAC2_s(a3),FAC_sc(a3)		; save FAC2 sign as sign compare
 2737/    10D8 : 102B 0595              	MOVE.b	FAC1_s(a3),d0			; get FAC1 sign
 2738/    10DC : B12B 059E              	EOR.b		d0,FAC_sc(a3)			; EOR to create sign compare
 2739/    10E0 :                        
 2740/    10E0 : 2748 0472              	MOVE.l	a0,Lvarpl(a3)			; save variable pointer
 2741/    10E4 : 6100 0CBA              	BSR		LAB_ADD				; add STEP value to FOR variable
 2742/    10E8 : 176F 0012 05B5         	MOVE.b	18(sp),Dtypef(a3)			; restore FOR variable data type (again)
 2743/    10EE : 6100 0FB0              	BSR		LAB_PFAC				; pack FAC1 into FOR variable (Lvarpl)
 2744/    10F2 :                        
 2745/    10F2 : 376F 000C 059C         	MOVE.w	12(sp),FAC2_e(a3)			; get TO value exponent and sign
 2746/    10F8 : 276F 000E 0598         	MOVE.l	14(sp),FAC2_m(a3)			; get TO value mantissa
 2747/    10FE :                        
 2748/    10FE : 176B 059D 059E         	MOVE.b	FAC2_s(a3),FAC_sc(a3)		; save FAC2 sign as sign compare
 2749/    1104 : 102B 0595              	MOVE.b	FAC1_s(a3),d0			; get FAC1 sign
 2750/    1108 : B12B 059E              	EOR.b		d0,FAC_sc(a3)			; EOR to create sign compare
 2751/    110C :                        
 2752/    110C : 6100 103C              	BSR		LAB_27FA				; compare FAC1 with FAC2 (TO value)
 2753/    1110 :                        								; returns d0=+1 if FAC1 > FAC2
 2754/    1110 :                        								; returns d0= 0 if FAC1 = FAC2
 2755/    1110 :                        								; returns d0=-1 if FAC1 < FAC2
 2756/    1110 :                        
 2757/    1110 : 322F 0006              	MOVE.w	6(sp),d1				; get STEP value exponent and sign
 2758/    1114 : B141                   	EOR.w		d0,d1					; EOR compare result with STEP exponent and sign
 2759/    1116 :                        
 2760/    1116 : 4A00                   	TST.b		d0					; test for =
 2761/    1118 : 6704                   	BEQ.s		LAB_1A90				; branch if = (loop INcomplete)
 2762/    111A :                        
 2763/    111A : 4A01                   	TST.b		d1					; test result
 2764/    111C : 6A0E                   	BPL.s		LAB_1A9B				; branch if > (loop complete)
 2765/    111E :                        
 2766/    111E :                        								; loop back and do it all again
 2767/    111E :                        LAB_1A90
 2768/    111E : 276F 0014 0452         	MOVE.l	20(sp),Clinel(a3)			; reset current line
 2769/    1124 : 2A6F 0018              	MOVE.l	24(sp),a5				; reset BASIC execute pointer
 2770/    1128 : 6000 F970              	BRA		LAB_15C2				; go do interpreter inner loop
 2771/    112C :                        
 2772/    112C :                        								; loop complete so carry on
 2773/    112C :                        LAB_1A9B
 2774/    112C : DEFC 001C              	ADDA.w	#28,sp				; add 28 to dump FOR structure
 2775/    1130 : 6100 018C              	BSR		LAB_GBYT				; scan memory
 2776/    1134 : B03C 002C              	CMP.b		#$2C,d0				; compare with ","
 2777/    1138 : 6600 F960              	BNE		LAB_15C2				; if not "," go do interpreter inner loop
 2778/    113C :                        
 2779/    113C :                        								; was "," so another NEXT variable to do
 2780/    113C : 6100 017E              	BSR		LAB_IGBY				; else increment & scan memory
 2781/    1140 : 6100 FF5E              	BSR		LAB_1A46				; do NEXT (var)
 2782/    1144 :                        
 2783/    1144 :                        
 2784/    1144 :                        ;************************************************************************************
 2785/    1144 :                        ;
 2786/    1144 :                        ; evaluate expression & check is numeric, else do type mismatch
 2787/    1144 :                        
 2788/    1144 :                        LAB_EVNM
 2789/    1144 : 6116                   	BSR.s		LAB_EVEX				; evaluate expression
 2790/    1146 :                        
 2791/    1146 :                        
 2792/    1146 :                        ;************************************************************************************
 2793/    1146 :                        ;
 2794/    1146 :                        ; check if source is numeric, else do type mismatch
 2795/    1146 :                        
 2796/    1146 :                        LAB_CTNM
 2797/    1146 : B040                   	CMP.w		d0,d0					; required type is numeric so clear carry
 2798/    1148 :                        
 2799/    1148 :                        
 2800/    1148 :                        ;************************************************************************************
 2801/    1148 :                        ;
 2802/    1148 :                        ; type match check, set C for string, clear C for numeric
 2803/    1148 :                        
 2804/    1148 :                        LAB_CKTM
 2805/    1148 : 082B 0007 05B5         	BTST.b	#7,Dtypef(a3)			; test data type flag, don't change carry
 2806/    114E : 6606                   	BNE.s		LAB_1ABA				; branch if data type is string
 2807/    1150 :                        
 2808/    1150 :                        								; else data type was numeric
 2809/    1150 : 6500 F4F8              	BCS		LAB_TMER				; if required type is string do type mismatch
 2810/    1154 :                        								; error
 2811/    1154 :                        
 2812/    1154 : 4E75                   	RTS
 2813/    1156 :                        								; data type was string, now check required type
 2814/    1156 :                        LAB_1ABA
 2815/    1156 : 6400 F4F2              	BCC		LAB_TMER				; if required type is numeric do type mismatch
 2816/    115A :                        								; error
 2817/    115A : 4E75                   	RTS
 2818/    115C :                        
 2819/    115C :                        
 2820/    115C :                        ;************************************************************************************
 2821/    115C :                        ;
 2822/    115C :                        ; this routine evaluates any type of expression. first it pushes an end marker so
 2823/    115C :                        ; it knows when the expression has been evaluated, this is a precedence value of zero.
 2824/    115C :                        ; next the first value is evaluated, this can be an in line value, either numeric or
 2825/    115C :                        ; string, a variable or array element of any type, a function or even an expression
 2826/    115C :                        ; in parenthesis. this value is kept in FAC_1
 2827/    115C :                        ; after the value is evaluated a test is made on the next BASIC program byte, if it
 2828/    115C :                        ; is a comparrison operator i.e. "<", "=" or ">", then the corresponding bit is set
 2829/    115C :                        ; in the comparison evaluation flag. this test loops until no more comparrison operators
 2830/    115C :                        ; are found or more than one of any type is found. in the last case an error is generated
 2831/    115C :                        
 2832/    115C :                        ; evaluate expression
 2833/    115C :                        
 2834/    115C :                        LAB_EVEX
 2835/    115C : 534D                   	SUBQ.w	#1,a5					; decrement BASIC execute pointer
 2836/    115E :                        LAB_EVEZ
 2837/    115E : 7200                   	MOVEQ		#0,d1					; clear precedence word
 2838/    1160 : 1741 05B5              	MOVE.b	d1,Dtypef(a3)			; clear the data type, $80=string, $40=integer,
 2839/    1164 :                        								; $00=float
 2840/    1164 : 601C                   	BRA.s		LAB_1ACD				; enter loop
 2841/    1166 :                        
 2842/    1166 :                        ; get vector, set up operator then continue evaluation
 2843/    1166 :                        
 2844/    1166 :                        LAB_1B43
 2845/    1166 : 41FA 22CA              	LEA		LAB_OPPT(pc),a0			; point to operator vector table
 2846/    116A : 3030 1002              	MOVE.w	2(a0,d1.w),d0			; get vector offset
 2847/    116E : 4870 0000              	PEA		(a0,d0.w)				; push vector
 2848/    1172 :                        
 2849/    1172 : 2F2B 0590              	MOVE.l	FAC1_m(a3),-(sp)			; push FAC1 mantissa
 2850/    1176 : 3F2B 0594              	MOVE.w	FAC1_e(a3),-(sp)			; push sign and exponent
 2851/    117A : 1F2B 05E3              	MOVE.b	comp_f(a3),-(sp)			; push comparison evaluation flag
 2852/    117E :                        
 2853/    117E : 3230 1000              	MOVE.w	(a0,d1.w),d1			; get precedence value
 2854/    1182 :                        LAB_1ACD
 2855/    1182 : 3F01                   	MOVE.w	d1,-(sp)				; push precedence value
 2856/    1184 : 6100 00E4              	BSR		LAB_GVAL				; get value from line
 2857/    1188 : 177C 0000 05E3         	MOVE.b	#$00,comp_f(a3)			; clear compare function flag
 2858/    118E :                        LAB_1ADB
 2859/    118E : 6100 012E              	BSR		LAB_GBYT				; scan memory
 2860/    1192 :                        LAB_1ADE
 2861/    1192 : 903C 00BC              	SUB.b		#TK_GT,d0				; subtract token for > (lowest compare function)
 2862/    1196 : 652A                   	BCS.s		LAB_1AFA				; branch if < TK_GT
 2863/    1198 :                        
 2864/    1198 : B03C 0003              	CMP.b		#$03,d0				; compare with ">" to "<" tokens
 2865/    119C : 650A                   	BCS.s		LAB_1AE0				; branch if <= TK_SGN (is compare function)
 2866/    119E :                        
 2867/    119E : 4A2B 05E3              	TST.b		comp_f(a3)				; test compare function flag
 2868/    11A2 : 6660                   	BNE.s		LAB_1B2A				; branch if compare function
 2869/    11A4 :                        
 2870/    11A4 : 6000 0086              	BRA		LAB_1B78				; go do functions
 2871/    11A8 :                        
 2872/    11A8 :                        								; was token for > = or < (d0 = 0, 1 or 2)
 2873/    11A8 :                        LAB_1AE0
 2874/    11A8 : 7201                   	MOVEQ		#1,d1					; set to 0000 0001
 2875/    11AA : E121                   	ASL.b		d0,d1					; 1 if >, 2 if =, 4 if <
 2876/    11AC : 102B 05E3              	MOVE.b	comp_f(a3),d0			; copy old compare function flag
 2877/    11B0 : B32B 05E3              	EOR.b		d1,comp_f(a3)			; EOR in this compare function bit
 2878/    11B4 : B02B 05E3              	CMP.b		comp_f(a3),d0			; compare old with new compare function flag
 2879/    11B8 : 6400 F4BC              	BCC		LAB_SNER				; if new <= old comp_f do syntax error and warm
 2880/    11BC :                        								; start, there was more than one <, = or >
 2881/    11BC : 6100 00FE              	BSR		LAB_IGBY				; increment & scan memory
 2882/    11C0 : 60D0                   	BRA.s		LAB_1ADE				; go do next character
 2883/    11C2 :                        
 2884/    11C2 :                        								; token is < ">" or > "<" tokens
 2885/    11C2 :                        LAB_1AFA
 2886/    11C2 : 4A2B 05E3              	TST.b		comp_f(a3)				; test compare function flag
 2887/    11C6 : 663C                   	BNE.s		LAB_1B2A				; branch if compare function
 2888/    11C8 :                        
 2889/    11C8 :                        								; was < TK_GT so is operator or lower
 2890/    11C8 : D03C 000A              	ADD.b	#(TK_GT-TK_PLUS),d0			; add # of operators (+ -	; / ^ AND OR EOR)
 2891/    11CC : 645E                   	BCC.s		LAB_1B78				; branch if < + operator
 2892/    11CE :                        
 2893/    11CE : 6608                   	BNE.s		LAB_1B0B				; branch if not + token
 2894/    11D0 :                        
 2895/    11D0 : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
 2896/    11D4 :                        								; $00=float
 2897/    11D4 : 6B00 087E              	BMI		LAB_224D				; type is string & token was +
 2898/    11D8 :                        
 2899/    11D8 :                        LAB_1B0B
 2900/    11D8 : 7200                   	MOVEQ		#0,d1					; clear longword
 2901/    11DA : D000                   	ADD.b		d0,d0					; *2
 2902/    11DC : D000                   	ADD.b		d0,d0					; *4
 2903/    11DE : 1200                   	MOVE.b	d0,d1					; copy to index
 2904/    11E0 :                        LAB_1B13
 2905/    11E0 : 301F                   	MOVE.w	(sp)+,d0				; pull previous precedence
 2906/    11E2 : 41FA 224E              	LEA		LAB_OPPT(pc),a0			; set pointer to operator table
 2907/    11E6 : B070 1000              	CMP.w		(a0,d1.w),d0			; compare with this opperator precedence
 2908/    11EA : 6446                   	BCC.s		LAB_1B7D				; branch if previous precedence (d0) >=
 2909/    11EC :                        
 2910/    11EC : 6100 FF58              	BSR		LAB_CTNM				; check if source is numeric, else type mismatch
 2911/    11F0 :                        LAB_1B1C
 2912/    11F0 : 3F00                   	MOVE.w	d0,-(sp)				; save precedence
 2913/    11F2 :                        LAB_1B1D
 2914/    11F2 : 6100 FF72              	BSR		LAB_1B43				; get vector, set-up operator and continue
 2915/    11F6 :                        								; evaluation
 2916/    11F6 : 301F                   	MOVE.w	(sp)+,d0				; restore precedence
 2917/    11F8 : 222B 05D8              	MOVE.l	prstk(a3),d1			; get stacked function pointer
 2918/    11FC : 6A22                   	BPL.s		LAB_1B3C				; branch if stacked values
 2919/    11FE :                        
 2920/    11FE : 3000                   	MOVE.w	d0,d0					; copy precedence (set flags)
 2921/    1200 : 672E                   	BEQ.s		LAB_1B7B				; exit if done
 2922/    1202 :                        
 2923/    1202 : 603C                   	BRA.s		LAB_1B86				; else pop FAC2 & return (do function)
 2924/    1204 :                        
 2925/    1204 :                        								; was compare function (< = >)
 2926/    1204 :                        LAB_1B2A
 2927/    1204 : 102B 05B5              	MOVE.b	Dtypef(a3),d0			; get data type flag
 2928/    1208 : 122B 05E3              	MOVE.b	comp_f(a3),d1			; get compare function flag
 2929/    120C : D000                   	ADD.b		d0,d0					; string bit flag into X bit
 2930/    120E : D301                   	ADDX.b	d1,d1					; shift compare function flag
 2931/    1210 :                        
 2932/    1210 : 177C 0000 05B5         	MOVE.b	#0,Dtypef(a3)			; clear data type flag, $00=float
 2933/    1216 : 1741 05E3              	MOVE.b	d1,comp_f(a3)			; save new compare function flag
 2934/    121A : 534D                   	SUBQ.w	#1,a5					; decrement BASIC execute pointer
 2935/    121C : 7230                   	MOVEQ		#(TK_LT-TK_PLUS)*4,d1		; set offset to last operator entry
 2936/    121E : 60C0                   	BRA.s		LAB_1B13				; branch always
 2937/    1220 :                        
 2938/    1220 :                        LAB_1B3C
 2939/    1220 : 41FA 2210              	LEA		LAB_OPPT(pc),a0			; point to function vector table
 2940/    1224 : B070 1000              	CMP.w		(a0,d1.w),d0			; compare with this opperator precedence
 2941/    1228 : 6416                   	BCC.s		LAB_1B86				; branch if d0 >=, pop FAC2 & return
 2942/    122A :                        
 2943/    122A : 60C4                   	BRA.s		LAB_1B1C				; branch always
 2944/    122C :                        
 2945/    122C :                        ; do functions
 2946/    122C :                        
 2947/    122C :                        LAB_1B78
 2948/    122C : 72FF                   	MOVEQ		#-1,d1				; flag all done
 2949/    122E : 301F                   	MOVE.w	(sp)+,d0				; pull precedence word
 2950/    1230 :                        LAB_1B7B
 2951/    1230 : 6732                   	BEQ.s		LAB_1B9D				; exit if done
 2952/    1232 :                        
 2953/    1232 :                        LAB_1B7D
 2954/    1232 : B07C 0064              	CMP.w		#$64,d0				; compare previous precedence with $64
 2955/    1236 : 6704                   	BEQ.s		LAB_1B84				; branch if was $64 (< function can be string)
 2956/    1238 :                        
 2957/    1238 : 6100 FF0C              	BSR		LAB_CTNM				; check if source is numeric, else type mismatch
 2958/    123C :                        LAB_1B84
 2959/    123C : 2741 05D8              	MOVE.l	d1,prstk(a3)			; save current operator index
 2960/    1240 :                        
 2961/    1240 :                        								; pop FAC2 & return
 2962/    1240 :                        LAB_1B86
 2963/    1240 : 101F                   	MOVE.b	(sp)+,d0				; pop comparison evaluation flag
 2964/    1242 : 1200                   	MOVE.b	d0,d1					; copy comparison evaluation flag
 2965/    1244 : E208                   	LSR.b		#1,d0					; shift out comparison evaluation lowest bit
 2966/    1246 : 1740 05E1              	MOVE.b	d0,Cflag(a3)			; save comparison evaluation flag
 2967/    124A : 375F 059C              	MOVE.w	(sp)+,FAC2_e(a3)			; pop exponent and sign
 2968/    124E : 275F 0598              	MOVE.l	(sp)+,FAC2_m(a3)			; pop mantissa
 2969/    1252 : 176B 059D 059E         	MOVE.b	FAC2_s(a3),FAC_sc(a3)		; copy FAC2 sign
 2970/    1258 : 102B 0595              	MOVE.b	FAC1_s(a3),d0			; get FAC1 sign
 2971/    125C : B12B 059E              	EOR.b		d0,FAC_sc(a3)			; EOR FAC1 sign and set sign compare
 2972/    1260 :                        
 2973/    1260 : E209                   	LSR.b		#1,d1					; type bit into X and C
 2974/    1262 : 4E75                   	RTS
 2975/    1264 :                        
 2976/    1264 :                        LAB_1B9D
 2977/    1264 : 102B 0594              	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
 2978/    1268 : 4E75                   	RTS
 2979/    126A :                        
 2980/    126A :                        
 2981/    126A :                        ;************************************************************************************
 2982/    126A :                        ;
 2983/    126A :                        ; get a value from the BASIC line
 2984/    126A :                        
 2985/    126A :                        LAB_GVAL
 2986/    126A : 6150                   	BSR.s		LAB_IGBY				; increment & scan memory
 2987/    126C : 6500 1B4C              	BCS		LAB_2887				; if numeric get FAC1 from string & return
 2988/    1270 :                        
 2989/    1270 : 4A00                   	TST.b		d0					; test byte
 2990/    1272 : 6B00 0090              	BMI		LAB_1BD0				; if -ve go test token values
 2991/    1276 :                        
 2992/    1276 :                        								; else it is either a string, number, variable
 2993/    1276 :                        								; or (<expr>)
 2994/    1276 : B03C 0024              	CMP.b		#'$',d0				; compare with "$"
 2995/    127A : 6700 1B3E              	BEQ		LAB_2887				; if "$" get hex number from string & return
 2996/    127E :                        
 2997/    127E : B03C 0025              	CMP.b		#'%',d0				; else compare with "%"
 2998/    1282 : 6700 1B36              	BEQ		LAB_2887				; if "%" get binary number from string & return
 2999/    1286 :                        
 3000/    1286 : B03C 002E              	CMP.b		#$2E,d0				; compare with "."
 3001/    128A : 6700 1B2E              	BEQ		LAB_2887				; if so get FAC1 from string and return
 3002/    128E :                        								; (e.g. .123)
 3003/    128E :                        
 3004/    128E :                        								; wasn't a number so ...
 3005/    128E : B03C 0022              	CMP.b		#$22,d0				; compare with "
 3006/    1292 : 660C                   	BNE.s		LAB_1BF3				; if not open quote it must be a variable or
 3007/    1294 :                        								; open bracket
 3008/    1294 :                        
 3009/    1294 :                        								; was open quote so get the enclosed string
 3010/    1294 :                        
 3011/    1294 :                        ; print "..." string to string stack
 3012/    1294 :                        
 3013/    1294 :                        LAB_1BC1
 3014/    1294 : 101D                   	MOVE.b	(a5)+,d0				; increment BASIC execute pointer (past ")
 3015/    1296 :                        								; fastest/shortest method
 3016/    1296 : 204D                   	MOVEA.l	a5,a0					; copy basic execute pointer (string start)
 3017/    1298 : 6100 063A              	BSR		LAB_20AE				; print " terminated string to stack
 3018/    129C : 2A4A                   	MOVEA.l	a2,a5					; restore BASIC execute pointer from temp
 3019/    129E : 4E75                   	RTS
 3020/    12A0 :                        
 3021/    12A0 :                        ; get value from line .. continued
 3022/    12A0 :                        								; wasn't any sort of number so ...
 3023/    12A0 :                        LAB_1BF3
 3024/    12A0 : B03C 0028              	CMP.b		#'(',d0				; compare with "("
 3025/    12A4 : 6644                   	BNE.s		LAB_1C18				; if not "(" get (var) and return value in FAC1
 3026/    12A6 :                        								; and $ flag
 3027/    12A6 :                        
 3028/    12A6 :                        
 3029/    12A6 :                        ;************************************************************************************
 3030/    12A6 :                        ;
 3031/    12A6 :                        ; evaluate expression within parentheses
 3032/    12A6 :                        
 3033/    12A6 :                        LAB_1BF7
 3034/    12A6 : 6100 FEB6              	BSR		LAB_EVEZ				; evaluate expression (no decrement)
 3035/    12AA :                        
 3036/    12AA :                        
 3037/    12AA :                        ;************************************************************************************
 3038/    12AA :                        ;
 3039/    12AA :                        ; all the 'scan for' routines return the character after the sought character
 3040/    12AA :                        
 3041/    12AA :                        ; scan for ")", else do syntax error, then warm start
 3042/    12AA :                        
 3043/    12AA :                        LAB_1BFB
 3044/    12AA : 7029                   	MOVEQ		#$29,d0				; load d0 with ")"
 3045/    12AC : 6006                   	BRA.s		LAB_SCCA
 3046/    12AE :                        
 3047/    12AE :                        
 3048/    12AE :                        ;************************************************************************************
 3049/    12AE :                        ;
 3050/    12AE :                        ; scan for "," and get byte, else do Syntax error then warm start
 3051/    12AE :                        
 3052/    12AE :                        LAB_SCGB
 3053/    12AE : 487A 0978              	PEA		LAB_GTBY(pc)			; return address is to get byte parameter
 3054/    12B2 :                        
 3055/    12B2 :                        
 3056/    12B2 :                        ;************************************************************************************
 3057/    12B2 :                        ;
 3058/    12B2 :                        ; scan for ",", else do syntax error, then warm start
 3059/    12B2 :                        
 3060/    12B2 :                        LAB_1C01
 3061/    12B2 : 702C                   	MOVEQ		#$2C,d0				; load d0 with ","
 3062/    12B4 :                        
 3063/    12B4 :                        
 3064/    12B4 :                        ;************************************************************************************
 3065/    12B4 :                        ;
 3066/    12B4 :                        ; scan for CHR$(d0) , else do syntax error, then warm start
 3067/    12B4 :                        
 3068/    12B4 :                        LAB_SCCA
 3069/    12B4 : B01D                   	CMP.b		(a5)+,d0				; check next byte is = d0
 3070/    12B6 : 6706                   	BEQ.s		LAB_GBYT				; if so go get next
 3071/    12B8 :                        
 3072/    12B8 : 6000 F3BC              	BRA		LAB_SNER				; else do syntax error/warm start
 3073/    12BC :                        
 3074/    12BC :                        
 3075/    12BC :                        ;************************************************************************************
 3076/    12BC :                        ;
 3077/    12BC :                        ; BASIC increment and scan memory routine
 3078/    12BC :                        
 3079/    12BC :                        LAB_IGBY
 3080/    12BC : 101D                   	MOVE.b	(a5)+,d0				; get byte & increment pointer
 3081/    12BE :                        
 3082/    12BE :                        ; scan memory routine, exit with Cb = 1 if numeric character
 3083/    12BE :                        ; also skips any spaces encountered
 3084/    12BE :                        
 3085/    12BE :                        LAB_GBYT
 3086/    12BE : 1015                   	MOVE.b	(a5),d0				; get byte
 3087/    12C0 :                        
 3088/    12C0 : B03C 0020              	CMP.b		#$20,d0				; compare with " "
 3089/    12C4 : 67F6                   	BEQ.s		LAB_IGBY				; if " " go do next
 3090/    12C6 :                        
 3091/    12C6 :                        ; test current BASIC byte, exit with Cb = 1 if numeric character
 3092/    12C6 :                        
 3093/    12C6 : B03C 00A9              	CMP.b		#TK_ELSE,d0				; compare with the token for ELSE
 3094/    12CA : 640E                   	BCC.s		RTS_001				; exit if >= (not numeric, carry clear)
 3095/    12CC :                        
 3096/    12CC : B03C 003A              	CMP.b		#$3A,d0				; compare with ":"
 3097/    12D0 : 6408                   	BCC.s		RTS_001				; exit if >= (not numeric, carry clear)
 3098/    12D2 :                        
 3099/    12D2 : 1C3C 00D0              	MOVE.b		#$D0,d6				; set -"0"
 3100/    12D6 : D006                   	ADD.b		d6,d0					; add -"0"
 3101/    12D8 : 9006                   	SUB.b		d6,d0					; subtract -"0"
 3102/    12DA :                        RTS_001							; carry set if byte = "0"-"9"
 3103/    12DA : 4E75                   	RTS
 3104/    12DC :                        
 3105/    12DC :                        
 3106/    12DC :                        ;************************************************************************************
 3107/    12DC :                        ;
 3108/    12DC :                        ; set-up for - operator
 3109/    12DC :                        
 3110/    12DC :                        LAB_1C11
 3111/    12DC : 6100 FE68              	BSR		LAB_CTNM				; check if source is numeric, else type mismatch
 3112/    12E0 : 7228                   	MOVEQ	#(TK_GT-TK_PLUS)*4,d1			; set offset from base to - operator
 3113/    12E2 :                        LAB_1C13
 3114/    12E2 : 4FEF 0004              	LEA		4(sp),sp				; dump GVAL return address
 3115/    12E6 : 6000 FF0A              	BRA		LAB_1B1D				; continue evaluating expression
 3116/    12EA :                        
 3117/    12EA :                        
 3118/    12EA :                        ;************************************************************************************
 3119/    12EA :                        ;
 3120/    12EA :                        ; variable name set-up
 3121/    12EA :                        ; get (var), return value in FAC_1 & data type flag
 3122/    12EA :                        
 3123/    12EA :                        LAB_1C18
 3124/    12EA : 6100 01E2              	BSR		LAB_GVAR				; get variable address in a0
 3125/    12EE :                        
 3126/    12EE :                        ; return existing variable value
 3127/    12EE :                        
 3128/    12EE :                        LAB_1C19
 3129/    12EE : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
 3130/    12F2 :                        								; $00=float
 3131/    12F2 : 6700 0D90              	BEQ		LAB_UFAC				; if float unpack memory (a0) into FAC1 and
 3132/    12F6 :                        								; return
 3133/    12F6 :                        
 3134/    12F6 : 6A06                   	BPL.s		LAB_1C1A				; if integer unpack memory (a0) into FAC1
 3135/    12F8 :                        								; and return
 3136/    12F8 :                        
 3137/    12F8 : 2748 0590              	MOVE.l	a0,FAC1_m(a3)			; else save descriptor pointer in FAC1
 3138/    12FC : 4E75                   	RTS
 3139/    12FE :                        
 3140/    12FE :                        LAB_1C1A
 3141/    12FE : 2010                   	MOVE.l	(a0),d0				; get integer value
 3142/    1300 : 6000 04BC              	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & return
 3143/    1304 :                        
 3144/    1304 :                        
 3145/    1304 :                        ;************************************************************************************
 3146/    1304 :                        ;
 3147/    1304 :                        ; get value from line .. continued
 3148/    1304 :                        ; do tokens
 3149/    1304 :                        
 3150/    1304 :                        LAB_1BD0
 3151/    1304 : B03C 00B3              	CMP.b		#TK_MINUS,d0			; compare with token for -
 3152/    1308 : 67D2                   	BEQ.s		LAB_1C11				; branch if - token (do set-up for - operator)
 3153/    130A :                        
 3154/    130A :                        								; wasn't -123 so ...
 3155/    130A : B03C 00B2              	CMP.b		#TK_PLUS,d0				; compare with token for +
 3156/    130E : 6700 FF5A              	BEQ		LAB_GVAL				; branch if + token (+n = n so ignore leading +)
 3157/    1312 :                        
 3158/    1312 : B03C 00AE              	CMP.b		#TK_NOT,d0				; compare with token for NOT
 3159/    1316 : 6606                   	BNE.s		LAB_1BE7				; branch if not token for NOT
 3160/    1318 :                        
 3161/    1318 :                        								; was NOT token
 3162/    1318 : 323C 002C              	MOVE.w	#(TK_EQUAL-TK_PLUS)*4,d1		; offset to NOT function
 3163/    131C : 60C4                   	BRA.s		LAB_1C13				; do set-up for function then execute
 3164/    131E :                        
 3165/    131E :                        								; wasn't +, - or NOT so ...
 3166/    131E :                        LAB_1BE7
 3167/    131E : B03C 00AB              	CMP.b		#TK_FN,d0				; compare with token for FN
 3168/    1322 : 6700 0514              	BEQ		LAB_201E				; if FN go evaluate FNx
 3169/    1326 :                        
 3170/    1326 :                        								; wasn't +, -, NOT or FN so ...
 3171/    1326 : 903C 00BF              	SUB.b		#TK_SGN,d0				; compare with token for SGN & normalise
 3172/    132A : 6500 F34A              	BCS		LAB_SNER				; if < SGN token then do syntax error
 3173/    132E :                        
 3174/    132E :                        ; get value from line .. continued
 3175/    132E :                        ; only functions left so set up function references
 3176/    132E :                        
 3177/    132E :                        ; new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
 3178/    132E :                        ; to process function calls. now the function vector is computed and pushed on the stack
 3179/    132E :                        ; and the preprocess offset is read. if the preprocess offset is non zero then the vector
 3180/    132E :                        ; is calculated and the routine called, if not this routine just does RTS. whichever
 3181/    132E :                        ; happens the RTS at the end of this routine, or the preprocess routine calls, the
 3182/    132E :                        ; function code
 3183/    132E :                        
 3184/    132E :                        ; this also removes some less than elegant code that was used to bypass type checking
 3185/    132E :                        ; for functions that returned strings
 3186/    132E :                        
 3187/    132E : C07C 007F              	AND.w		#$7F,d0				; mask byte
 3188/    1332 : D040                   	ADD.w		d0,d0					; *2 (2 bytes per function offset)
 3189/    1334 :                        
 3190/    1334 : 41FA 20B0              	LEA		LAB_FTBL(pc),a0			; pointer to functions vector table
 3191/    1338 : 3230 0000              	MOVE.w	(a0,d0.w),d1			; get function vector offset
 3192/    133C : 4870 1000              	PEA		(a0,d1.w)				; push function vector
 3193/    1340 :                        
 3194/    1340 : 41FA 2058              	LEA		LAB_FTPP(pc),a0			; pointer to functions preprocess vector table
 3195/    1344 : 3030 0000              	MOVE.w	(a0,d0.w),d0			; get function preprocess vector offset
 3196/    1348 : 6712                   	BEQ.s		LAB_1C2A				; no preprocess vector so go do function
 3197/    134A :                        
 3198/    134A : 41F0 0000              	LEA		(a0,d0.w),a0			; get function preprocess vector
 3199/    134E : 4ED0                   	JMP		(a0)					; go do preprocess routine then function
 3200/    1350 :                        
 3201/    1350 :                        
 3202/    1350 :                        ;************************************************************************************
 3203/    1350 :                        ;
 3204/    1350 :                        ; process string expression in parenthesis
 3205/    1350 :                        
 3206/    1350 :                        LAB_PPFS
 3207/    1350 : 6100 FF54              	BSR		LAB_1BF7				; process expression in parenthesis
 3208/    1354 : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type
 3209/    1358 : 6A00 F2F0              	BPL		LAB_TMER				; if numeric do Type missmatch Error/warm start
 3210/    135C :                        
 3211/    135C :                        LAB_1C2A
 3212/    135C : 4E75                   	RTS							; else do function
 3213/    135E :                        
 3214/    135E :                        
 3215/    135E :                        ;************************************************************************************
 3216/    135E :                        ;
 3217/    135E :                        ; process numeric expression in parenthesis
 3218/    135E :                        
 3219/    135E :                        LAB_PPFN
 3220/    135E : 6100 FF46              	BSR		LAB_1BF7				; process expression in parenthesis
 3221/    1362 : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type
 3222/    1366 : 6B00 F2E2              	BMI		LAB_TMER				; if string do Type missmatch Error/warm start
 3223/    136A :                        
 3224/    136A : 4E75                   	RTS							; else do function
 3225/    136C :                        
 3226/    136C :                        
 3227/    136C :                        ;************************************************************************************
 3228/    136C :                        ;
 3229/    136C :                        ; set numeric data type and increment BASIC execute pointer
 3230/    136C :                        
 3231/    136C :                        LAB_PPBI
 3232/    136C : 177C 0000 05B5         	MOVE.b	#$00,Dtypef(a3)			; clear data type flag, $00=float
 3233/    1372 : 101D                   	MOVE.b	(a5)+,d0				; get next BASIC byte
 3234/    1374 : 4E75                   	RTS							; do function
 3235/    1376 :                        
 3236/    1376 :                        
 3237/    1376 :                        ;************************************************************************************
 3238/    1376 :                        ;
 3239/    1376 :                        ; process string for LEFT$, RIGHT$ or MID$
 3240/    1376 :                        
 3241/    1376 :                        LAB_LRMS
 3242/    1376 : 6100 FDE6              	BSR		LAB_EVEZ				; evaluate (should be string) expression
 3243/    137A : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type flag
 3244/    137E : 6A00 F2CA              	BPL		LAB_TMER				; if type is not string do type mismatch error
 3245/    1382 :                        
 3246/    1382 : 141D                   	MOVE.b	(a5)+,d2				; get BASIC byte
 3247/    1384 : B43C 002C              	CMP.b		#',',d2				; compare with comma
 3248/    1388 : 6600 F2EC              	BNE		LAB_SNER				; if not "," go do syntax error/warm start
 3249/    138C :                        
 3250/    138C : 2F2B 0590              	MOVE.l	FAC1_m(a3),-(sp)			; save descriptor pointer
 3251/    1390 : 6100 08AC              	BSR		LAB_GTWO				; get word parameter, result in d0 and Itemp
 3252/    1394 : 205F                   	MOVEA.l	(sp)+,a0				; restore descriptor pointer
 3253/    1396 : 4E75                   	RTS							; do function
 3254/    1398 :                        
 3255/    1398 :                        
 3256/    1398 :                        ;************************************************************************************
 3257/    1398 :                        ;
 3258/    1398 :                        ; process numeric expression(s) for BIN$ or HEX$
 3259/    1398 :                        
 3260/    1398 :                        LAB_BHSS
 3261/    1398 : 6100 FDC4              	BSR		LAB_EVEZ				; evaluate expression (no decrement)
 3262/    139C : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type
 3263/    13A0 : 6B00 F2A8              	BMI		LAB_TMER				; if string do Type missmatch Error/warm start
 3264/    13A4 :                        
 3265/    13A4 : 6100 0DD0              	BSR		LAB_2831				; convert FAC1 floating to fixed
 3266/    13A8 :                        								; result in d0 and Itemp
 3267/    13A8 : 7200                   	MOVEQ		#0,d1					; set default to no leading "0"s
 3268/    13AA : 141D                   	MOVE.b	(a5)+,d2				; get BASIC byte
 3269/    13AC : B43C 002C              	CMP.b		#',',d2				; compare with comma
 3270/    13B0 : 660C                   	BNE.s		LAB_BHCB				; if not "," go check close bracket
 3271/    13B2 :                        
 3272/    13B2 : 2F00                   	MOVE.l	d0,-(sp)				; copy number to stack
 3273/    13B4 : 6100 0872              	BSR		LAB_GTBY				; get byte value
 3274/    13B8 : 2200                   	MOVE.l	d0,d1					; copy leading 0s #
 3275/    13BA : 201F                   	MOVE.l	(sp)+,d0				; restore number from stack
 3276/    13BC : 141D                   	MOVE.b	(a5)+,d2				; get BASIC byte
 3277/    13BE :                        LAB_BHCB
 3278/    13BE : B43C 0029              	CMP.b		#')',d2				; compare with close bracket
 3279/    13C2 : 6600 F2B2              	BNE		LAB_SNER				; if not ")" do Syntax Error/warm start
 3280/    13C6 :                        
 3281/    13C6 : 4E75                   	RTS							; go do function
 3282/    13C8 :                        
 3283/    13C8 :                        
 3284/    13C8 :                        ;************************************************************************************
 3285/    13C8 :                        ;
 3286/    13C8 :                        ; perform EOR
 3287/    13C8 :                        
 3288/    13C8 :                        LAB_EOR
 3289/    13C8 : 6116                   	BSR.s		GetFirst				; get two values for OR, AND or EOR
 3290/    13CA :                        								; first in d0, and Itemp, second in d2
 3291/    13CA : B580                   	EOR.l		d2,d0					; EOR values
 3292/    13CC : 6000 03F0              	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & RET
 3293/    13D0 :                        
 3294/    13D0 :                        
 3295/    13D0 :                        ;************************************************************************************
 3296/    13D0 :                        ;
 3297/    13D0 :                        ; perform OR
 3298/    13D0 :                        
 3299/    13D0 :                        LAB_OR
 3300/    13D0 : 610E                   	BSR.s		GetFirst				; get two values for OR, AND or EOR
 3301/    13D2 :                        								; first in d0, and Itemp, second in d2
 3302/    13D2 : 8082                   	OR.l		d2,d0					; do OR
 3303/    13D4 : 6000 03E8              	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & RET
 3304/    13D8 :                        
 3305/    13D8 :                        
 3306/    13D8 :                        ;************************************************************************************
 3307/    13D8 :                        ;
 3308/    13D8 :                        ; perform AND
 3309/    13D8 :                        
 3310/    13D8 :                        LAB_AND
 3311/    13D8 : 6106                   	BSR.s		GetFirst				; get two values for OR, AND or EOR
 3312/    13DA :                        								; first in d0, and Itemp, second in d2
 3313/    13DA : C082                   	AND.l		d2,d0					; do AND
 3314/    13DC : 6000 03E0              	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & RET
 3315/    13E0 :                        
 3316/    13E0 :                        
 3317/    13E0 :                        ;************************************************************************************
 3318/    13E0 :                        ;
 3319/    13E0 :                        ; get two values for OR, AND, EOR
 3320/    13E0 :                        ; first in d0, second in d2
 3321/    13E0 :                        
 3322/    13E0 :                        GetFirst
 3323/    13E0 : 6100 0228              	BSR		LAB_EVIR				; evaluate integer expression (no sign check)
 3324/    13E4 :                        								; result in d0 and Itemp
 3325/    13E4 : 2400                   	MOVE.l	d0,d2					; copy second value
 3326/    13E6 : 6100 0CF6              	BSR		LAB_279B				; copy FAC2 to FAC1, get first value in
 3327/    13EA :                        								; expression
 3328/    13EA : 6000 021E              	BRA		LAB_EVIR				; evaluate integer expression (no sign check)
 3329/    13EE :                        								; result in d0 and Itemp & return
 3330/    13EE :                        
 3331/    13EE :                        
 3332/    13EE :                        ;************************************************************************************
 3333/    13EE :                        ;
 3334/    13EE :                        ; perform NOT
 3335/    13EE :                        
 3336/    13EE :                        LAB_EQUAL
 3337/    13EE : 6100 021A              	BSR		LAB_EVIR				; evaluate integer expression (no sign check)
 3338/    13F2 :                        								; result in d0 and Itemp
 3339/    13F2 : 4680                   	NOT.l		d0					; bitwise invert
 3340/    13F4 : 6000 03C8              	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & RET
 3341/    13F8 :                        
 3342/    13F8 :                        
 3343/    13F8 :                        ;************************************************************************************
 3344/    13F8 :                        ;
 3345/    13F8 :                        ; perform comparisons
 3346/    13F8 :                        ; do < compare
 3347/    13F8 :                        
 3348/    13F8 :                        LAB_LTHAN
 3349/    13F8 : 6100 FD4E              	BSR		LAB_CKTM				; type match check, set C for string
 3350/    13FC : 6506                   	BCS.s		LAB_1CAE				; branch if string
 3351/    13FE :                        
 3352/    13FE :                        								; do numeric < compare
 3353/    13FE : 6100 0D4A              	BSR		LAB_27FA				; compare FAC1 with FAC2
 3354/    1402 :                        								; returns d0=+1 if FAC1 > FAC2
 3355/    1402 :                        								; returns d0= 0 if FAC1 = FAC2
 3356/    1402 :                        								; returns d0=-1 if FAC1 < FAC2
 3357/    1402 : 6042                   	BRA.s		LAB_1CF2				; process result
 3358/    1404 :                        
 3359/    1404 :                        								; do string < compare
 3360/    1404 :                        LAB_1CAE
 3361/    1404 : 177C 0000 05B5         	MOVE.b	#$00,Dtypef(a3)			; clear data type, $80=string, $40=integer,
 3362/    140A :                        								; $00=float
 3363/    140A : 6100 06BC              	BSR		LAB_22B6				; pop string off descriptor stack, or from top
 3364/    140E :                        								; of string space returns d0 = length,
 3365/    140E :                        								; a0 = pointer
 3366/    140E : 2248                   	MOVEA.l	a0,a1					; copy string 2 pointer
 3367/    1410 : 2200                   	MOVE.l	d0,d1					; copy string 2 length
 3368/    1412 : 206B 0598              	MOVEA.l	FAC2_m(a3),a0			; get string 1 descriptor pointer
 3369/    1416 : 6100 06B4              	BSR		LAB_22BA				; pop (a0) descriptor, returns with ..
 3370/    141A :                        								; d0 = length, a0 = pointer
 3371/    141A : 2400                   	MOVE.l	d0,d2					; copy length
 3372/    141C : 6604                   	BNE.s		LAB_1CB5				; branch if not null string
 3373/    141E :                        
 3374/    141E : 4A81                   	TST.l		d1					; test if string 2 is null also
 3375/    1420 : 6724                   	BEQ.s		LAB_1CF2				; if so do string 1 = string 2
 3376/    1422 :                        
 3377/    1422 :                        LAB_1CB5
 3378/    1422 : 9481                   	SUB.l		d1,d2					; subtract string 2 length
 3379/    1424 : 670C                   	BEQ.s		LAB_1CD5				; branch if strings = length
 3380/    1426 :                        
 3381/    1426 : 6504                   	BCS.s		LAB_1CD4				; branch if string 1 < string 2
 3382/    1428 :                        
 3383/    1428 : 70FF                   	MOVEQ		#-1,d0				; set for string 1 > string 2
 3384/    142A : 6008                   	BRA.s		LAB_1CD6				; go do character comapare
 3385/    142C :                        
 3386/    142C :                        LAB_1CD4
 3387/    142C : 2200                   	MOVE.l	d0,d1					; string 1 length is compare length
 3388/    142E : 7001                   	MOVEQ		#1,d0					; and set for string 1 < string 2
 3389/    1430 : 6002                   	BRA.s		LAB_1CD6				; go do character comapare
 3390/    1432 :                        
 3391/    1432 :                        LAB_1CD5
 3392/    1432 : 2002                   	MOVE.l	d2,d0					; set for string 1 = string 2
 3393/    1434 :                        LAB_1CD6
 3394/    1434 : 5381                   	SUBQ.l	#1,d1					; adjust length for DBcc loop
 3395/    1436 :                        
 3396/    1436 :                        								; d1 is length to compare, d0 is <=> for length
 3397/    1436 :                        								; a0 is string 1 pointer, a1 is string 2 pointer
 3398/    1436 :                        LAB_1CE6
 3399/    1436 : B308                   	CMPM.b	(a0)+,(a1)+				; compare string bytes (1 with 2)
 3400/    1438 : 56C9 FFFC              	DBNE		d1,LAB_1CE6				; loop if same and not end yet
 3401/    143C :                        
 3402/    143C : 6708                   	BEQ.s		LAB_1CF2				; if = to here, then go use length compare
 3403/    143E :                        
 3404/    143E : 6404                   	BCC.s		LAB_1CDB				; else branch if string 1 > string 2
 3405/    1440 :                        
 3406/    1440 : 70FF                   	MOVEQ		#-1,d0				; else set for string 1 < string 2
 3407/    1442 : 6002                   	BRA.s		LAB_1CF2				; go set result
 3408/    1444 :                        
 3409/    1444 :                        LAB_1CDB
 3410/    1444 : 7001                   	MOVEQ		#1,d0					; and set for string 1 > string 2
 3411/    1446 :                        
 3412/    1446 :                        LAB_1CF2
 3413/    1446 : 5200                   	ADDQ.b	#1,d0					; make result 0, 1 or 2
 3414/    1448 : 1200                   	MOVE.b	d0,d1					; copy to d1
 3415/    144A : 7001                   	MOVEQ		#1,d0					; set d0 longword
 3416/    144C : E338                   	ROL.b		d1,d0					; make 1, 2 or 4 (result = flag bit)
 3417/    144E : C02B 05E1              	AND.b		Cflag(a3),d0			; AND with comparison evaluation flag
 3418/    1452 : 6700 0CDE              	BEQ		LAB_27DB				; exit if not a wanted result (i.e. false)
 3419/    1456 :                        
 3420/    1456 : 70FF                   	MOVEQ		#-1,d0				; else set -1 (true)
 3421/    1458 : 6000 0CD8              	BRA		LAB_27DB				; save d0 as integer & return
 3422/    145C :                        
 3423/    145C :                        
 3424/    145C :                        LAB_1CFE
 3425/    145C : 6100 FE54              	BSR		LAB_1C01				; scan for ",", else do syntax error/warm start
 3426/    1460 :                        
 3427/    1460 :                        
 3428/    1460 :                        ;************************************************************************************
 3429/    1460 :                        ;
 3430/    1460 :                        ; perform DIM
 3431/    1460 :                        
 3432/    1460 :                        LAB_DIM
 3433/    1460 : 72FF                   	MOVEQ		#-1,d1				; set "DIM" flag
 3434/    1462 : 6170                   	BSR.s		LAB_1D10				; search for or dimension a variable
 3435/    1464 : 6100 FE58              	BSR		LAB_GBYT				; scan memory
 3436/    1468 : 66F2                   	BNE.s		LAB_1CFE				; loop and scan for "," if not null
 3437/    146A :                        
 3438/    146A : 4E75                   	RTS
 3439/    146C :                        
 3440/    146C :                        
 3441/    146C :                        ;************************************************************************************
 3442/    146C :                        ;
 3443/    146C :                        ; perform << (left shift)
 3444/    146C :                        
 3445/    146C :                        LAB_LSHIFT
 3446/    146C : 612E                   	BSR.s		GetPair				; get an integer and byte pair
 3447/    146E :                        								; byte is in d2, integer is in d0 and Itemp
 3448/    146E : 6708                   	BEQ.s		NoShift				; branch if byte zero
 3449/    1470 :                        
 3450/    1470 : B43C 0020              	CMP.b		#$20,d2				; compare bit count with 32d
 3451/    1474 : 6420                   	BCC.s		TooBig				; branch if >=
 3452/    1476 :                        
 3453/    1476 : E5A0                   	ASL.l		d2,d0					; shift longword
 3454/    1478 :                        NoShift
 3455/    1478 : 6000 0344              	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & RET
 3456/    147C :                        
 3457/    147C :                        
 3458/    147C :                        ;************************************************************************************
 3459/    147C :                        ;
 3460/    147C :                        ; perform >> (right shift)
 3461/    147C :                        
 3462/    147C :                        LAB_RSHIFT
 3463/    147C : 611E                   	BSR.s		GetPair				; get an integer and byte pair
 3464/    147E :                        								; byte is in d2, integer is in d0 and Itemp
 3465/    147E : 67F8                   	BEQ.s		NoShift				; branch if byte zero
 3466/    1480 :                        
 3467/    1480 : B43C 0020              	CMP.b		#$20,d2				; compare bit count with 32d
 3468/    1484 : 650A                   	BCS.s		Not2Big				; branch if >= (return shift)
 3469/    1486 :                        
 3470/    1486 : 4A80                   	TST.l		d0					; test sign bit
 3471/    1488 : 6A0C                   	BPL.s		TooBig				; branch if +ve
 3472/    148A :                        
 3473/    148A : 70FF                   	MOVEQ		#-1,d0				; set longword
 3474/    148C : 6000 0330              	BRA		LAB_AYFC				; convert d0 to longword in FAC1 & RET
 3475/    1490 :                        
 3476/    1490 :                        Not2Big
 3477/    1490 : E4A0                   	ASR.l		d2,d0					; shift longword
 3478/    1492 : 6000 032A              	BRA		LAB_AYFC				; convert d0 to longword in FAC1 & RET
 3479/    1496 :                        
 3480/    1496 :                        TooBig
 3481/    1496 : 7000                   	MOVEQ		#0,d0					; clear longword
 3482/    1498 : 6000 0324              	BRA		LAB_AYFC				; convert d0 to longword in FAC1 & RET
 3483/    149C :                        
 3484/    149C :                        
 3485/    149C :                        ;************************************************************************************
 3486/    149C :                        ;
 3487/    149C :                        ; get an integer and byte pair
 3488/    149C :                        ; byte is in d2, integer is in d0 and Itemp
 3489/    149C :                        
 3490/    149C :                        GetPair
 3491/    149C : 6100 078E              	BSR		LAB_EVBY				; evaluate byte expression, result in d0 and
 3492/    14A0 :                        								; Itemp
 3493/    14A0 : 1400                   	MOVE.b	d0,d2					; save it
 3494/    14A2 : 6100 0C3A              	BSR		LAB_279B				; copy FAC2 to FAC1, get first value in
 3495/    14A6 :                        								; expression
 3496/    14A6 : 6100 0162              	BSR		LAB_EVIR				; evaluate integer expression (no sign check)
 3497/    14AA :                        								; result in d0 and Itemp
 3498/    14AA : 4A02                   	TST.b		d2					; test byte value
 3499/    14AC : 4E75                   	RTS
 3500/    14AE :                        
 3501/    14AE :                        
 3502/    14AE :                        ;************************************************************************************
 3503/    14AE :                        ;
 3504/    14AE :                        ; check alpha, return C=0 if<"A" or >"Z" or <"a" to "z">
 3505/    14AE :                        
 3506/    14AE :                        LAB_CASC
 3507/    14AE : B03C 0061              	CMP.b		#$61,d0				; compare with "a"
 3508/    14B2 : 6410                   	BCC.s		LAB_1D83				; if >="a" go check =<"z"
 3509/    14B4 :                        
 3510/    14B4 :                        
 3511/    14B4 :                        ;************************************************************************************
 3512/    14B4 :                        ;
 3513/    14B4 :                        ; check alpha upper case, return C=0 if<"A" or >"Z"
 3514/    14B4 :                        
 3515/    14B4 :                        LAB_CAUC
 3516/    14B4 : B03C 0041              	CMP.b		#$41,d0				; compare with "A"
 3517/    14B8 : 6404                   	BCC.s		LAB_1D8A				; if >="A" go check =<"Z"
 3518/    14BA :                        
 3519/    14BA : 8040                   	OR		d0,d0					; make C=0
 3520/    14BC : 4E75                   	RTS
 3521/    14BE :                        
 3522/    14BE :                        LAB_1D8A
 3523/    14BE : B03C 005B              	CMP.b		#$5B,d0				; compare with "Z"+1
 3524/    14C2 :                        								; carry set if byte<="Z"
 3525/    14C2 : 4E75                   	RTS
 3526/    14C4 :                        
 3527/    14C4 :                        LAB_1D83
 3528/    14C4 : B03C 007B              	CMP.b		#$7B,d0				; compare with "z"+1
 3529/    14C8 :                        								; carry set if byte<="z"
 3530/    14C8 : 4E75                   	RTS
 3531/    14CA :                        
 3532/    14CA :                        
 3533/    14CA :                        ;************************************************************************************
 3534/    14CA :                        ;
 3535/    14CA :                        ; search for or create variable. this is used to automatically create a variable if
 3536/    14CA :                        ; it is not found. any routines that need to create the variable call LAB_GVAR via
 3537/    14CA :                        ; this point and error generation is supressed and the variable will be created
 3538/    14CA :                        ;
 3539/    14CA :                        ; return pointer to variable in Cvaral and a0
 3540/    14CA :                        ; set data type to variable type
 3541/    14CA :                        
 3542/    14CA :                        LAB_SVAR
 3543/    14CA : 6102                   	BSR.s		LAB_GVAR				; search for variable
 3544/    14CC :                        LAB_FVAR
 3545/    14CC : 4E75                   	RTS
 3546/    14CE :                        
 3547/    14CE :                        
 3548/    14CE :                        ;************************************************************************************
 3549/    14CE :                        ;
 3550/    14CE :                        ; search for variable. if this routine is called from anywhere but the above call and
 3551/    14CE :                        ; the variable searched for does not exist then an error will be returned
 3552/    14CE :                        ;
 3553/    14CE :                        ; DIM flag is in d1.b
 3554/    14CE :                        ; return pointer to variable in Cvaral and a0
 3555/    14CE :                        ; set data type to variable type
 3556/    14CE :                        
 3557/    14CE :                        LAB_GVAR
 3558/    14CE : 7200                   	MOVEQ		#$00,d1				; set DIM flag = $00
 3559/    14D0 : 6100 FDEC              	BSR		LAB_GBYT				; scan memory (1st character)
 3560/    14D4 :                        LAB_1D10
 3561/    14D4 : 1741 05B4              	MOVE.b	d1,Defdim(a3)			; save DIM flag
 3562/    14D8 :                        
 3563/    14D8 :                        ; search for FN name entry point
 3564/    14D8 :                        
 3565/    14D8 :                        LAB_1D12
 3566/    14D8 : 61D4                   	BSR.s		LAB_CASC				; check byte, return C=0 if<"A" or >"Z"
 3567/    14DA : 6400 F19A              	BCC		LAB_SNER				; if not, syntax error then warm start
 3568/    14DE :                        
 3569/    14DE :                        								; it is a variable name so ...
 3570/    14DE : 7200                   	MOVEQ		#$0,d1				; set index for name byte
 3571/    14E0 : 41EB 046A              	LEA		Varname(a3),a0			; pointer to variable name
 3572/    14E4 : 2081                   	MOVE.l	d1,(a0)				; clear the variable name
 3573/    14E6 : 1741 05B5              	MOVE.b	d1,Dtypef(a3)			; clear the data type, $80=string, $40=integer,
 3574/    14EA :                        								; $00=float
 3575/    14EA :                        
 3576/    14EA :                        LAB_1D2D
 3577/    14EA : B27C 0004              	CMP.w		#$04,d1				; done all significant characters?
 3578/    14EE : 6406                   	BCC.s		LAB_1D2E				; if so go ignore any more
 3579/    14F0 :                        
 3580/    14F0 : 1180 1000              	MOVE.b	d0,(a0,d1.w)			; save the character
 3581/    14F4 : 5241                   	ADDQ.w	#1,d1					; increment index
 3582/    14F6 :                        LAB_1D2E
 3583/    14F6 : 6100 FDC4              	BSR		LAB_IGBY				; increment & scan memory (next character)
 3584/    14FA : 65EE                   	BCS.s		LAB_1D2D				; branch if character = "0"-"9" (ok)
 3585/    14FC :                        
 3586/    14FC :                        								; character wasn't "0" to "9" so ...
 3587/    14FC : 61B0                   	BSR.s		LAB_CASC				; check byte, return C=0 if<"A" or >"Z"
 3588/    14FE : 65EA                   	BCS.s		LAB_1D2D				; branch if = "A"-"Z" (ok)
 3589/    1500 :                        
 3590/    1500 :                        								; check if string variable
 3591/    1500 : B03C 0024              	CMP.b		#'$',d0				; compare with "$"
 3592/    1504 : 660C                   	BNE.s		LAB_1D44				; branch if not string
 3593/    1506 :                        
 3594/    1506 :                        								; type is string
 3595/    1506 : 002B 0080 046B         	OR.b		#$80,Varname+1(a3)		; set top bit of 2nd character, indicate string
 3596/    150C : 6100 FDAE              	BSR		LAB_IGBY				; increment & scan memory
 3597/    1510 : 6010                   	BRA.s		LAB_1D45				; skip integer check
 3598/    1512 :                        
 3599/    1512 :                        								; check if integer variable
 3600/    1512 :                        LAB_1D44
 3601/    1512 : B03C 0026              	CMP.b		#'&',d0				; compare with "&"
 3602/    1516 : 660A                   	BNE.s		LAB_1D45				; branch if not integer
 3603/    1518 :                        
 3604/    1518 :                        								; type is integer
 3605/    1518 : 002B 0080 046C         	OR.b		#$80,Varname+2(a3)		; set top bit of 3rd character, indicate integer
 3606/    151E : 6100 FD9C              	BSR		LAB_IGBY				; increment & scan memory
 3607/    1522 :                        
 3608/    1522 :                        ; after we have determined the variable type we need to determine
 3609/    1522 :                        ; if it's an array of type
 3610/    1522 :                        
 3611/    1522 :                        								; gets here with character after var name in d0
 3612/    1522 :                        LAB_1D45
 3613/    1522 : 4A2B 05DF              	TST.b		Sufnxf(a3)				; test function name flag
 3614/    1526 : 670E                   	BEQ.s		LAB_1D48				; if not FN or FN variable continue
 3615/    1528 :                        
 3616/    1528 : 6A14                   	BPL.s		LAB_1D49				; if FN variable go find or create it
 3617/    152A :                        
 3618/    152A :                        								; else was FN name
 3619/    152A : 202B 046A              	MOVE.l	Varname(a3),d0			; get whole function name
 3620/    152E : 7208                   	MOVEQ		#8,d1					; set step to next function size -4
 3621/    1530 : 41EB 0432              	LEA		Sfncl(a3),a0			; get pointer to start of functions
 3622/    1534 : 601C                   	BRA.s		LAB_1D4B				; go find function
 3623/    1536 :                        
 3624/    1536 :                        LAB_1D48
 3625/    1536 : 903C 0028              	SUB.b		#'(',d0				; subtract "("
 3626/    153A : 6700 00F4              	BEQ		LAB_1E17				; if "(" go find, or make, array
 3627/    153E :                        
 3628/    153E :                        ; either find or create var
 3629/    153E :                        ; var name (1st four characters only!) is in Varname
 3630/    153E :                        
 3631/    153E :                        								; variable name wasn't var( .. so look for
 3632/    153E :                        								; plain variable
 3633/    153E :                        LAB_1D49
 3634/    153E : 202B 046A              	MOVE.l	Varname(a3),d0			; get whole variable name
 3635/    1542 :                        LAB_1D4A
 3636/    1542 : 7204                   	MOVEQ		#4,d1					; set step to next variable size -4
 3637/    1544 : 41EB 0436              	LEA		Svarl(a3),a0			; get pointer to start of variables
 3638/    1548 :                        
 3639/    1548 : 0800 0017              	BTST.l	#23,d0				; test if string name
 3640/    154C : 6704                   	BEQ.s		LAB_1D4B				; branch if not
 3641/    154E :                        
 3642/    154E : 5441                   	ADDQ.w	#2,d1					; 6 bytes per string entry
 3643/    1550 : 5848                   	ADDQ.w	#(Sstrl-Svarl),a0			; move to string area
 3644/    1552 :                        
 3645/    1552 :                        LAB_1D4B
 3646/    1552 : 2268 0004              	MOVEA.l	4(a0),a1				; get end address
 3647/    1556 : 2050                   	MOVEA.l	(a0),a0				; get start address
 3648/    1558 : 6006                   	BRA.s		LAB_1D5E				; enter loop at exit check
 3649/    155A :                        
 3650/    155A :                        LAB_1D5D
 3651/    155A : B098                   	CMP.l		(a0)+,d0				; compare this variable with name
 3652/    155C : 6776                   	BEQ.s		LAB_1DD7				; branch if match (found var)
 3653/    155E :                        
 3654/    155E : D1C1                   	ADDA.l	d1,a0					; add offset to next variable
 3655/    1560 :                        LAB_1D5E
 3656/    1560 : B1C9                   	CMPA.l	a1,a0					; compare address with variable space end
 3657/    1562 : 66F6                   	BNE.s		LAB_1D5D				; if not end go check next
 3658/    1564 :                        
 3659/    1564 : 4A2B 05DF              	TST.b		Sufnxf(a3)				; is it a function or function variable
 3660/    1568 : 660A                   	BNE.s		LAB_1D94				; if was go do DEF or function variable
 3661/    156A :                        
 3662/    156A :                        								; reached end of variable mem without match
 3663/    156A :                        								; ... so create new variable, possibly
 3664/    156A :                        
 3665/    156A : 45FA FF60              	LEA		LAB_FVAR(pc),a2			; get the address of the create if doesn't
 3666/    156E :                        								; exist call to LAB_GVAR
 3667/    156E : B5D7                   	CMPA.l	(sp),a2				; compare the return address with expected
 3668/    1570 : 6600 F0C0              	BNE		LAB_UVER				; if not create go do error or return null
 3669/    1574 :                        
 3670/    1574 :                        ; this will only branch if the call to LAB_GVAR wasn't from LAB_SVAR
 3671/    1574 :                        
 3672/    1574 :                        LAB_1D94
 3673/    1574 : 082B 0000 05DF         	BTST.b	#0,Sufnxf(a3)			; test function search flag
 3674/    157A : 6600 F0BE              	BNE		LAB_UFER				; if not doing DEF then go do undefined
 3675/    157E :                        								; function error
 3676/    157E :                        
 3677/    157E :                        								; else create new variable/function
 3678/    157E :                        LAB_1D98
 3679/    157E : 246B 0442              	MOVEA.l	Earryl(a3),a2			; get end of block to move
 3680/    1582 : 240A                   	MOVE.l	a2,d2					; copy end of block to move
 3681/    1584 : 9489                   	SUB.l		a1,d2					; calculate block to move size
 3682/    1586 :                        
 3683/    1586 : 204A                   	MOVEA.l	a2,a0					; copy end of block to move
 3684/    1588 : 5881                   	ADDQ.l	#4,d1					; space for one variable/function + name
 3685/    158A : D5C1                   	ADDA.l	d1,a2					; add space for one variable/function
 3686/    158C : 274A 0442              	MOVE.l	a2,Earryl(a3)			; set new array mem end
 3687/    1590 : E28A                   	LSR.l		#1,d2					; /2 for word copy
 3688/    1592 : 6712                   	BEQ.s		LAB_1DAF				; skip move if zero length block
 3689/    1594 :                        
 3690/    1594 : 5382                   	SUBQ.l	#1,d2					; -1 for DFB loop
 3691/    1596 : 4842                   	SWAP		d2					; swap high word to low word
 3692/    1598 :                        LAB_1DAC
 3693/    1598 : 4842                   	SWAP		d2					; swap high word to low word
 3694/    159A :                        LAB_1DAE
 3695/    159A : 3520                   	MOVE.w	-(a0),-(a2)				; copy word
 3696/    159C : 51CA FFFC              	DBF		d2,LAB_1DAE				; loop until done
 3697/    15A0 :                        
 3698/    15A0 : 4842                   	SWAP		d2					; swap high word to low word
 3699/    15A2 : 51CA FFF4              	DBF		d2,LAB_1DAC				; decrement high count and loop until done
 3700/    15A6 :                        
 3701/    15A6 :                        ; get here after creating either a function, variable or string
 3702/    15A6 :                        ; if function set variables start, string start, array start
 3703/    15A6 :                        ; if variable set string start, array start
 3704/    15A6 :                        ; if string set array start
 3705/    15A6 :                        
 3706/    15A6 :                        LAB_1DAF
 3707/    15A6 : 4A2B 05DF              	TST.b		Sufnxf(a3)				; was it function
 3708/    15AA : 6B08                   	BMI.s		LAB_1DB0				; branch if was FN
 3709/    15AC :                        
 3710/    15AC : 0800 0017              	BTST.l	#23,d0				; was it string
 3711/    15B0 : 660A                   	BNE.s		LAB_1DB2				; branch if string
 3712/    15B2 :                        
 3713/    15B2 : 6004                   	BRA.s		LAB_1DB1				; branch if was plain variable
 3714/    15B4 :                        
 3715/    15B4 :                        LAB_1DB0
 3716/    15B4 : D3AB 0436              	ADD.l		d1,Svarl(a3)			; set new variable memory start
 3717/    15B8 :                        LAB_1DB1
 3718/    15B8 : D3AB 043A              	ADD.l		d1,Sstrl(a3)			; set new start of strings
 3719/    15BC :                        LAB_1DB2
 3720/    15BC : D3AB 043E              	ADD.l		d1,Sarryl(a3)			; set new array memory start
 3721/    15C0 : 20C0                   	MOVE.l	d0,(a0)+				; save variable/function name
 3722/    15C2 : 20BC 0000 0000         	MOVE.l	#$00,(a0)				; initialise variable
 3723/    15C8 : 0800 0017              	BTST.l	#23,d0				; was it string
 3724/    15CC : 6706                   	BEQ.s		LAB_1DD7				; branch if not string
 3725/    15CE :                        
 3726/    15CE : 317C 0000 0004         	MOVE.w	#$00,4(a0)				; else initialise string length
 3727/    15D4 :                        
 3728/    15D4 :                        								; found a match for var ((Vrschl) = ptr)
 3729/    15D4 :                        LAB_1DD7
 3730/    15D4 : 2200                   	MOVE.l	d0,d1					; ........ $....... &....... ........
 3731/    15D6 : D281                   	ADD.l		d1,d1					; .......$ .......& ........ .......0
 3732/    15D8 : 4841                   	SWAP		d1					; ........ .......0 .......$ .......&
 3733/    15DA : E219                   	ROR.b		#1,d1					; ........ .......0 .......$ &.......
 3734/    15DC : E249                   	LSR.w		#1,d1					; ........ .......0 0....... $&......
 3735/    15DE : C23C 00C0              	AND.b		#$C0,d1				; mask the type bits
 3736/    15E2 : 1741 05B5              	MOVE.b	d1,Dtypef(a3)			; save the data type
 3737/    15E6 :                        
 3738/    15E6 : 177C 0000 05DF         	MOVE.b	#$00,Sufnxf(a3)			; clear FN flag byte
 3739/    15EC : 4E75                   	RTS
 3740/    15EE :                        
 3741/    15EE :                        
 3742/    15EE :                        ;************************************************************************************
 3743/    15EE :                        ;
 3744/    15EE :                        ; set-up array pointer, d0, to first element in array
 3745/    15EE :                        ; set d0 to (a0)+2*(Dimcnt)+$0A
 3746/    15EE :                        
 3747/    15EE :                        LAB_1DE6
 3748/    15EE : 7005                   	MOVEQ		#5,d0					; set d0 to 5 (*2 = 10, later)
 3749/    15F0 : D02B 05DB              	ADD.b		Dimcnt(a3),d0			; add # of dimensions (1, 2 or 3)
 3750/    15F4 : D080                   	ADD.l		d0,d0					; *2 (bytes per dimension size)
 3751/    15F6 : D088                   	ADD.l		a0,d0					; add array start pointer
 3752/    15F8 : 4E75                   	RTS
 3753/    15FA :                        
 3754/    15FA :                        
 3755/    15FA :                        ;************************************************************************************
 3756/    15FA :                        ;
 3757/    15FA :                        ; evaluate unsigned integer expression
 3758/    15FA :                        
 3759/    15FA :                        LAB_EVIN
 3760/    15FA : 6100 FCC0              	BSR		LAB_IGBY				; increment & scan memory
 3761/    15FE : 6100 FB44              	BSR		LAB_EVNM				; evaluate expression & check is numeric,
 3762/    1602 :                        								; else do type mismatch
 3763/    1602 :                        
 3764/    1602 :                        
 3765/    1602 :                        ;************************************************************************************
 3766/    1602 :                        ;
 3767/    1602 :                        ; evaluate positive integer expression, result in d0 and Itemp
 3768/    1602 :                        
 3769/    1602 :                        LAB_EVPI
 3770/    1602 : 4A2B 0595              	TST.b		FAC1_s(a3)				; test FAC1 sign (b7)
 3771/    1606 : 6B00 F062              	BMI		LAB_FCER				; do function call error if -ve
 3772/    160A :                        
 3773/    160A :                        
 3774/    160A :                        ;************************************************************************************
 3775/    160A :                        ;
 3776/    160A :                        ; evaluate integer expression, no sign check
 3777/    160A :                        ; result in d0 and Itemp, exit with flags set correctly
 3778/    160A :                        
 3779/    160A :                        LAB_EVIR
 3780/    160A : 0C2B 00A0 0594         	CMPI.b	#$A0,FAC1_e(a3)			; compare exponent with exponent = 2^32 (n>2^31)
 3781/    1610 : 6500 0B64              	BCS		LAB_2831				; convert FAC1 floating to fixed
 3782/    1614 :                        								; result in d0 and Itemp
 3783/    1614 : 6600 F054              	BNE		LAB_FCER				; if > do function call error, then warm start
 3784/    1618 :                        
 3785/    1618 : 4A2B 0595              	TST.b		FAC1_s(a3)				; test sign of FAC1
 3786/    161C : 6A00 0B58              	BPL		LAB_2831				; if +ve then ok
 3787/    1620 :                        
 3788/    1620 : 202B 0590              	MOVE.l	FAC1_m(a3),d0			; get mantissa
 3789/    1624 : 4480                   	NEG.l		d0					; do -d0
 3790/    1626 : 6800 F042              	BVC		LAB_FCER				; if not $80000000 do FC error, then warm start
 3791/    162A :                        
 3792/    162A : 2740 042A              	MOVE.l	d0,Itemp(a3)			; else just set it
 3793/    162E : 4E75                   	RTS
 3794/    1630 :                        
 3795/    1630 :                        
 3796/    1630 :                        ;************************************************************************************
 3797/    1630 :                        ;
 3798/    1630 :                        ; find or make array
 3799/    1630 :                        
 3800/    1630 :                        LAB_1E17
 3801/    1630 : 3F2B 05B4              	MOVE.w	Defdim(a3),-(sp)			; get DIM flag and data type flag (word in mem)
 3802/    1634 : 7200                   	MOVEQ		#0,d1					; clear dimensions count
 3803/    1636 :                        
 3804/    1636 :                        ; now get the array dimension(s) and stack it (them) before the data type and DIM flag
 3805/    1636 :                        
 3806/    1636 :                        LAB_1E1F
 3807/    1636 : 3F01                   	MOVE.w	d1,-(sp)				; save dimensions count
 3808/    1638 : 2F2B 046A              	MOVE.l	Varname(a3),-(sp)			; save variable name
 3809/    163C : 61BC                   	BSR.s		LAB_EVIN				; evaluate integer expression
 3810/    163E :                        
 3811/    163E : 4840                   	SWAP		d0					; swap high word to low word
 3812/    1640 : 4A40                   	TST.w		d0					; test swapped high word
 3813/    1642 : 6600 F016              	BNE		LAB_ABER				; if too big do array bounds error
 3814/    1646 :                        
 3815/    1646 : 275F 046A              	MOVE.l	(sp)+,Varname(a3)			; restore variable name
 3816/    164A : 321F                   	MOVE.w	(sp)+,d1				; restore dimensions count
 3817/    164C : 301F                   	MOVE.w	(sp)+,d0				; restore DIM and data type flags
 3818/    164E : 3F2B 042C              	MOVE.w	Itemp+2(a3),-(sp)			; stack this dimension size
 3819/    1652 : 3F00                   	MOVE.w	d0,-(sp)				; save DIM and data type flags
 3820/    1654 : 5241                   	ADDQ.w	#1,d1					; increment dimensions count
 3821/    1656 : 6100 FC66              	BSR		LAB_GBYT				; scan memory
 3822/    165A : B03C 002C              	CMP.b		#$2C,d0				; compare with ","
 3823/    165E : 67D6                   	BEQ.s		LAB_1E1F				; if found go do next dimension
 3824/    1660 :                        
 3825/    1660 : 1741 05DB              	MOVE.b	d1,Dimcnt(a3)			; store dimensions count
 3826/    1664 : 6100 FC44              	BSR		LAB_1BFB				; scan for ")", else do syntax error/warm start
 3827/    1668 : 375F 05B4              	MOVE.w	(sp)+,Defdim(a3)			; restore DIM and data type flags (word in mem)
 3828/    166C : 206B 043E              	MOVEA.l	Sarryl(a3),a0			; get array mem start
 3829/    1670 :                        
 3830/    1670 :                        ; now check to see if we are at the end of array memory (we would be if there were
 3831/    1670 :                        ; no arrays).
 3832/    1670 :                        
 3833/    1670 :                        LAB_1E5C
 3834/    1670 : 2748 05AC              	MOVE.l	a0,Astrtl(a3)			; save as array start pointer
 3835/    1674 : B1EB 0442              	CMPA.l	Earryl(a3),a0			; compare with array mem end
 3836/    1678 : 672E                   	BEQ.s		LAB_1EA1				; go build array if not found
 3837/    167A :                        
 3838/    167A :                        								; search for array
 3839/    167A : 2010                   	MOVE.l	(a0),d0				; get this array name
 3840/    167C : B0AB 046A              	CMP.l		Varname(a3),d0			; compare with array name
 3841/    1680 : 670A                   	BEQ.s		LAB_1E8D				; array found so branch
 3842/    1682 :                        
 3843/    1682 :                        								; no match
 3844/    1682 : 2068 0004              	MOVEA.l	4(a0),a0				; get this array size
 3845/    1686 : D1EB 05AC              	ADDA.l	Astrtl(a3),a0			; add to array start pointer
 3846/    168A : 60E4                   	BRA.s		LAB_1E5C				; go check next array
 3847/    168C :                        
 3848/    168C :                        								; found array, are we trying to dimension it?
 3849/    168C :                        LAB_1E8D
 3850/    168C : 4A2B 05B4              	TST.b		Defdim(a3)				; are we trying to dimension it?
 3851/    1690 : 6600 EFC4              	BNE		LAB_DDER				; if so do double dimension error/warm start
 3852/    1694 :                        
 3853/    1694 :                        ; found the array and we're not dimensioning it so we must find an element in it
 3854/    1694 :                        
 3855/    1694 : 6100 FF58              	BSR		LAB_1DE6				; set data pointer, d0, to the first element
 3856/    1698 :                        								; in the array
 3857/    1698 : 5048                   	ADDQ.w	#8,a0					; index to dimension count
 3858/    169A : 3018                   	MOVE.w	(a0)+,d0				; get no of dimensions
 3859/    169C : B02B 05DB              	CMP.b		Dimcnt(a3),d0			; compare with dimensions count
 3860/    16A0 : 6700 0094              	BEQ		LAB_1F28				; found array so go get element
 3861/    16A4 :                        
 3862/    16A4 : 6000 EF84              	BRA		LAB_WDER				; else wrong so do "Wrong dimensions" error
 3863/    16A8 :                        
 3864/    16A8 :                        								; array not found, so possibly build it
 3865/    16A8 :                        LAB_1EA1
 3866/    16A8 : 4A2B 05B4              	TST.b		Defdim(a3)				; test the default DIM flag
 3867/    16AC : 6700 EF80              	BEQ		LAB_UDER				; if default flag is clear then we are not
 3868/    16B0 :                        								; explicitly dimensioning an array so go
 3869/    16B0 :                        								; do an "Undimensioned array" error
 3870/    16B0 :                        
 3871/    16B0 : 6100 FF3C              	BSR		LAB_1DE6				; set data pointer, d0, to the first element
 3872/    16B4 :                        								; in the array
 3873/    16B4 : 202B 046A              	MOVE.l	Varname(a3),d0			; get array name
 3874/    16B8 : 20C0                   	MOVE.l	d0,(a0)+				; save array name
 3875/    16BA : 7204                   	MOVEQ		#4,d1					; set 4 bytes per element
 3876/    16BC : 0800 0017              	BTST.l	#23,d0				; test if string array
 3877/    16C0 : 6702                   	BEQ.s		LAB_1EDF				; branch if not string
 3878/    16C2 :                        
 3879/    16C2 : 7206                   	MOVEQ		#6,d1					; else 6 bytes per element
 3880/    16C4 :                        LAB_1EDF
 3881/    16C4 : 2741 05A8              	MOVE.l	d1,Asptl(a3)			; set array data size (bytes per element)
 3882/    16C8 : 122B 05DB              	MOVE.b	Dimcnt(a3),d1			; get dimensions count
 3883/    16CC : 5848                   	ADDQ.w	#4,a0					; skip the array size now (don't know it yet!)
 3884/    16CE : 30C1                   	MOVE.w	d1,(a0)+				; set array's dimensions count
 3885/    16D0 :                        
 3886/    16D0 :                        ; now calculate the array data space size
 3887/    16D0 :                        
 3888/    16D0 :                        LAB_1EC0
 3889/    16D0 :                        
 3890/    16D0 :                        ; If you want arrays to dimension themselves by default then comment out the test
 3891/    16D0 :                        ; above and uncomment the next three code lines and the label LAB_1ED0
 3892/    16D0 :                        
 3893/    16D0 :                        ;	MOVE.w	#$0A,d1				; set default dimension value, allow 0 to 9
 3894/    16D0 :                        ;	TST.b		Defdim(a3)				; test default DIM flag
 3895/    16D0 :                        ;	BNE.s		LAB_1ED0				; branch if b6 of Defdim is clear
 3896/    16D0 :                        
 3897/    16D0 : 321F                   	MOVE.w	(sp)+,d1				; get dimension size
 3898/    16D2 :                        ;LAB_1ED0
 3899/    16D2 : 30C1                   	MOVE.w	d1,(a0)+				; save to array header
 3900/    16D4 : 6100 00AE              	BSR		LAB_1F7C				; do this dimension size+1	; array size
 3901/    16D8 :                        								; (d1+1)*(Asptl), result in d0
 3902/    16D8 : 2740 05A8              	MOVE.l	d0,Asptl(a3)			; save array data size
 3903/    16DC : 532B 05DB              	SUBQ.b	#1,Dimcnt(a3)			; decrement dimensions count
 3904/    16E0 : 66EE                   	BNE.s		LAB_1EC0				; loop while not = 0
 3905/    16E2 :                        
 3906/    16E2 : D1EB 05A8              	ADDA.l	Asptl(a3),a0			; add size to first element address
 3907/    16E6 : 6500 EF7A              	BCS		LAB_OMER				; if overflow go do "Out of memory" error
 3908/    16EA :                        
 3909/    16EA : B1EB 0446              	CMPA.l	Sstorl(a3),a0			; compare with bottom of string memory
 3910/    16EE : 650C                   	BCS.s		LAB_1ED6				; branch if less (is ok)
 3911/    16F0 :                        
 3912/    16F0 : 6100 028E              	BSR		LAB_GARB				; do garbage collection routine
 3913/    16F4 : B1EB 0446              	CMPA.l	Sstorl(a3),a0			; compare with bottom of string memory
 3914/    16F8 : 6400 EF68              	BCC		LAB_OMER				; if Sstorl <= a0 do "Out of memory"
 3915/    16FC :                        								; error then warm start
 3916/    16FC :                        
 3917/    16FC :                        LAB_1ED6							; ok exit, carry set
 3918/    16FC : 2748 0442              	MOVE.l	a0,Earryl(a3)			; save array mem end
 3919/    1700 : 7000                   	MOVEQ		#0,d0					; zero d0
 3920/    1702 : 222B 05A8              	MOVE.l	Asptl(a3),d1			; get size in bytes
 3921/    1706 : E289                   	LSR.l		#1,d1					; /2 for word fill (may be odd # words)
 3922/    1708 : 5341                   	SUBQ.w	#1,d1					; adjust for DBF loop
 3923/    170A :                        LAB_1ED8
 3924/    170A : 3100                   	MOVE.w	d0,-(a0)				; decrement pointer and clear word
 3925/    170C : 51C9 FFFC              	DBF		d1,LAB_1ED8				; decrement & loop until low word done
 3926/    1710 :                        
 3927/    1710 : 4841                   	SWAP		d1					; swap words
 3928/    1712 : 4A41                   	TST.w		d1					; test high word
 3929/    1714 : 6706                   	BEQ.s		LAB_1F07				; exit if done
 3930/    1716 :                        
 3931/    1716 : 5341                   	SUBQ.w	#1,d1					; decrement low (high) word
 3932/    1718 : 4841                   	SWAP		d1					; swap back
 3933/    171A : 60EE                   	BRA.s		LAB_1ED8				; go do a whole block
 3934/    171C :                        
 3935/    171C :                        ; now we need to calculate the array size by doing Earryl - Astrtl
 3936/    171C :                        
 3937/    171C :                        LAB_1F07
 3938/    171C : 206B 05AC              	MOVEA.l	Astrtl(a3),a0			; get for calculation and as pointer
 3939/    1720 : 202B 0442              	MOVE.l	Earryl(a3),d0			; get array memory end
 3940/    1724 : 9088                   	SUB.l		a0,d0					; calculate array size
 3941/    1726 : 2140 0004              	MOVE.l	d0,4(a0)				; save size to array
 3942/    172A : 4A2B 05B4              	TST.b		Defdim(a3)				; test default DIM flag
 3943/    172E : 6652                   	BNE.s		RTS_011				; exit (RET) if this was a DIM command
 3944/    1730 :                        
 3945/    1730 :                        								; else, find element
 3946/    1730 : 5048                   	ADDQ.w	#8,a0					; index to dimension count
 3947/    1732 : 3758 05DB              	MOVE.w	(a0)+,Dimcnt(a3)			; get array's dimension count
 3948/    1736 :                        
 3949/    1736 :                        ; we have found, or built, the array. now we need to find the element
 3950/    1736 :                        
 3951/    1736 :                        LAB_1F28
 3952/    1736 : 7000                   	MOVEQ		#0,d0					; clear first result
 3953/    1738 : 2740 05A8              	MOVE.l	d0,Asptl(a3)			; clear array data pointer
 3954/    173C :                        
 3955/    173C :                        ; compare nth dimension bound (a0) with nth index (sp)+
 3956/    173C :                        ; if greater do array bounds error
 3957/    173C :                        
 3958/    173C :                        LAB_1F2C
 3959/    173C : 3218                   	MOVE.w	(a0)+,d1				; get nth dimension bound
 3960/    173E : B257                   	CMP.w		(sp),d1				; compare nth index with nth dimension bound
 3961/    1740 : 6500 EF18              	BCS		LAB_ABER				; if d1 less or = do array bounds error
 3962/    1744 :                        
 3963/    1744 :                        ; now do pointer = pointer	; nth dimension + nth index
 3964/    1744 :                        
 3965/    1744 : 4A80                   	TST.l		d0					; test pointer
 3966/    1746 : 6702                   	BEQ.s		LAB_1F5A				; skip multiply if last result = null
 3967/    1748 :                        
 3968/    1748 : 613A                   	BSR.s		LAB_1F7C				; do this dimension size+1	; array size
 3969/    174A :                        LAB_1F5A
 3970/    174A : 7200                   	MOVEQ		#0,d1					; clear longword
 3971/    174C : 321F                   	MOVE.w	(sp)+,d1				; get nth dimension index
 3972/    174E : D081                   	ADD.l		d1,d0					; add index to size
 3973/    1750 : 2740 05A8              	MOVE.l	d0,Asptl(a3)			; save array data pointer
 3974/    1754 :                        
 3975/    1754 : 532B 05DB              	SUBQ.b	#1,Dimcnt(a3)			; decrement dimensions count
 3976/    1758 : 66E2                   	BNE.s		LAB_1F2C				; loop if dimensions still to do
 3977/    175A :                        
 3978/    175A : 177C 0000 05B5         	MOVE.b	#0,Dtypef(a3)			; set data type to float
 3979/    1760 : 7203                   	MOVEQ		#3,d1					; set for numeric array
 3980/    1762 : 4A2B 046B              	TST.b		Varname+1(a3)			; test if string array
 3981/    1766 : 6A0A                   	BPL.s		LAB_1F6A				; branch if not string
 3982/    1768 :                        
 3983/    1768 : 7205                   	MOVEQ		#5,d1					; else set for string array
 3984/    176A : 177C 0080 05B5         	MOVE.b	#$80,Dtypef(a3)			; and set data type to string
 3985/    1770 : 600C                   	BRA.s		LAB_1F6B				; skip integer test
 3986/    1772 :                        
 3987/    1772 :                        LAB_1F6A
 3988/    1772 : 4A2B 046C              	TST.b		Varname+2(a3)			; test if integer array
 3989/    1776 : 6A06                   	BPL.s		LAB_1F6B				; branch if not integer
 3990/    1778 :                        
 3991/    1778 : 177C 0040 05B5         	MOVE.b	#$40,Dtypef(a3)			; else set data type to integer
 3992/    177E :                        LAB_1F6B
 3993/    177E : 6104                   	BSR.s		LAB_1F7C				; do element size (d1)	; array size (Asptl)
 3994/    1780 : D1C0                   	ADDA.l	d0,a0					; add array data start pointer
 3995/    1782 :                        RTS_011
 3996/    1782 : 4E75                   	RTS
 3997/    1784 :                        
 3998/    1784 :                        
 3999/    1784 :                        ;************************************************************************************
 4000/    1784 :                        ;
 4001/    1784 :                        ; do this dimension size (d1)	; array data size (Asptl)
 4002/    1784 :                        
 4003/    1784 :                        ; do a 16 x 32 bit multiply
 4004/    1784 :                        ; d1 holds the 16 bit multiplier
 4005/    1784 :                        ; Asptl holds the 32 bit multiplicand
 4006/    1784 :                        
 4007/    1784 :                        ; d0	bbbb  bbbb
 4008/    1784 :                        ; d1	0000  aaaa
 4009/    1784 :                        ;	----------
 4010/    1784 :                        ; d0	rrrr  rrrr
 4011/    1784 :                        
 4012/    1784 :                        LAB_1F7C
 4013/    1784 : 202B 05A8              	MOVE.l	Asptl(a3),d0			; get result
 4014/    1788 : 2400                   	MOVE.l	d0,d2					; copy it
 4015/    178A : 4842                   	SWAP		d2					; shift high word to low word
 4016/    178C : C0C1                   	MULU.w	d1,d0					; d1	; low word = low result
 4017/    178E : C4C1                   	MULU.w	d1,d2					; d1	; high word = high result
 4018/    1790 : 4842                   	SWAP		d2					; align words for test
 4019/    1792 : 4A42                   	TST.w		d2					; must be zero
 4020/    1794 : 6600 EECC              	BNE		LAB_OMER				; if overflow go do "Out of memory" error
 4021/    1798 :                        
 4022/    1798 : D082                   	ADD.l		d2,d0					; calculate result
 4023/    179A : 6500 EEC6              	BCS		LAB_OMER				; if overflow go do "Out of memory" error
 4024/    179E :                        
 4025/    179E : D0AB 05A8              	ADD.l		Asptl(a3),d0			; add original
 4026/    17A2 : 6500 EEBE              	BCS		LAB_OMER				; if overflow go do "Out of memory" error
 4027/    17A6 :                        
 4028/    17A6 : 4E75                   	RTS
 4029/    17A8 :                        
 4030/    17A8 :                        
 4031/    17A8 :                        ;************************************************************************************
 4032/    17A8 :                        ;
 4033/    17A8 :                        ; perform FRE()
 4034/    17A8 :                        
 4035/    17A8 :                        LAB_FRE
 4036/    17A8 : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
 4037/    17AC :                        								; $00=float
 4038/    17AC : 6A04                   	BPL.s		LAB_1FB4				; branch if numeric
 4039/    17AE :                        
 4040/    17AE : 6100 0318              	BSR		LAB_22B6				; pop string off descriptor stack, or from
 4041/    17B2 :                        								; top of string space, returns d0 = length,
 4042/    17B2 :                        								; a0 = pointer
 4043/    17B2 :                        
 4044/    17B2 :                        								; FRE(n) was numeric so do this
 4045/    17B2 :                        LAB_1FB4
 4046/    17B2 : 6100 01CC              	BSR		LAB_GARB				; go do garbage collection
 4047/    17B6 : 202B 0446              	MOVE.l	Sstorl(a3),d0			; get bottom of string space
 4048/    17BA : 90AB 0442              	SUB.l		Earryl(a3),d0			; subtract array mem end
 4049/    17BE :                        
 4050/    17BE :                        
 4051/    17BE :                        ;************************************************************************************
 4052/    17BE :                        ;
 4053/    17BE :                        ; convert d0 to signed longword in FAC1
 4054/    17BE :                        
 4055/    17BE :                        LAB_AYFC
 4056/    17BE : 177C 0000 05B5         	MOVE.b	#$00,Dtypef(a3)			; clear data type, $80=string, $40=integer,
 4057/    17C4 :                        								; $00=float
 4058/    17C4 : 377C A000 0594         	MOVE.w	#$A000,FAC1_e(a3)			; set FAC1 exponent and clear sign (b7)
 4059/    17CA : 2740 0590              	MOVE.l	d0,FAC1_m(a3)			; save FAC1 mantissa
 4060/    17CE : 6A00 0640              	BPL		LAB_24D0				; convert if +ve
 4061/    17D2 :                        
 4062/    17D2 : 003C 0001              	ORI.b		#1,CCR				; else set carry
 4063/    17D6 : 6000 0638              	BRA		LAB_24D0				; do +/- (carry is sign) & normalise FAC1
 4064/    17DA :                        
 4065/    17DA :                        
 4066/    17DA :                        ;************************************************************************************
 4067/    17DA :                        ;
 4068/    17DA :                        ; remember if the line length is zero (infinite line) then POS(n) will return
 4069/    17DA :                        ; position MOD tabsize
 4070/    17DA :                        
 4071/    17DA :                        ; perform POS()
 4072/    17DA :                        
 4073/    17DA :                        LAB_POS
 4074/    17DA : 102B 05E5              	MOVE.b	TPos(a3),d0				; get terminal position
 4075/    17DE :                        
 4076/    17DE :                        ; convert d0 to unsigned byte in FAC1
 4077/    17DE :                        
 4078/    17DE :                        LAB_1FD0
 4079/    17DE : C0BC 0000 00FF         	AND.l		#$FF,d0				; clear high bits
 4080/    17E4 : 60D8                   	BRA.s		LAB_AYFC				; convert d0 to signed longword in FAC1 & RET
 4081/    17E6 :                        
 4082/    17E6 :                        ; check not direct (used by DEF and INPUT)
 4083/    17E6 :                        
 4084/    17E6 :                        LAB_CKRN
 4085/    17E6 : 4A2B 0452              	TST.b		Clinel(a3)				; test current line #
 4086/    17EA : 6B00 EE62              	BMI		LAB_IDER				; if -ve go do illegal direct error then warm
 4087/    17EE :                        								; start
 4088/    17EE :                        
 4089/    17EE : 4E75                   	RTS							; can continue so return
 4090/    17F0 :                        
 4091/    17F0 :                        
 4092/    17F0 :                        ;************************************************************************************
 4093/    17F0 :                        ;
 4094/    17F0 :                        ; perform DEF
 4095/    17F0 :                        
 4096/    17F0 :                        LAB_DEF
 4097/    17F0 : 70AB                   	MOVEQ		#TK_FN-$100,d0			; get FN token
 4098/    17F2 : 6100 FAC0              	BSR		LAB_SCCA				; scan for CHR$(d0), else syntax error and
 4099/    17F6 :                        								; warm start
 4100/    17F6 :                        								; return character after d0
 4101/    17F6 : 177C 0080 05DF         	MOVE.b	#$80,Sufnxf(a3)			; set FN flag bit
 4102/    17FC : 6100 FCDA              	BSR		LAB_1D12				; get FN name
 4103/    1800 : 2748 05B0              	MOVE.l	a0,func_l(a3)			; save function pointer
 4104/    1804 :                        
 4105/    1804 : 61E0                   	BSR.s		LAB_CKRN				; check not direct (back here if ok)
 4106/    1806 : 0C1D 0028              	CMP.b		#$28,(a5)+				; check next byte is "(" and increment
 4107/    180A : 6600 EE6A              	BNE		LAB_SNER				; else do syntax error/warm start
 4108/    180E :                        
 4109/    180E : 177C 007E 05DF         	MOVE.b	#$7E,Sufnxf(a3)			; set FN variable flag bits
 4110/    1814 : 6100 FCB4              	BSR		LAB_SVAR				; search for or create a variable
 4111/    1818 :                        								; return the variable address in a0
 4112/    1818 : 6100 FA90              	BSR		LAB_1BFB				; scan for ")", else do syntax error/warm start
 4113/    181C : 70BD                   	MOVEQ		#TK_EQUAL-$100,d0			; = token
 4114/    181E : 6100 FA94              	BSR		LAB_SCCA				; scan for CHR$(A), else syntax error/warm start
 4115/    1822 :                        								; return character after d0
 4116/    1822 : 2F2B 046A              	MOVE.l	Varname(a3),-(sp)			; push current variable name
 4117/    1826 : 2F0D                   	MOVE.l	a5,-(sp)				; push BASIC execute pointer
 4118/    1828 : 6100 F412              	BSR		LAB_DATA				; go perform DATA, find end of DEF FN statement
 4119/    182C : 206B 05B0              	MOVEA.l	func_l(a3),a0			; get the function pointer
 4120/    1830 : 209F                   	MOVE.l	(sp)+,(a0)				; save BASIC execute pointer to function
 4121/    1832 : 215F 0004              	MOVE.l	(sp)+,4(a0)				; save current variable name to function
 4122/    1836 : 4E75                   	RTS
 4123/    1838 :                        
 4124/    1838 :                        
 4125/    1838 :                        ;************************************************************************************
 4126/    1838 :                        ;
 4127/    1838 :                        ; evaluate FNx
 4128/    1838 :                        
 4129/    1838 :                        LAB_201E
 4130/    1838 : 177C 0081 05DF         	MOVE.b	#$81,Sufnxf(a3)			; set FN flag (find not create)
 4131/    183E : 6100 FA7C              	BSR		LAB_IGBY				; increment & scan memory
 4132/    1842 : 6100 FC94              	BSR		LAB_1D12				; get FN name
 4133/    1846 : 1F2B 05B5              	MOVE.b	Dtypef(a3),-(sp)			; push data type flag (function type)
 4134/    184A : 2F08                   	MOVE.l	a0,-(sp)				; push function pointer
 4135/    184C : 0C15 0028              	CMP.b		#$28,(a5)				; check next byte is "(", no increment
 4136/    1850 : 6600 EE24              	BNE		LAB_SNER				; else do syntax error/warm start
 4137/    1854 :                        
 4138/    1854 : 6100 FA50              	BSR		LAB_1BF7				; evaluate expression within parentheses
 4139/    1858 : 205F                   	MOVEA.l	(sp)+,a0				; pop function pointer
 4140/    185A : 2748 05B0              	MOVE.l	a0,func_l(a3)			; set function pointer
 4141/    185E : 1F2B 05B5              	MOVE.b	Dtypef(a3),-(sp)			; push data type flag (function expression type)
 4142/    1862 :                        
 4143/    1862 : 2028 0004              	MOVE.l	4(a0),d0				; get function variable name
 4144/    1866 : 6100 FCDA              	BSR		LAB_1D4A				; go find function variable (already created)
 4145/    186A :                        
 4146/    186A :                        								; now check type match for variable
 4147/    186A : 101F                   	MOVE.b	(sp)+,d0				; pop data type flag (function expression type)
 4148/    186C : E318                   	ROL.b		#1,d0					; set carry if type = string
 4149/    186E : 6100 F8D8              	BSR		LAB_CKTM				; type match check, set C for string
 4150/    1872 :                        
 4151/    1872 :                        								; now stack the function variable value before
 4152/    1872 :                        								; use
 4153/    1872 : 6712                   	BEQ.s		LAB_2043				; branch if not string
 4154/    1874 :                        
 4155/    1874 : 43EB 0476              	LEA		des_sk_e(a3),a1			; get string stack pointer max+1
 4156/    1878 : B9C9                   	CMPA.l	a1,a4					; compare string stack pointer with max+1
 4157/    187A : 6700 EDC6              	BEQ		LAB_SCER				; if no space on the stack go do string too
 4158/    187E :                        								; complex error
 4159/    187E :                        
 4160/    187E : 3928 0004              	MOVE.w	4(a0),-(a4)				; string length on descriptor stack
 4161/    1882 : 2910                   	MOVE.l	(a0),-(a4)				; string address on stack
 4162/    1884 : 6002                   	BRA.s		LAB_204S				; skip var push
 4163/    1886 :                        
 4164/    1886 :                        LAB_2043
 4165/    1886 : 2F10                   	MOVE.l	(a0),-(sp)				; push variable
 4166/    1888 :                        LAB_204S
 4167/    1888 : 2F08                   	MOVE.l	a0,-(sp)				; push variable address
 4168/    188A : 1F2B 05B5              	MOVE.b	Dtypef(a3),-(sp)			; push variable data type
 4169/    188E :                        
 4170/    188E : 6132                   	BSR.s		LAB_2045				; pack function expression value into (a0)
 4171/    1890 :                        								; (function variable)
 4172/    1890 : 2F0D                   	MOVE.l	a5,-(sp)				; push BASIC execute pointer
 4173/    1892 : 206B 05B0              	MOVEA.l	func_l(a3),a0			; get function pointer
 4174/    1896 : 2A50                   	MOVEA.l	(a0),a5				; save function execute ptr as BASIC execute ptr
 4175/    1898 : 6100 F8C2              	BSR		LAB_EVEX				; evaluate expression
 4176/    189C : 6100 FA20              	BSR		LAB_GBYT				; scan memory
 4177/    18A0 : 6600 EDD4              	BNE		LAB_SNER				; if not [EOL] or [EOS] do syntax error and
 4178/    18A4 :                        								; warm start
 4179/    18A4 :                        
 4180/    18A4 : 2A5F                   	MOVE.l	(sp)+,a5				; restore BASIC execute pointer
 4181/    18A6 :                        
 4182/    18A6 :                        ; restore variable from stack and test data type
 4183/    18A6 :                        
 4184/    18A6 : 101F                   	MOVE.b	(sp)+,d0				; pull variable data type
 4185/    18A8 : 205F                   	MOVEA.l	(sp)+,a0				; pull variable address
 4186/    18AA : 4A00                   	TST.b		d0					; test variable data type
 4187/    18AC : 6A08                   	BPL.s		LAB_204T				; branch if not string
 4188/    18AE :                        
 4189/    18AE : 209C                   	MOVE.l	(a4)+,(a0)				; string address from descriptor stack
 4190/    18B0 : 315C 0004              	MOVE.w	(a4)+,4(a0)				; string length from descriptor stack
 4191/    18B4 : 6002                   	BRA.s		LAB_2044				; skip variable pull
 4192/    18B6 :                        
 4193/    18B6 :                        LAB_204T
 4194/    18B6 : 209F                   	MOVE.l	(sp)+,(a0)				; restore variable from stack
 4195/    18B8 :                        LAB_2044
 4196/    18B8 : 101F                   	MOVE.b	(sp)+,d0				; pop data type flag (function type)
 4197/    18BA : E318                   	ROL.b		#1,d0					; set carry if type = string
 4198/    18BC : 6100 F88A              	BSR		LAB_CKTM				; type match check, set C for string
 4199/    18C0 : 4E75                   	RTS
 4200/    18C2 :                        
 4201/    18C2 :                        LAB_2045
 4202/    18C2 : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type
 4203/    18C6 : 6A00 07F0              	BPL		LAB_2778				; if numeric pack FAC1 into variable (a0)
 4204/    18CA :                        								; and return
 4205/    18CA :                        
 4206/    18CA : 2448                   	MOVEA.l	a0,a2					; copy variable pointer
 4207/    18CC : 6000 F512              	BRA		LAB_17D6				; go do string LET & return
 4208/    18D0 :                        
 4209/    18D0 :                        
 4210/    18D0 :                        
 4211/    18D0 :                        ;************************************************************************************
 4212/    18D0 :                        ;
 4213/    18D0 :                        ; perform STR$()
 4214/    18D0 :                        
 4215/    18D0 :                        LAB_STRS
 4216/    18D0 : 6100 0950              	BSR		LAB_2970				; convert FAC1 to string
 4217/    18D4 :                        
 4218/    18D4 :                        ; scan, set up string
 4219/    18D4 :                        ; print " terminated string to FAC1 stack
 4220/    18D4 :                        
 4221/    18D4 :                        LAB_20AE
 4222/    18D4 : 7422                   	MOVEQ		#$22,d2				; set Srchc character (terminator 1)
 4223/    18D6 : 3602                   	MOVE.w	d2,d3					; set Asrch character (terminator 2)
 4224/    18D8 :                        
 4225/    18D8 :                        ; print d2/d3 terminated string to FAC1 stack
 4226/    18D8 :                        ; d2 = Srchc, d3 = Asrch, a0 is source
 4227/    18D8 :                        ; a6 is temp
 4228/    18D8 :                        
 4229/    18D8 :                        LAB_20B4
 4230/    18D8 : 7200                   	MOVEQ		#0,d1					; clear longword
 4231/    18DA : 5341                   	SUBQ.w	#1,d1					; set length to -1
 4232/    18DC : 2448                   	MOVEA.l	a0,a2					; copy start to calculate end
 4233/    18DE :                        LAB_20BE
 4234/    18DE : 5241                   	ADDQ.w	#1,d1					; increment length
 4235/    18E0 : 1030 1000              	MOVE.b	(a0,d1.w),d0			; get byte from string
 4236/    18E4 : 6710                   	BEQ.s		LAB_20D0				; exit loop if null byte [EOS]
 4237/    18E6 :                        
 4238/    18E6 : B002                   	CMP.b		d2,d0					; compare with search character (terminator 1)
 4239/    18E8 : 6704                   	BEQ.s		LAB_20CB				; branch if terminator
 4240/    18EA :                        
 4241/    18EA : B003                   	CMP.b		d3,d0					; compare with terminator 2
 4242/    18EC : 66F0                   	BNE.s		LAB_20BE				; loop if not terminator 2 (or null string)
 4243/    18EE :                        
 4244/    18EE :                        LAB_20CB
 4245/    18EE : B03C 0022              	CMP.b		#$22,d0				; compare with "
 4246/    18F2 : 6602                   	BNE.s		LAB_20D0				; branch if not "
 4247/    18F4 :                        
 4248/    18F4 : 524A                   	ADDQ.w	#1,a2					; else increment string start (skip " at end)
 4249/    18F6 :                        LAB_20D0
 4250/    18F6 : D5C1                   	ADDA.l	d1,a2					; add longowrd length to make string end+1
 4251/    18F8 :                        
 4252/    18F8 : B1CB                   	CMPA.l	a3,a0					; is string in ram
 4253/    18FA : 651E                   	BCS.s		LAB_RTST				; if not go push descriptor on stack & exit
 4254/    18FC :                        								; (could be message string from ROM)
 4255/    18FC :                        
 4256/    18FC : B1EB 042E              	CMPA.l	Smeml(a3),a0			; is string in utility ram
 4257/    1900 : 6418                   	BCC.s		LAB_RTST				; if not go push descriptor on stack & exit
 4258/    1902 :                        								; (is in string or program space)
 4259/    1902 :                        
 4260/    1902 :                        								; (else) copy string to string memory
 4261/    1902 :                        LAB_20C9
 4262/    1902 : 2248                   	MOVEA.l	a0,a1					; copy descriptor pointer
 4263/    1904 : 2001                   	MOVE.l	d1,d0					; copy longword length
 4264/    1906 : 6604                   	BNE.s		LAB_20D8				; branch if not null string
 4265/    1908 :                        
 4266/    1908 : 2041                   	MOVEA.l	d1,a0					; make null pointer
 4267/    190A : 600E                   	BRA.s		LAB_RTST				; go push descriptor on stack & exit
 4268/    190C :                        
 4269/    190C :                        LAB_20D8
 4270/    190C : 6126                   	BSR.s		LAB_2115				; make string space d1 bytes long
 4271/    190E : D1C1                   	ADDA.l	d1,a0					; new string end
 4272/    1910 : D3C1                   	ADDA.l	d1,a1					; old string end
 4273/    1912 : 5340                   	SUBQ.w	#1,d0					; -1 for DBF loop
 4274/    1914 :                        LAB_20E0
 4275/    1914 : 1121                   	MOVE.b	-(a1),-(a0)				; copy byte (source can be odd aligned)
 4276/    1916 : 51C8 FFFC              	DBF		d0,LAB_20E0				; loop until done
 4277/    191A :                        
 4278/    191A :                        
 4279/    191A :                        
 4280/    191A :                        ;************************************************************************************
 4281/    191A :                        ;
 4282/    191A :                        ; check for space on descriptor stack then ...
 4283/    191A :                        ; put string address and length on descriptor stack & update stack pointers
 4284/    191A :                        ; start is in a0, length is in d1
 4285/    191A :                        
 4286/    191A :                        LAB_RTST
 4287/    191A : 43EB 0476              	LEA		des_sk_e(a3),a1			; get string stack pointer max+1
 4288/    191E : B9C9                   	CMPA.l	a1,a4					; compare string stack pointer with max+1
 4289/    1920 : 6700 ED20              	BEQ		LAB_SCER				; if no space on string stack ..
 4290/    1924 :                        								; .. go do 'string too complex' error
 4291/    1924 :                        
 4292/    1924 :                        								; push string & update pointers
 4293/    1924 : 3901                   	MOVE.w	d1,-(a4)				; string length on descriptor stack
 4294/    1926 : 2908                   	MOVE.l	a0,-(a4)				; string address on stack
 4295/    1928 : 274C 0590              	MOVE.l	a4,FAC1_m(a3)			; string descriptor pointer in FAC1
 4296/    192C : 177C 0080 05B5         	MOVE.b	#$80,Dtypef(a3)			; save data type flag, $80=string
 4297/    1932 : 4E75                   	RTS
 4298/    1934 :                        
 4299/    1934 :                        
 4300/    1934 :                        ;************************************************************************************
 4301/    1934 :                        ;
 4302/    1934 :                        ; build descriptor a0/d1
 4303/    1934 :                        ; make space in string memory for string d1.w long
 4304/    1934 :                        ; return pointer in a0/Sutill
 4305/    1934 :                        
 4306/    1934 :                        LAB_2115
 4307/    1934 : 4A41                   	TST.w		d1					; test length
 4308/    1936 : 672E                   	BEQ.s		LAB_2128				; branch if user wants null string
 4309/    1938 :                        
 4310/    1938 :                        								; make space for string d1 long
 4311/    1938 : 2F00                   	MOVE.l	d0,-(sp)				; save d0
 4312/    193A : 7000                   	MOVEQ		#0,d0					; clear longword
 4313/    193C : 1740 05DE              	MOVE.b	d0,Gclctd(a3)			; clear garbage collected flag (b7)
 4314/    1940 : 7001                   	MOVEQ		#1,d0					; +1 to possibly round up
 4315/    1942 : C041                   	AND.w		d1,d0					; mask odd bit
 4316/    1944 : D041                   	ADD.w		d1,d0					; ensure d0 is even length
 4317/    1946 : 6404                   	BCC.s		LAB_2117				; branch if no overflow
 4318/    1948 :                        
 4319/    1948 : 7001                   	MOVEQ		#1,d0					; set to allocate 65536 bytes
 4320/    194A : 4840                   	SWAP		d0					; makes $00010000
 4321/    194C :                        LAB_2117
 4322/    194C : 206B 0446              	MOVEA.l	Sstorl(a3),a0			; get bottom of string space
 4323/    1950 : 91C0                   	SUBA.l	d0,a0					; subtract string length
 4324/    1952 : B1EB 0442              	CMPA.l	Earryl(a3),a0			; compare with top of array space
 4325/    1956 : 6512                   	BCS.s		LAB_2137				; if less do out of memory error
 4326/    1958 :                        
 4327/    1958 : 2748 0446              	MOVE.l	a0,Sstorl(a3)			; save bottom of string space
 4328/    195C : 2748 044E              	MOVE.l	a0,Sutill(a3)			; save string utility pointer
 4329/    1960 : 201F                   	MOVE.l	(sp)+,d0				; restore d0
 4330/    1962 : 4A41                   	TST.w		d1					; set flags on length
 4331/    1964 : 4E75                   	RTS
 4332/    1966 :                        
 4333/    1966 :                        LAB_2128
 4334/    1966 : 3041                   	MOVEA.w	d1,a0					; make null pointer
 4335/    1968 : 4E75                   	RTS
 4336/    196A :                        
 4337/    196A :                        LAB_2137
 4338/    196A : 4A2B 05DE              	TST.b		Gclctd(a3)				; get garbage collected flag
 4339/    196E : 6B00 ECF2              	BMI		LAB_OMER				; do "Out of memory" error, then warm start
 4340/    1972 :                        
 4341/    1972 : 2F09                   	MOVE.l	a1,-(sp)				; save a1
 4342/    1974 : 610A                   	BSR.s		LAB_GARB				; else go do garbage collection
 4343/    1976 : 225F                   	MOVEA.l	(sp)+,a1				; restore a1
 4344/    1978 : 177C 0080 05DE         	MOVE.b	#$80,Gclctd(a3)			; set garbage collected flag
 4345/    197E : 60CC                   	BRA.s		LAB_2117				; go try again
 4346/    1980 :                        
 4347/    1980 :                        
 4348/    1980 :                        ;************************************************************************************
 4349/    1980 :                        ;
 4350/    1980 :                        ; garbage collection routine
 4351/    1980 :                        
 4352/    1980 :                        LAB_GARB
 4353/    1980 : 48E7 E0E0              	MOVEM.l	d0-d2/a0-a2,-(sp)			; save registers
 4354/    1984 : 276B 044A 0446         	MOVE.l	Ememl(a3),Sstorl(a3)		; start with no strings
 4355/    198A :                        
 4356/    198A :                        								; re-run routine from last ending
 4357/    198A :                        LAB_214B
 4358/    198A : 222B 0442              	MOVE.l	Earryl(a3),d1			; set highest uncollected string so far
 4359/    198E : 7000                   	MOVEQ		#0,d0					; clear longword
 4360/    1990 : 2240                   	MOVEA.l	d0,a1					; clear string to move pointer
 4361/    1992 : 206B 043A              	MOVEA.l	Sstrl(a3),a0			; set pointer to start of strings
 4362/    1996 : 41E8 0004              	LEA		4(a0),a0				; index to string pointer
 4363/    199A : 246B 043E              	MOVEA.l	Sarryl(a3),a2			; set end pointer to start of arrays (end of
 4364/    199E :                        								; strings)
 4365/    199E : 6008                   	BRA.s		LAB_2176				; branch into loop at end loop test
 4366/    19A0 :                        
 4367/    19A0 :                        LAB_2161
 4368/    19A0 : 6100 0084              	BSR		LAB_2206				; test and set if this is the highest string
 4369/    19A4 : 41E8 000A              	LEA		10(a0),a0				; increment to next string
 4370/    19A8 :                        LAB_2176
 4371/    19A8 : B1CA                   	CMPA.l	a2,a0					; compare end of area with pointer
 4372/    19AA : 65F4                   	BCS.s		LAB_2161				; go do next if not at end
 4373/    19AC :                        
 4374/    19AC :                        ; done strings, now do arrays.
 4375/    19AC :                        
 4376/    19AC : 41E8 FFFC              	LEA		-4(a0),a0				; decrement pointer to start of arrays
 4377/    19B0 : 246B 0442              	MOVEA.l	Earryl(a3),a2			; set end pointer to end of arrays
 4378/    19B4 : 6024                   	BRA.s		LAB_218F				; branch into loop at end loop test
 4379/    19B6 :                        
 4380/    19B6 :                        LAB_217E
 4381/    19B6 : 2428 0004              	MOVE.l	4(a0),d2				; get array size
 4382/    19BA : D488                   	ADD.l		a0,d2					; makes start of next array
 4383/    19BC :                        
 4384/    19BC : 2010                   	MOVE.l	(a0),d0				; get array name
 4385/    19BE : 0800 0017              	BTST		#23,d0				; test string flag
 4386/    19C2 : 6714                   	BEQ.s		LAB_218B				; branch if not string
 4387/    19C4 :                        
 4388/    19C4 : 3028 0008              	MOVE.w	8(a0),d0				; get # of dimensions
 4389/    19C8 : D040                   	ADD.w		d0,d0					; *2
 4390/    19CA : D0C0                   	ADDA.w	d0,a0					; add to skip dimension size(s)
 4391/    19CC : 41E8 000A              	LEA		10(a0),a0				; increment to first element
 4392/    19D0 :                        LAB_2183
 4393/    19D0 : 6154                   	BSR.s		LAB_2206				; test and set if this is the highest string
 4394/    19D2 : 5C48                   	ADDQ.w	#6,a0					; increment to next element
 4395/    19D4 : B1C2                   	CMPA.l	d2,a0					; compare with start of next array
 4396/    19D6 : 66F8                   	BNE.s		LAB_2183				; go do next if not at end of array
 4397/    19D8 :                        
 4398/    19D8 :                        LAB_218B
 4399/    19D8 : 2042                   	MOVEA.l	d2,a0					; pointer to next array
 4400/    19DA :                        LAB_218F
 4401/    19DA : B5C8                   	CMPA.l	a0,a2					; compare pointer with array end
 4402/    19DC : 66D8                   	BNE.s		LAB_217E				; go do next if not at end
 4403/    19DE :                        
 4404/    19DE :                        ; done arrays and variables, now just the descriptor stack to do
 4405/    19DE :                        
 4406/    19DE : 204C                   	MOVEA.l	a4,a0					; get descriptor stack pointer
 4407/    19E0 : 45EB 048E              	LEA		des_sk(a3),a2			; set end pointer to end of stack
 4408/    19E4 : 6006                   	BRA.s		LAB_21C4				; branch into loop at end loop test
 4409/    19E6 :                        
 4410/    19E6 :                        LAB_21C2
 4411/    19E6 : 613E                   	BSR.s		LAB_2206				; test and set if this is the highest string
 4412/    19E8 : 41E8 0006              	LEA		6(a0),a0				; increment to next string
 4413/    19EC :                        LAB_21C4
 4414/    19EC : B5C8                   	CMPA.l	a0,a2					; compare pointer with stack end
 4415/    19EE : 66F6                   	BNE.s		LAB_21C2				; go do next if not at end
 4416/    19F0 :                        
 4417/    19F0 :                        ; descriptor search complete, now either exit or set-up and move string
 4418/    19F0 :                        
 4419/    19F0 : 2009                   	MOVE.l	a1,d0					; set the flags (a1 is move string)
 4420/    19F2 : 672C                   	BEQ.s		LAB_21D1				; go tidy up and exit if no move
 4421/    19F4 :                        
 4422/    19F4 : 2051                   	MOVEA.l	(a1),a0				; a0 is now string start
 4423/    19F6 : 7200                   	MOVEQ		#0,d1					; clear d1
 4424/    19F8 : 3229 0004              	MOVE.w	4(a1),d1				; d1 is string length
 4425/    19FC : 5281                   	ADDQ.l	#1,d1					; +1
 4426/    19FE : C23C 00FE              	AND.b		#$FE,d1				; make even length
 4427/    1A02 : D1C1                   	ADDA.l	d1,a0					; pointer is now to string end+1
 4428/    1A04 : 246B 0446              	MOVEA.l	Sstorl(a3),a2			; is destination end+1
 4429/    1A08 : B1CA                   	CMPA.l	a2,a0					; does the string need moving
 4430/    1A0A : 670C                   	BEQ.s		LAB_2240				; branch if not
 4431/    1A0C :                        
 4432/    1A0C : E289                   	LSR.l		#1,d1					; word move so do /2
 4433/    1A0E : 5341                   	SUBQ.w	#1,d1					; -1 for DBF loop
 4434/    1A10 :                        LAB_2216
 4435/    1A10 : 3520                   	MOVE.w	-(a0),-(a2)				; copy word
 4436/    1A12 : 51C9 FFFC              	DBF		d1,LAB_2216				; loop until done
 4437/    1A16 :                        
 4438/    1A16 : 228A                   	MOVE.l	a2,(a1)				; save new string start
 4439/    1A18 :                        LAB_2240
 4440/    1A18 : 2751 0446              	MOVE.l	(a1),Sstorl(a3)			; string start is new string mem start
 4441/    1A1C : 6000 FF6C              	BRA		LAB_214B				; re-run routine from last ending
 4442/    1A20 :                        								; (but don't collect this string)
 4443/    1A20 :                        
 4444/    1A20 :                        LAB_21D1
 4445/    1A20 : 4CDF 0707              	MOVEM.l	(sp)+,d0-d2/a0-a2			; restore registers
 4446/    1A24 : 4E75                   	RTS
 4447/    1A26 :                        
 4448/    1A26 :                        ; test and set if this is the highest string
 4449/    1A26 :                        
 4450/    1A26 :                        LAB_2206
 4451/    1A26 : 2010                   	MOVE.l	(a0),d0				; get this string pointer
 4452/    1A28 : 6728                   	BEQ.s		RTS_012				; exit if null string
 4453/    1A2A :                        
 4454/    1A2A : B280                   	CMP.l		d0,d1					; compare with highest uncollected string so far
 4455/    1A2C : 6424                   	BCC.s		RTS_012				; exit if <= with highest so far
 4456/    1A2E :                        
 4457/    1A2E : B0AB 0446              	CMP.l		Sstorl(a3),d0			; compare with bottom of string space
 4458/    1A32 : 641E                   	BCC.s		RTS_012				; exit if >= bottom of string space
 4459/    1A34 :                        
 4460/    1A34 : 70FF                   	MOVEQ		#-1,d0				; d0 = $FFFFFFFF
 4461/    1A36 : 3028 0004              	MOVE.w	4(a0),d0				; d0 is string length
 4462/    1A3A : 4440                   	NEG.w		d0					; make -ve
 4463/    1A3C : C03C 00FE              	AND.b		#$FE,d0				; make -ve even length
 4464/    1A40 : D0AB 0446              	ADD.l		Sstorl(a3),d0			; add string store to -ve length
 4465/    1A44 : B090                   	CMP.l		(a0),d0				; compare with string address
 4466/    1A46 : 6706                   	BEQ.s		LAB_2212				; if = go move string store pointer down
 4467/    1A48 :                        
 4468/    1A48 : 2210                   	MOVE.l	(a0),d1				; highest = current
 4469/    1A4A : 2248                   	MOVEA.l	a0,a1					; string to move = current
 4470/    1A4C : 4E75                   	RTS
 4471/    1A4E :                        
 4472/    1A4E :                        LAB_2212
 4473/    1A4E : 2740 0446              	MOVE.l	d0,Sstorl(a3)			; set new string store start
 4474/    1A52 :                        RTS_012
 4475/    1A52 : 4E75                   	RTS
 4476/    1A54 :                        
 4477/    1A54 :                        
 4478/    1A54 :                        ;************************************************************************************
 4479/    1A54 :                        ;
 4480/    1A54 :                        ; concatenate - add strings
 4481/    1A54 :                        ; string descriptor 1 is in FAC1_m, string 2 is in line
 4482/    1A54 :                        
 4483/    1A54 :                        LAB_224D
 4484/    1A54 : 487A F738              	PEA		LAB_1ADB(pc)			; continue evaluation after concatenate
 4485/    1A58 : 2F2B 0590              	MOVE.l	FAC1_m(a3),-(sp)			; stack descriptor pointer for string 1
 4486/    1A5C :                        
 4487/    1A5C : 6100 F80C              	BSR		LAB_GVAL				; get value from line
 4488/    1A60 : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type flag
 4489/    1A64 : 6A00 EBE4              	BPL		LAB_TMER				; if type is not string do type mismatch error
 4490/    1A68 :                        
 4491/    1A68 : 205F                   	MOVEA.l	(sp)+,a0				; restore descriptor pointer for string 1
 4492/    1A6A :                        
 4493/    1A6A :                        ;************************************************************************************
 4494/    1A6A :                        ;
 4495/    1A6A :                        ; concatenate
 4496/    1A6A :                        ; string descriptor 1 is in a0, string descriptor 2 is in FAC1_m
 4497/    1A6A :                        
 4498/    1A6A :                        LAB_224E
 4499/    1A6A : 226B 0590              	MOVEA.l	FAC1_m(a3),a1			; copy descriptor pointer 2
 4500/    1A6E : 3228 0004              	MOVE.w	4(a0),d1				; get length 1
 4501/    1A72 : D269 0004              	ADD.w		4(a1),d1				; add length 2
 4502/    1A76 : 6500 EBCE              	BCS		LAB_SLER				; if overflow go do 'string too long' error
 4503/    1A7A :                        
 4504/    1A7A : 2F08                   	MOVE.l	a0,-(sp)				; save descriptor pointer 1
 4505/    1A7C : 6100 FEB6              	BSR		LAB_2115				; make space d1 bytes long
 4506/    1A80 : 2748 0598              	MOVE.l	a0,FAC2_m(a3)			; save new string start pointer
 4507/    1A84 : 2057                   	MOVEA.l	(sp),a0				; copy descriptor pointer 1 from stack
 4508/    1A86 : 3028 0004              	MOVE.w	4(a0),d0				; get length
 4509/    1A8A : 2050                   	MOVEA.l	(a0),a0				; get string pointer
 4510/    1A8C : 6120                   	BSR.s		LAB_229E				; copy string d0 bytes long from a0 to Sutill
 4511/    1A8E :                        								; return with a0 = pointer, d1 = length
 4512/    1A8E :                        
 4513/    1A8E : 206B 0590              	MOVEA.l	FAC1_m(a3),a0			; get descriptor pointer for string 2
 4514/    1A92 : 6138                   	BSR.s		LAB_22BA				; pop (a0) descriptor, returns with ..
 4515/    1A94 :                        								; a0 = pointer, d0 = length
 4516/    1A94 : 6118                   	BSR.s		LAB_229E				; copy string d0 bytes long from a0 to Sutill
 4517/    1A96 :                        								; return with a0 = pointer, d1 = length
 4518/    1A96 :                        
 4519/    1A96 : 205F                   	MOVEA.l	(sp)+,a0				; get descriptor pointer for string 1
 4520/    1A98 : 6132                   	BSR.s		LAB_22BA				; pop (a0) descriptor, returns with ..
 4521/    1A9A :                        								; d0 = length, a0 = pointer
 4522/    1A9A :                        
 4523/    1A9A : 206B 0598              	MOVEA.l	FAC2_m(a3),a0			; retreive the result string pointer
 4524/    1A9E : 2208                   	MOVE.l	a0,d1					; copy the result string pointer
 4525/    1AA0 : 6700 FE78              	BEQ		LAB_RTST				; if it is a null string just return it
 4526/    1AA4 :                        								; a0 = pointer, d1 = length
 4527/    1AA4 :                        
 4528/    1AA4 : 4481                   	NEG.l		d1					; else make the start pointer negative
 4529/    1AA6 : D2AB 044E              	ADD.l		Sutill(a3),d1			; add the end pointert to give the length
 4530/    1AAA : 6000 FE6E              	BRA		LAB_RTST				; push string on descriptor stack
 4531/    1AAE :                        								; a0 = pointer, d1 = length
 4532/    1AAE :                        
 4533/    1AAE :                        
 4534/    1AAE :                        ;************************************************************************************
 4535/    1AAE :                        ;
 4536/    1AAE :                        ; copy string d0 bytes long from a0 to Sutill
 4537/    1AAE :                        ; return with a0 = pointer, d1 = length
 4538/    1AAE :                        
 4539/    1AAE :                        LAB_229E
 4540/    1AAE : 3200                   	MOVE.w	d0,d1					; copy and check length
 4541/    1AB0 : 6714                   	BEQ.s		RTS_013				; skip copy if null
 4542/    1AB2 :                        
 4543/    1AB2 : 226B 044E              	MOVEA.l	Sutill(a3),a1			; get destination pointer
 4544/    1AB6 : 2F09                   	MOVE.l	a1,-(sp)				; save destination string pointer
 4545/    1AB8 : 5340                   	SUBQ.w	#1,d0					; subtract for DBF loop
 4546/    1ABA :                        LAB_22A0
 4547/    1ABA : 12D8                   	MOVE.b	(a0)+,(a1)+				; copy byte
 4548/    1ABC : 51C8 FFFC              	DBF		d0,LAB_22A0				; loop if not done
 4549/    1AC0 :                        
 4550/    1AC0 : 2749 044E              	MOVE.l	a1,Sutill(a3)			; update Sutill to end of copied string
 4551/    1AC4 : 205F                   	MOVEA.l	(sp)+,a0				; restore destination string pointer
 4552/    1AC6 :                        RTS_013
 4553/    1AC6 : 4E75                   	RTS
 4554/    1AC8 :                        
 4555/    1AC8 :                        
 4556/    1AC8 :                        ;************************************************************************************
 4557/    1AC8 :                        ;
 4558/    1AC8 :                        ; pop string off descriptor stack, or from top of string space
 4559/    1AC8 :                        ; returns with d0.l = length, a0 = pointer
 4560/    1AC8 :                        
 4561/    1AC8 :                        LAB_22B6
 4562/    1AC8 : 206B 0590              	MOVEA.l	FAC1_m(a3),a0			; get descriptor pointer
 4563/    1ACC :                        
 4564/    1ACC :                        
 4565/    1ACC :                        ;************************************************************************************
 4566/    1ACC :                        ;
 4567/    1ACC :                        ; pop (a0) descriptor off stack or from string space
 4568/    1ACC :                        ; returns with d0.l = length, a0 = pointer
 4569/    1ACC :                        
 4570/    1ACC :                        LAB_22BA
 4571/    1ACC : 48E7 4040              	MOVEM.l	a1/d1,-(sp)				; save other regs
 4572/    1AD0 : B9C8                   	CMPA.l	a0,a4					; is string on the descriptor stack
 4573/    1AD2 : 6602                   	BNE.s		LAB_22BD				; skip pop if not
 4574/    1AD4 :                        
 4575/    1AD4 : 5C4C                   	ADDQ.w	#$06,a4				; else update stack pointer
 4576/    1AD6 :                        LAB_22BD
 4577/    1AD6 : 7000                   	MOVEQ		#0,d0					; clear string length longword
 4578/    1AD8 : 2258                   	MOVEA.l	(a0)+,a1				; get string address
 4579/    1ADA : 3018                   	MOVE.w	(a0)+,d0				; get string length
 4580/    1ADC :                        
 4581/    1ADC : B9C8                   	CMPA.l	a0,a4					; was it on the descriptor stack
 4582/    1ADE : 6610                   	BNE.s		LAB_22E6				; branch if it wasn't
 4583/    1AE0 :                        
 4584/    1AE0 : B3EB 0446              	CMPA.l	Sstorl(a3),a1			; compare string address with bottom of string
 4585/    1AE4 :                        								; space
 4586/    1AE4 : 660A                   	BNE.s		LAB_22E6				; branch if <>
 4587/    1AE6 :                        
 4588/    1AE6 : 7201                   	MOVEQ		#1,d1					; mask for odd bit
 4589/    1AE8 : C240                   	AND.w		d0,d1					; AND length
 4590/    1AEA : D280                   	ADD.l		d0,d1					; make it fit word aligned length
 4591/    1AEC :                        
 4592/    1AEC : D3AB 0446              	ADD.l		d1,Sstorl(a3)			; add to bottom of string space
 4593/    1AF0 :                        LAB_22E6
 4594/    1AF0 : 2049                   	MOVEA.l	a1,a0					; copy to a0
 4595/    1AF2 : 4CDF 0202              	MOVEM.l	(sp)+,a1/d1				; restore other regs
 4596/    1AF6 : 4A80                   	TST.l		d0					; set flags on length
 4597/    1AF8 : 4E75                   	RTS
 4598/    1AFA :                        
 4599/    1AFA :                        
 4600/    1AFA :                        ;************************************************************************************
 4601/    1AFA :                        ;
 4602/    1AFA :                        ; perform CHR$()
 4603/    1AFA :                        
 4604/    1AFA :                        LAB_CHRS
 4605/    1AFA : 6100 0130              	BSR		LAB_EVBY				; evaluate byte expression, result in d0 and
 4606/    1AFE :                        								; Itemp
 4607/    1AFE :                        LAB_MKCHR
 4608/    1AFE : 7201                   	MOVEQ		#1,d1					; string is single byte
 4609/    1B00 : 6100 FE32              	BSR		LAB_2115				; make string space d1 bytes long
 4610/    1B04 :                        								; return a0/Sutill = pointer, others unchanged
 4611/    1B04 : 1080                   	MOVE.b	d0,(a0)				; save byte in string (byte IS string!)
 4612/    1B06 : 6000 FE12              	BRA		LAB_RTST				; push string on descriptor stack
 4613/    1B0A :                        								; a0 = pointer, d1 = length
 4614/    1B0A :                        
 4615/    1B0A :                        
 4616/    1B0A :                        ;************************************************************************************
 4617/    1B0A :                        ;
 4618/    1B0A :                        ; perform LEFT$()
 4619/    1B0A :                        
 4620/    1B0A :                        ; enter with a0 is descriptor, d0 & Itemp is word 1
 4621/    1B0A :                        
 4622/    1B0A :                        LAB_LEFT
 4623/    1B0A : C141                   	EXG		d0,d1					; word in d1
 4624/    1B0C : 6100 F79C              	BSR		LAB_1BFB				; scan for ")", else do syntax error/warm start
 4625/    1B10 :                        
 4626/    1B10 : 4A81                   	TST.l		d1					; test returned length
 4627/    1B12 : 6722                   	BEQ.s		LAB_231C				; branch if null return
 4628/    1B14 :                        
 4629/    1B14 : 7000                   	MOVEQ		#0,d0					; clear start offset
 4630/    1B16 : B268 0004              	CMP.w		4(a0),d1				; compare word parameter with string length
 4631/    1B1A : 651A                   	BCS.s		LAB_231C				; branch if string length > word parameter
 4632/    1B1C :                        
 4633/    1B1C : 6014                   	BRA.s		LAB_2317				; go copy whole string
 4634/    1B1E :                        
 4635/    1B1E :                        
 4636/    1B1E :                        ;************************************************************************************
 4637/    1B1E :                        ;
 4638/    1B1E :                        ; perform RIGHT$()
 4639/    1B1E :                        
 4640/    1B1E :                        ; enter with a0 is descriptor, d0 & Itemp is word 1
 4641/    1B1E :                        
 4642/    1B1E :                        LAB_RIGHT
 4643/    1B1E : C141                   	EXG		d0,d1					; word in d1
 4644/    1B20 : 6100 F788              	BSR		LAB_1BFB				; scan for ")", else do syntax error/warm start
 4645/    1B24 :                        
 4646/    1B24 : 4A81                   	TST.l		d1					; test returned length
 4647/    1B26 : 670E                   	BEQ.s		LAB_231C				; branch if null return
 4648/    1B28 :                        
 4649/    1B28 : 3028 0004              	MOVE.w	4(a0),d0				; get string length
 4650/    1B2C : 9081                   	SUB.l		d1,d0					; subtract word
 4651/    1B2E : 6406                   	BCC.s		LAB_231C				; branch if string length > word parameter
 4652/    1B30 :                        
 4653/    1B30 :                        								; else copy whole string
 4654/    1B30 :                        LAB_2316
 4655/    1B30 : 7000                   	MOVEQ		#0,d0					; clear start offset
 4656/    1B32 :                        LAB_2317
 4657/    1B32 : 3228 0004              	MOVE.w	4(a0),d1				; else make parameter = length
 4658/    1B36 :                        
 4659/    1B36 :                        ; get here with ...
 4660/    1B36 :                        ;   a0 - points to descriptor
 4661/    1B36 :                        ;   d0 - is offset from string start
 4662/    1B36 :                        ;   d1 - is required string length
 4663/    1B36 :                        
 4664/    1B36 :                        LAB_231C
 4665/    1B36 : 2248                   	MOVEA.l	a0,a1					; save string descriptor pointer
 4666/    1B38 : 6100 FDFA              	BSR		LAB_2115				; make string space d1 bytes long
 4667/    1B3C :                        								; return a0/Sutill = pointer, others unchanged
 4668/    1B3C : 2049                   	MOVEA.l	a1,a0					; restore string descriptor pointer
 4669/    1B3E : 2F00                   	MOVE.l	d0,-(sp)				; save start offset (longword)
 4670/    1B40 : 618A                   	BSR.s		LAB_22BA				; pop (a0) descriptor, returns with ..
 4671/    1B42 :                        								; d0 = length, a0 = pointer
 4672/    1B42 : D1DF                   	ADDA.l	(sp)+,a0				; adjust pointer to start of wanted string
 4673/    1B44 : 3001                   	MOVE.w	d1,d0					; length to d0
 4674/    1B46 : 6100 FF66              	BSR		LAB_229E				; store string d0 bytes long from (a0) to
 4675/    1B4A :                        								; (Sutill) return with a0 = pointer,
 4676/    1B4A :                        								; d1 = length
 4677/    1B4A : 6000 FDCE              	BRA		LAB_RTST				; push string on descriptor stack
 4678/    1B4E :                        								; a0 = pointer, d1 = length
 4679/    1B4E :                        
 4680/    1B4E :                        
 4681/    1B4E :                        ;************************************************************************************
 4682/    1B4E :                        ;
 4683/    1B4E :                        ; perform MID$()
 4684/    1B4E :                        
 4685/    1B4E :                        ; enter with a0 is descriptor, d0 & Itemp is word 1
 4686/    1B4E :                        
 4687/    1B4E :                        LAB_MIDS
 4688/    1B4E : 7E00                   	MOVEQ		#0,d7					; clear longword
 4689/    1B50 : 5347                   	SUBQ.w	#1,d7					; set default length = 65535
 4690/    1B52 : 2F00                   	MOVE.l	d0,-(sp)				; save word 1
 4691/    1B54 : 6100 F768              	BSR		LAB_GBYT				; scan memory
 4692/    1B58 : B03C 002C              	CMP.b		#',',d0				; was it ","
 4693/    1B5C : 660C                   	BNE.s		LAB_2358				; branch if not "," (skip second byte get)
 4694/    1B5E :                        
 4695/    1B5E : 101D                   	MOVE.b	(a5)+,d0				; increment pointer past ","
 4696/    1B60 : 2F08                   	MOVE.l	a0,-(sp)				; save descriptor pointer
 4697/    1B62 : 6100 00DA              	BSR		LAB_GTWO				; get word parameter, result in d0 and Itemp
 4698/    1B66 : 205F                   	MOVEA.l	(sp)+,a0				; restore descriptor pointer
 4699/    1B68 : 2E00                   	MOVE.l	d0,d7					; copy length
 4700/    1B6A :                        LAB_2358
 4701/    1B6A : 6100 F73E              	BSR		LAB_1BFB				; scan for ")", else do syntax error then warm
 4702/    1B6E :                        								; start
 4703/    1B6E : 201F                   	MOVE.l	(sp)+,d0				; restore word 1
 4704/    1B70 : 7200                   	MOVEQ		#0,d1					; null length
 4705/    1B72 : 5380                   	SUBQ.l	#1,d0					; decrement start index (word 1)
 4706/    1B74 : 6B00 EAF4              	BMI		LAB_FCER				; if was null do function call error then warm
 4707/    1B78 :                        								; start
 4708/    1B78 :                        
 4709/    1B78 : B068 0004              	CMP.w		4(a0),d0				; compare string length with start index
 4710/    1B7C : 64B8                   	BCC.s		LAB_231C				; if start not in string do null string (d1=0)
 4711/    1B7E :                        
 4712/    1B7E : 2207                   	MOVE.l	d7,d1					; get length back
 4713/    1B80 : DE40                   	ADD.w		d0,d7					; d7 now = MID$() end
 4714/    1B82 : 6506                   	BCS.s		LAB_2368				; already too long so do RIGHT$ equivalent
 4715/    1B84 :                        
 4716/    1B84 : BE68 0004              	CMP.w		4(a0),d7				; compare string length with start index+length
 4717/    1B88 : 65AC                   	BCS.s		LAB_231C				; if end in string go do string
 4718/    1B8A :                        
 4719/    1B8A :                        LAB_2368
 4720/    1B8A : 3228 0004              	MOVE.w	4(a0),d1				; get string length
 4721/    1B8E : 9240                   	SUB.w		d0,d1					; subtract start offset
 4722/    1B90 : 60A4                   	BRA.s		LAB_231C				; go do string (effectively RIGHT$)
 4723/    1B92 :                        
 4724/    1B92 :                        
 4725/    1B92 :                        ;************************************************************************************
 4726/    1B92 :                        ;
 4727/    1B92 :                        ; perform LCASE$()
 4728/    1B92 :                        
 4729/    1B92 :                        LAB_LCASE
 4730/    1B92 : 6100 FF34              	BSR		LAB_22B6				; pop string off descriptor stack or from memory
 4731/    1B96 :                        								; returns with d0 = length, a0 = pointer
 4732/    1B96 : 2200                   	MOVE.l	d0,d1					; copy the string length
 4733/    1B98 : 6756                   	BEQ.s		NoString				; if null go return a null string
 4734/    1B9A :                        
 4735/    1B9A :                        ; else copy and change the string
 4736/    1B9A :                        
 4737/    1B9A : 2248                   	MOVEA.l	a0,a1					; copy the string address
 4738/    1B9C : 6100 FD96              	BSR		LAB_2115				; make a string space d1 bytes long
 4739/    1BA0 : D1C1                   	ADDA.l	d1,a0					; new string end
 4740/    1BA2 : D3C1                   	ADDA.l	d1,a1					; old string end
 4741/    1BA4 : 3401                   	MOVE.w	d1,d2					; copy length for loop
 4742/    1BA6 : 5342                   	SUBQ.w	#1,d2					; -1 for DBF loop
 4743/    1BA8 :                        LC_loop
 4744/    1BA8 : 1021                   	MOVE.b	-(a1),d0				; get byte from string
 4745/    1BAA :                        
 4746/    1BAA : B03C 005B              	CMP.b		#$5B,d0				; compare with "Z"+1
 4747/    1BAE : 640A                   	BCC.s		NoUcase				; if > "Z" skip change
 4748/    1BB0 :                        
 4749/    1BB0 : B03C 0041              	CMP.b		#$41,d0				; compare with "A"
 4750/    1BB4 : 6504                   	BCS.s		NoUcase				; if < "A" skip change
 4751/    1BB6 :                        
 4752/    1BB6 : 0000 0020              	ORI.b		#$20,d0				; convert upper case to lower case
 4753/    1BBA :                        NoUcase
 4754/    1BBA : 1100                   	MOVE.b	d0,-(a0)				; copy upper case byte back to string
 4755/    1BBC : 51CA FFEA              	DBF		d2,LC_loop				; decrement and loop if not all done
 4756/    1BC0 :                        
 4757/    1BC0 : 602E                   	BRA.s		NoString				; tidy up & exit (branch always)
 4758/    1BC2 :                        
 4759/    1BC2 :                        
 4760/    1BC2 :                        ;************************************************************************************
 4761/    1BC2 :                        ;
 4762/    1BC2 :                        ; perform UCASE$()
 4763/    1BC2 :                        
 4764/    1BC2 :                        LAB_UCASE
 4765/    1BC2 : 6100 FF04              	BSR		LAB_22B6				; pop string off descriptor stack or from memory
 4766/    1BC6 :                        								; returns with d0 = length, a0 = pointer
 4767/    1BC6 : 2200                   	MOVE.l	d0,d1					; copy the string length
 4768/    1BC8 : 6726                   	BEQ.s		NoString				; if null go return a null string
 4769/    1BCA :                        
 4770/    1BCA :                        ; else copy and change the string
 4771/    1BCA :                        
 4772/    1BCA : 2248                   	MOVEA.l	a0,a1					; copy the string address
 4773/    1BCC : 6100 FD66              	BSR		LAB_2115				; make a string space d1 bytes long
 4774/    1BD0 : D1C1                   	ADDA.l	d1,a0					; new string end
 4775/    1BD2 : D3C1                   	ADDA.l	d1,a1					; old string end
 4776/    1BD4 : 3401                   	MOVE.w	d1,d2					; copy length for loop
 4777/    1BD6 : 5342                   	SUBQ.w	#1,d2					; -1 for DBF loop
 4778/    1BD8 :                        UC_loop
 4779/    1BD8 : 1021                   	MOVE.b	-(a1),d0				; get a byte from the string
 4780/    1BDA :                        
 4781/    1BDA : B03C 0061              	CMP.b		#$61,d0				; compare with "a"
 4782/    1BDE : 650A                   	BCS.s		NoLcase				; if < "a" skip change
 4783/    1BE0 :                        
 4784/    1BE0 : B03C 007B              	CMP.b		#$7B,d0				; compare with "z"+1
 4785/    1BE4 : 6404                   	BCC.s		NoLcase				; if > "z" skip change
 4786/    1BE6 :                        
 4787/    1BE6 : 0200 00DF              	ANDI.b	#$DF,d0				; convert lower case to upper case
 4788/    1BEA :                        NoLcase
 4789/    1BEA : 1100                   	MOVE.b	d0,-(a0)				; copy upper case byte back to string
 4790/    1BEC : 51CA FFEA              	DBF		d2,UC_loop				; decrement and loop if not all done
 4791/    1BF0 :                        
 4792/    1BF0 :                        NoString
 4793/    1BF0 : 6000 FD28              	BRA		LAB_RTST				; push string on descriptor stack
 4794/    1BF4 :                        								; a0 = pointer, d1 = length
 4795/    1BF4 :                        
 4796/    1BF4 :                        
 4797/    1BF4 :                        ;************************************************************************************
 4798/    1BF4 :                        ;
 4799/    1BF4 :                        ; perform SADD()
 4800/    1BF4 :                        
 4801/    1BF4 :                        LAB_SADD
 4802/    1BF4 : 101D                   	MOVE.b	(a5)+,d0				; increment pointer
 4803/    1BF6 : 6100 F8D6              	BSR		LAB_GVAR				; get variable address in a0
 4804/    1BFA : 6100 F6AE              	BSR		LAB_1BFB				; scan for ")", else do syntax error/warm start
 4805/    1BFE : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type flag
 4806/    1C02 : 6A00 EA46              	BPL		LAB_TMER				; if numeric do Type missmatch Error
 4807/    1C06 : 2010                   	MOVE.l	(a0),d0					; get string address
 4808/    1C08 : 6000 FBB4              	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & return
 4809/    1C0C :                        
 4810/    1C0C :                        
 4811/    1C0C :                        ;************************************************************************************
 4812/    1C0C :                        ;
 4813/    1C0C :                        ; perform LEN()
 4814/    1C0C :                        
 4815/    1C0C :                        LAB_LENS
 4816/    1C0C : 487A FBB0              	PEA		LAB_AYFC(pc)			; set return address to convert d0 to signed
 4817/    1C10 :                        								; longword in FAC1
 4818/    1C10 : 6000 FEB6              	BRA		LAB_22B6				; pop string off descriptor stack or from memory
 4819/    1C14 :                        								; returns with d0 = length, a0 = pointer
 4820/    1C14 :                        
 4821/    1C14 :                        
 4822/    1C14 :                        ;************************************************************************************
 4823/    1C14 :                        ;
 4824/    1C14 :                        ; perform ASC()
 4825/    1C14 :                        
 4826/    1C14 :                        LAB_ASC
 4827/    1C14 : 6100 FEB2              	BSR		LAB_22B6				; pop string off descriptor stack or from memory
 4828/    1C18 :                        								; returns with d0 = length, a0 = pointer
 4829/    1C18 : 4A40                   	TST.w		d0					; test length
 4830/    1C1A : 6700 EA4E              	BEQ		LAB_FCER				; if null do function call error then warm start
 4831/    1C1E :                        
 4832/    1C1E : 1010                   	MOVE.b	(a0),d0				; get first character byte
 4833/    1C20 : 6000 FBBC              	BRA		LAB_1FD0				; convert d0 to unsigned byte in FAC1 & return
 4834/    1C24 :                        
 4835/    1C24 :                        
 4836/    1C24 :                        ;************************************************************************************
 4837/    1C24 :                        ;
 4838/    1C24 :                        ; increment and get byte, result in d0 and Itemp
 4839/    1C24 :                        
 4840/    1C24 :                        LAB_SGBY
 4841/    1C24 : 6100 F696              	BSR		LAB_IGBY				; increment & scan memory
 4842/    1C28 :                        
 4843/    1C28 :                        
 4844/    1C28 :                        ;************************************************************************************
 4845/    1C28 :                        ;
 4846/    1C28 :                        ; get byte parameter, result in d0 and Itemp
 4847/    1C28 :                        
 4848/    1C28 :                        LAB_GTBY
 4849/    1C28 : 6100 F51A              	BSR		LAB_EVNM				; evaluate expression & check is numeric,
 4850/    1C2C :                        								; else do type mismatch
 4851/    1C2C :                        
 4852/    1C2C :                        
 4853/    1C2C :                        ;************************************************************************************
 4854/    1C2C :                        ;
 4855/    1C2C :                        ; evaluate byte expression, result in d0 and Itemp
 4856/    1C2C :                        
 4857/    1C2C :                        LAB_EVBY
 4858/    1C2C : 6100 F9D4              	BSR		LAB_EVPI				; evaluate positive integer expression
 4859/    1C30 :                        								; result in d0 and Itemp
 4860/    1C30 : 123C 0080              	MOVE.b		#$80,d1				; set mask/2
 4861/    1C34 : D281                   	ADD.l		d1,d1					; =$FFFFFF00
 4862/    1C36 : C280                   	AND.l		d0,d1					; check top 24 bits
 4863/    1C38 : 6600 EA30              	BNE		LAB_FCER				; if <> 0 do function call error/warm start
 4864/    1C3C :                        
 4865/    1C3C : 4E75                   	RTS
 4866/    1C3E :                        
 4867/    1C3E :                        
 4868/    1C3E :                        ;************************************************************************************
 4869/    1C3E :                        ;
 4870/    1C3E :                        ; get word parameter, result in d0 and Itemp
 4871/    1C3E :                        
 4872/    1C3E :                        LAB_GTWO
 4873/    1C3E : 6100 F504              	BSR		LAB_EVNM				; evaluate expression & check is numeric,
 4874/    1C42 :                        								; else do type mismatch
 4875/    1C42 : 6100 F9BE              	BSR		LAB_EVPI				; evaluate positive integer expression
 4876/    1C46 :                        								; result in d0 and Itemp
 4877/    1C46 : 4840                   	SWAP		d0					; copy high word to low word
 4878/    1C48 : 4A40                   	TST.w		d0					; set flags
 4879/    1C4A : 6600 EA1E              	BNE		LAB_FCER				; if <> 0 do function call error/warm start
 4880/    1C4E :                        
 4881/    1C4E : 4840                   	SWAP		d0					; copy high word to low word
 4882/    1C50 : 4E75                   	RTS
 4883/    1C52 :                        
 4884/    1C52 :                        
 4885/    1C52 :                        ;************************************************************************************
 4886/    1C52 :                        ;
 4887/    1C52 :                        ; perform VAL()
 4888/    1C52 :                        
 4889/    1C52 :                        LAB_VAL
 4890/    1C52 : 6100 FE74              	BSR		LAB_22B6				; pop string off descriptor stack or from memory
 4891/    1C56 :                        								; returns with d0 = length, a0 = pointer
 4892/    1C56 : 6722                   	BEQ.s		LAB_VALZ				; string was null so set result = $00
 4893/    1C58 :                        								; clear FAC1 exponent & sign & return
 4894/    1C58 :                        
 4895/    1C58 : 2C4D                   	MOVEA.l	a5,a6					; save BASIC execute pointer
 4896/    1C5A : 2A48                   	MOVEA.l	a0,a5					; copy string pointer to execute pointer
 4897/    1C5C : D1C0                   	ADDA.l	d0,a0					; string end+1
 4898/    1C5E : 1010                   	MOVE.b	(a0),d0				; get byte from string+1
 4899/    1C60 : 3F00                   	MOVE.w	d0,-(sp)				; save it
 4900/    1C62 : 2F08                   	MOVE.l	a0,-(sp)				; save address
 4901/    1C64 : 10BC 0000              	MOVE.b	#0,(a0)				; null terminate string
 4902/    1C68 : 6100 F654              	BSR		LAB_GBYT				; scan memory
 4903/    1C6C : 6100 114C              	BSR		LAB_2887				; get FAC1 from string
 4904/    1C70 : 205F                   	MOVEA.l	(sp)+,a0				; restore pointer
 4905/    1C72 : 301F                   	MOVE.w	(sp)+,d0				; pop byte
 4906/    1C74 : 1080                   	MOVE.b	d0,(a0)				; restore to memory
 4907/    1C76 : 2A4E                   	MOVEA.l	a6,a5					; restore BASIC execute pointer
 4908/    1C78 : 4E75                   	RTS
 4909/    1C7A :                        
 4910/    1C7A :                        LAB_VALZ
 4911/    1C7A : 3740 0594              	MOVE.w	d0,FAC1_e(a3)			; clear FAC1 exponent & sign
 4912/    1C7E : 4E75                   	RTS
 4913/    1C80 :                        
 4914/    1C80 :                        
 4915/    1C80 :                        ;************************************************************************************
 4916/    1C80 :                        ;
 4917/    1C80 :                        ; get two parameters for POKE or WAIT, first parameter in a0, second in d0
 4918/    1C80 :                        
 4919/    1C80 :                        LAB_GADB
 4920/    1C80 : 6100 F4C2              	BSR		LAB_EVNM				; evaluate expression & check is numeric,
 4921/    1C84 :                        								; else do type mismatch
 4922/    1C84 : 6100 F984              	BSR		LAB_EVIR				; evaluate integer expression
 4923/    1C88 :                        								; (does FC error not OF error if out of range)
 4924/    1C88 : 2F00                   	MOVE.l	d0,-(sp)				; copy to stack
 4925/    1C8A : 6100 F626              	BSR		LAB_1C01				; scan for ",", else do syntax error/warm start
 4926/    1C8E : 6198                   	BSR.s		LAB_GTBY				; get byte parameter, result in d0 and Itemp
 4927/    1C90 : 205F                   	MOVEA.l	(sp)+,a0				; pull address
 4928/    1C92 : 4E75                   	RTS
 4929/    1C94 :                        
 4930/    1C94 :                        
 4931/    1C94 :                        ;************************************************************************************
 4932/    1C94 :                        ;
 4933/    1C94 :                        ; get two parameters for DOKE or WAITW, first parameter in a0, second in d0
 4934/    1C94 :                        
 4935/    1C94 :                        LAB_GADW
 4936/    1C94 : 611E                   	BSR.s		LAB_GEAD				; get even address for word/long memory actions
 4937/    1C96 :                        								; address returned in d0 and on the stack
 4938/    1C96 : 6100 F61A              	BSR		LAB_1C01				; scan for ",", else do syntax error/warm start
 4939/    1C9A : 6100 F4A8              	BSR		LAB_EVNM				; evaluate expression & check is numeric,
 4940/    1C9E :                        								; else do type mismatch
 4941/    1C9E : 6100 F96A              	BSR		LAB_EVIR				; evaluate integer expression
 4942/    1CA2 :                        								; result in d0 and Itemp
 4943/    1CA2 : 4840                   	SWAP		d0					; swap words
 4944/    1CA4 : 4A40                   	TST.w		d0					; test high word
 4945/    1CA6 : 6706                   	BEQ.s		LAB_XGADW				; exit if null
 4946/    1CA8 :                        
 4947/    1CA8 : 5240                   	ADDQ.w	#1,d0					; increment word
 4948/    1CAA : 6600 E9BE              	BNE		LAB_FCER				; if <> 0 do function call error/warm start
 4949/    1CAE :                        
 4950/    1CAE :                        LAB_XGADW
 4951/    1CAE : 4840                   	SWAP		d0					; swap words back
 4952/    1CB0 : 205F                   	MOVEA.l	(sp)+,a0				; pull address
 4953/    1CB2 : 4E75                   	RTS
 4954/    1CB4 :                        
 4955/    1CB4 :                        
 4956/    1CB4 :                        ;************************************************************************************
 4957/    1CB4 :                        ;
 4958/    1CB4 :                        ; get even address (for word or longword memory actions)
 4959/    1CB4 :                        ; address returned in d0 and on the stack
 4960/    1CB4 :                        ; does address error if the address is odd
 4961/    1CB4 :                        
 4962/    1CB4 :                        LAB_GEAD
 4963/    1CB4 : 6100 F48E              	BSR		LAB_EVNM				; evaluate expression & check is numeric,
 4964/    1CB8 :                        								; else do type mismatch
 4965/    1CB8 : 6100 F950              	BSR		LAB_EVIR				; evaluate integer expression
 4966/    1CBC :                        								; (does FC error not OF error if out of range)
 4967/    1CBC : 0800 0000              	BTST		#0,d0					; test low bit of longword
 4968/    1CC0 : 6600 E964              	BNE		LAB_ADER				; if address is odd do address error/warm start
 4969/    1CC4 :                        
 4970/    1CC4 : 2057                   	MOVEA.l	(sp),a0				; copy return address
 4971/    1CC6 : 2E80                   	MOVE.l	d0,(sp)				; even address on stack
 4972/    1CC8 : 4ED0                   	JMP		(a0)					; effectively RTS
 4973/    1CCA :                        
 4974/    1CCA :                        
 4975/    1CCA :                        ;************************************************************************************
 4976/    1CCA :                        ;
 4977/    1CCA :                        ; perform PEEK()
 4978/    1CCA :                        
 4979/    1CCA :                        LAB_PEEK
 4980/    1CCA : 6100 F93E              	BSR		LAB_EVIR				; evaluate integer expression
 4981/    1CCE :                        								; (does FC error not OF error if out of range)
 4982/    1CCE : 2040                   	MOVEA.l	d0,a0					; copy to address register
 4983/    1CD0 : 1010                   	MOVE.b	(a0),d0				; get byte
 4984/    1CD2 : 6000 FB0A              	BRA		LAB_1FD0				; convert d0 to unsigned byte in FAC1 & return
 4985/    1CD6 :                        
 4986/    1CD6 :                        
 4987/    1CD6 :                        ;************************************************************************************
 4988/    1CD6 :                        ;
 4989/    1CD6 :                        ; perform POKE
 4990/    1CD6 :                        
 4991/    1CD6 :                        LAB_POKE
 4992/    1CD6 : 61A8                   	BSR.s		LAB_GADB				; get two parameters for POKE or WAIT
 4993/    1CD8 :                        								; first parameter in a0, second in d0
 4994/    1CD8 : 1080                   	MOVE.b	d0,(a0)				; put byte in memory
 4995/    1CDA : 4E75                   	RTS
 4996/    1CDC :                        
 4997/    1CDC :                        
 4998/    1CDC :                        ;************************************************************************************
 4999/    1CDC :                        ;
 5000/    1CDC :                        ; perform DEEK()
 5001/    1CDC :                        
 5002/    1CDC :                        LAB_DEEK
 5003/    1CDC : 6100 F92C              	BSR		LAB_EVIR				; evaluate integer expression
 5004/    1CE0 :                        								; (does FC error not OF error if out of range)
 5005/    1CE0 : E208                   	LSR.b		#1,d0					; shift bit 0 to carry
 5006/    1CE2 : 6500 E942              	BCS		LAB_ADER				; if address is odd do address error/warm start
 5007/    1CE6 :                        
 5008/    1CE6 : D000                   	ADD.b		d0,d0					; shift byte back
 5009/    1CE8 : C188                   	EXG		d0,a0					; copy to address register
 5010/    1CEA : 7000                   	MOVEQ		#0,d0					; clear top bits
 5011/    1CEC : 3010                   	MOVE.w	(a0),d0				; get word
 5012/    1CEE : 6000 FACE              	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & return
 5013/    1CF2 :                        
 5014/    1CF2 :                        
 5015/    1CF2 :                        ;************************************************************************************
 5016/    1CF2 :                        ;
 5017/    1CF2 :                        ; perform LEEK()
 5018/    1CF2 :                        
 5019/    1CF2 :                        LAB_LEEK
 5020/    1CF2 : 6100 F916              	BSR		LAB_EVIR				; evaluate integer expression
 5021/    1CF6 :                        								; (does FC error not OF error if out of range)
 5022/    1CF6 : E208                   	LSR.b		#1,d0					; shift bit 0 to carry
 5023/    1CF8 : 6500 E92C              	BCS		LAB_ADER				; if address is odd do address error/warm start
 5024/    1CFC :                        
 5025/    1CFC : D000                   	ADD.b		d0,d0					; shift byte back
 5026/    1CFE : C188                   	EXG		d0,a0					; copy to address register
 5027/    1D00 : 2010                   	MOVE.l	(a0),d0				; get longword
 5028/    1D02 : 6000 FABA              	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & return
 5029/    1D06 :                        
 5030/    1D06 :                        
 5031/    1D06 :                        ;************************************************************************************
 5032/    1D06 :                        ;
 5033/    1D06 :                        ; perform DOKE
 5034/    1D06 :                        
 5035/    1D06 :                        LAB_DOKE
 5036/    1D06 : 618C                   	BSR.s		LAB_GADW				; get two parameters for DOKE or WAIT
 5037/    1D08 :                        								; first parameter in a0, second in d0
 5038/    1D08 : 3080                   	MOVE.w	d0,(a0)				; put word in memory
 5039/    1D0A : 4E75                   	RTS
 5040/    1D0C :                        
 5041/    1D0C :                        
 5042/    1D0C :                        ;************************************************************************************
 5043/    1D0C :                        ;
 5044/    1D0C :                        ; perform LOKE
 5045/    1D0C :                        
 5046/    1D0C :                        LAB_LOKE
 5047/    1D0C : 61A6                   	BSR.s		LAB_GEAD				; get even address for word/long memory actions
 5048/    1D0E :                        								; address returned in d0 and on the stack
 5049/    1D0E : 6100 F5A2              	BSR		LAB_1C01				; scan for ",", else do syntax error/warm start
 5050/    1D12 : 6100 F430              	BSR		LAB_EVNM				; evaluate expression & check is numeric,
 5051/    1D16 :                        								; else do type mismatch
 5052/    1D16 : 6100 F8F2              	BSR		LAB_EVIR				; evaluate integer value (no sign check)
 5053/    1D1A : 205F                   	MOVEA.l	(sp)+,a0				; pull address
 5054/    1D1C : 2080                   	MOVE.l	d0,(a0)				; put longword in memory
 5055/    1D1E :                        RTS_015
 5056/    1D1E : 4E75                   	RTS
 5057/    1D20 :                        
 5058/    1D20 :                        
 5059/    1D20 :                        ;************************************************************************************
 5060/    1D20 :                        ;
 5061/    1D20 :                        ; perform SWAP
 5062/    1D20 :                        
 5063/    1D20 :                        LAB_SWAP
 5064/    1D20 : 6100 F7AC              	BSR		LAB_GVAR				; get variable 1 address in a0
 5065/    1D24 : 2F08                   	MOVE.l	a0,-(sp)				; save variable 1 address
 5066/    1D26 : 182B 05B5              	MOVE.b	Dtypef(a3),d4			; copy variable 1 data type, $80=string,
 5067/    1D2A :                        								; $40=inetger, $00=float
 5068/    1D2A :                        
 5069/    1D2A : 6100 F586              	BSR		LAB_1C01				; scan for ",", else do syntax error/warm start
 5070/    1D2E : 6100 F79E              	BSR		LAB_GVAR				; get variable 2 address in a0
 5071/    1D32 : 245F                   	MOVEA.l	(sp)+,a2				; restore variable 1 address
 5072/    1D34 : B82B 05B5              	CMP.b		Dtypef(a3),d4			; compare variable 1 data type with variable 2
 5073/    1D38 :                        								; data type
 5074/    1D38 : 6600 E910              	BNE		LAB_TMER				; if not both the same type do "Type mismatch"
 5075/    1D3C :                        								; error then warm start
 5076/    1D3C :                        
 5077/    1D3C : 2010                   	MOVE.l	(a0),d0				; get variable 2
 5078/    1D3E : 20D2                   	MOVE.l	(a2),(a0)+				; copy variable 1 to variable 2
 5079/    1D40 : 24C0                   	MOVE.l	d0,(a2)+				; save variable 2 to variable 1
 5080/    1D42 :                        
 5081/    1D42 : 4A04                   	TST.b		d4					; check data type
 5082/    1D44 : 6AD8                   	BPL.s		RTS_015				; exit if not string
 5083/    1D46 :                        
 5084/    1D46 : 3010                   	MOVE.w	(a0),d0				; get string 2 length
 5085/    1D48 : 3092                   	MOVE.w	(a2),(a0)				; copy string 1 length to string 2 length
 5086/    1D4A : 3480                   	MOVE.w	d0,(a2)				; save string 2 length to string 1 length
 5087/    1D4C : 4E75                   	RTS
 5088/    1D4E :                        
 5089/    1D4E :                        
 5090/    1D4E :                        ;************************************************************************************
 5091/    1D4E :                        ;
 5092/    1D4E :                        ; perform USR
 5093/    1D4E :                        
 5094/    1D4E :                        LAB_USR
 5095/    1D4E : 4EAB 0406              	JSR		Usrjmp(a3)				; do user vector
 5096/    1D52 : 6000 F556              	BRA		LAB_1BFB				; scan for ")", else do syntax error/warm start
 5097/    1D56 :                        
 5098/    1D56 :                        
 5099/    1D56 :                        ;************************************************************************************
 5100/    1D56 :                        ;
 5101/    1D56 :                        ; perform LOAD
 5102/    1D56 :                        
 5103/    1D56 :                        LAB_LOAD
 5104/    1D56 : 4EEB 0418              	JMP		V_LOAD(a3)				; do load vector
 5105/    1D5A :                        
 5106/    1D5A :                        
 5107/    1D5A :                        ;************************************************************************************
 5108/    1D5A :                        ;
 5109/    1D5A :                        ; perform SAVE
 5110/    1D5A :                        
 5111/    1D5A :                        LAB_SAVE
 5112/    1D5A : 4EEB 041E              	JMP		V_SAVE(a3)				; do save vector
 5113/    1D5E :                        
 5114/    1D5E :                        
 5115/    1D5E :                        ;************************************************************************************
 5116/    1D5E :                        ;
 5117/    1D5E :                        ; perform CALL
 5118/    1D5E :                        
 5119/    1D5E :                        LAB_CALL
 5120/    1D5E : 487A F55E              	PEA		LAB_GBYT(pc)			; put return address on stack
 5121/    1D62 : 6100 FF50              	BSR		LAB_GEAD				; get even address for word/long memory actions
 5122/    1D66 :                        								; address returned in d0 and on the stack
 5123/    1D66 : 4E75                   	RTS							; effectively calls the routine
 5124/    1D68 :                        
 5125/    1D68 :                        ; if the called routine exits correctly then it will return via the get byte routine.
 5126/    1D68 :                        ; this will then get the next byte for the interpreter and return
 5127/    1D68 :                        
 5128/    1D68 :                        
 5129/    1D68 :                        ;************************************************************************************
 5130/    1D68 :                        ;
 5131/    1D68 :                        ; perform WAIT
 5132/    1D68 :                        
 5133/    1D68 :                        LAB_WAIT
 5134/    1D68 : 6100 FF16              	BSR		LAB_GADB				; get two parameters for POKE or WAIT
 5135/    1D6C :                        								; first parameter in a0, second in d0
 5136/    1D6C : 2F08                   	MOVE.l	a0,-(sp)				; save address
 5137/    1D6E : 3F00                   	MOVE.w	d0,-(sp)				; save byte
 5138/    1D70 : 7400                   	MOVEQ		#0,d2					; clear mask
 5139/    1D72 : 6100 F54A              	BSR		LAB_GBYT				; scan memory
 5140/    1D76 : 6706                   	BEQ.s		LAB_2441				; skip if no third argument
 5141/    1D78 :                        
 5142/    1D78 : 6100 F534              	BSR		LAB_SCGB				; scan for "," & get byte,
 5143/    1D7C :                        								; else do syntax error/warm start
 5144/    1D7C : 2400                   	MOVE.l	d0,d2					; copy mask
 5145/    1D7E :                        LAB_2441
 5146/    1D7E : 321F                   	MOVE.w	(sp)+,d1				; get byte
 5147/    1D80 : 205F                   	MOVEA.l	(sp)+,a0				; get address
 5148/    1D82 :                        LAB_2445
 5149/    1D82 : 1010                   	MOVE.b	(a0),d0				; read memory byte
 5150/    1D84 : B500                   	EOR.b		d2,d0					; EOR with second argument (mask)
 5151/    1D86 : C001                   	AND.b		d1,d0					; AND with first argument (byte)
 5152/    1D88 : 67F8                   	BEQ.s		LAB_2445				; loop if result is zero
 5153/    1D8A :                        
 5154/    1D8A : 4E75                   	RTS
 5155/    1D8C :                        
 5156/    1D8C :                        
 5157/    1D8C :                        ;************************************************************************************
 5158/    1D8C :                        ;
 5159/    1D8C :                        ; perform subtraction, FAC1 from FAC2
 5160/    1D8C :                        
 5161/    1D8C :                        LAB_SUBTRACT
 5162/    1D8C : 0A2B 0080 0595         	EORI.b	#$80,FAC1_s(a3)			; complement FAC1 sign
 5163/    1D92 : 176B 059D 059E         	MOVE.b	FAC2_s(a3),FAC_sc(a3)		; copy FAC2 sign byte
 5164/    1D98 :                        
 5165/    1D98 : 102B 0595              	MOVE.b	FAC1_s(a3),d0			; get FAC1 sign byte
 5166/    1D9C : B12B 059E              	EOR.b		d0,FAC_sc(a3)			; EOR with FAC2 sign
 5167/    1DA0 :                        
 5168/    1DA0 :                        
 5169/    1DA0 :                        ;************************************************************************************
 5170/    1DA0 :                        ;
 5171/    1DA0 :                        ; add FAC2 to FAC1
 5172/    1DA0 :                        
 5173/    1DA0 :                        LAB_ADD
 5174/    1DA0 : 102B 0594              	MOVE.b	FAC1_e(a3),d0			; get exponent
 5175/    1DA4 : 6700 0338              	BEQ		LAB_279B				; FAC1 was zero so copy FAC2 to FAC1 & return
 5176/    1DA8 :                        
 5177/    1DA8 :                        								; FAC1 is non zero
 5178/    1DA8 : 41EB 0598              	LEA		FAC2_m(a3),a0			; set pointer1 to FAC2 mantissa
 5179/    1DAC : 102B 059C              	MOVE.b	FAC2_e(a3),d0			; get FAC2 exponent
 5180/    1DB0 : 6746                   	BEQ.s		RTS_016				; exit if zero
 5181/    1DB2 :                        
 5182/    1DB2 : 902B 0594              	SUB.b		FAC1_e(a3),d0			; subtract FAC1 exponent
 5183/    1DB6 : 6722                   	BEQ.s		LAB_24A8				; branch if = (go add mantissa)
 5184/    1DB8 :                        
 5185/    1DB8 : 650A                   	BCS.s		LAB_249C				; branch if FAC2 < FAC1
 5186/    1DBA :                        
 5187/    1DBA :                        								; FAC2 > FAC1
 5188/    1DBA : 376B 059C 0594         	MOVE.w	FAC2_e(a3),FAC1_e(a3)		; copy sign and exponent of FAC2
 5189/    1DC0 : 4400                   	NEG.b		d0					; negate exponent difference (make diff -ve)
 5190/    1DC2 : 5148                   	SUBQ.w	#8,a0					; pointer1 to FAC1
 5191/    1DC4 :                        
 5192/    1DC4 :                        LAB_249C
 5193/    1DC4 : 4400                   	NEG.b		d0					; negate exponent difference (make diff +ve)
 5194/    1DC6 : 2F01                   	MOVE.l	d1,-(sp)				; save d1
 5195/    1DC8 : B03C 0020              	CMP.b		#32,d0				; compare exponent diff with 32
 5196/    1DCC : 6D04                   	BLT.s		LAB_2467				; branch if range >= 32
 5197/    1DCE :                        
 5198/    1DCE : 7200                   	MOVEQ		#0,d1					; clear d1
 5199/    1DD0 : 6004                   	BRA.s		LAB_2468				; go clear smaller mantissa
 5200/    1DD2 :                        
 5201/    1DD2 :                        LAB_2467
 5202/    1DD2 : 2210                   	MOVE.l	(a0),d1				; get FACx mantissa
 5203/    1DD4 : E0A9                   	LSR.l		d0,d1					; shift d0 times right
 5204/    1DD6 :                        LAB_2468
 5205/    1DD6 : 2081                   	MOVE.l	d1,(a0)				; save it back
 5206/    1DD8 : 221F                   	MOVE.l	(sp)+,d1				; restore d1
 5207/    1DDA :                        
 5208/    1DDA :                        								; exponents are equal now do mantissa add or
 5209/    1DDA :                        								; subtract
 5210/    1DDA :                        LAB_24A8
 5211/    1DDA : 4A2B 059E              	TST.b		FAC_sc(a3)				; test sign compare (FAC1 EOR FAC2)
 5212/    1DDE : 6B1A                   	BMI.s		LAB_24F8				; if <> go do subtract
 5213/    1DE0 :                        
 5214/    1DE0 : 202B 0598              	MOVE.l	FAC2_m(a3),d0			; get FAC2 mantissa
 5215/    1DE4 : D0AB 0590              	ADD.l		FAC1_m(a3),d0			; add FAC1 mantissa
 5216/    1DE8 : 640A                   	BCC.s		LAB_24F7				; save and exit if no carry (FAC1 is normal)
 5217/    1DEA :                        
 5218/    1DEA : E290                   	ROXR.l	#1,d0					; else shift carry back into mantissa
 5219/    1DEC : 522B 0594              	ADDQ.b	#1,FAC1_e(a3)			; increment FAC1 exponent
 5220/    1DF0 : 6500 E874              	BCS		LAB_OFER				; if carry do overflow error & warm start
 5221/    1DF4 :                        
 5222/    1DF4 :                        LAB_24F7
 5223/    1DF4 : 2740 0590              	MOVE.l	d0,FAC1_m(a3)			; save mantissa
 5224/    1DF8 :                        RTS_016
 5225/    1DF8 : 4E75                   	RTS
 5226/    1DFA :                        								; signs are different
 5227/    1DFA :                        LAB_24F8
 5228/    1DFA : 43EB 0590              	LEA		FAC1_m(a3),a1			; pointer 2 to FAC1
 5229/    1DFE : B3C8                   	CMPA.l	a0,a1					; compare pointers
 5230/    1E00 : 6602                   	BNE.s		LAB_24B4				; branch if <>
 5231/    1E02 :                        
 5232/    1E02 : 5049                   	ADDQ.w	#8,a1					; else pointer2 to FAC2
 5233/    1E04 :                        
 5234/    1E04 :                        								; take smaller from bigger (take sign of bigger)
 5235/    1E04 :                        LAB_24B4
 5236/    1E04 : 2011                   	MOVE.l	(a1),d0				; get larger mantissa
 5237/    1E06 : 2210                   	MOVE.l	(a0),d1				; get smaller mantissa
 5238/    1E08 : 2740 0590              	MOVE.l	d0,FAC1_m(a3)			; save larger mantissa
 5239/    1E0C : 93AB 0590              	SUB.l		d1,FAC1_m(a3)			; subtract smaller
 5240/    1E10 :                        
 5241/    1E10 :                        
 5242/    1E10 :                        ;************************************************************************************
 5243/    1E10 :                        ;
 5244/    1E10 :                        ; do +/- (carry is sign) & normalise FAC1
 5245/    1E10 :                        
 5246/    1E10 :                        LAB_24D0
 5247/    1E10 : 640A                   	BCC.s		LAB_24D5				; branch if result is +ve
 5248/    1E12 :                        
 5249/    1E12 :                        								; erk! subtract is the wrong way round so
 5250/    1E12 :                        								; negate everything
 5251/    1E12 : 0A2B 00FF 0595         	EORI.b	#$FF,FAC1_s(a3)			; complement FAC1 sign
 5252/    1E18 : 44AB 0590              	NEG.l		FAC1_m(a3)				; negate FAC1 mantissa
 5253/    1E1C :                        
 5254/    1E1C :                        
 5255/    1E1C :                        ;************************************************************************************
 5256/    1E1C :                        ;
 5257/    1E1C :                        ; normalise FAC1
 5258/    1E1C :                        
 5259/    1E1C :                        LAB_24D5
 5260/    1E1C : 202B 0590              	MOVE.l	FAC1_m(a3),d0			; get mantissa
 5261/    1E20 : 6B2E                   	BMI.s		LAB_24DA				; mantissa is normal so just exit
 5262/    1E22 :                        
 5263/    1E22 : 6606                   	BNE.s		LAB_24D9				; mantissa is not zero so go normalise FAC1
 5264/    1E24 :                        
 5265/    1E24 : 3740 0594              	MOVE.w	d0,FAC1_e(a3)			; else make FAC1 = +zero
 5266/    1E28 : 4E75                   	RTS
 5267/    1E2A :                        
 5268/    1E2A :                        LAB_24D9
 5269/    1E2A : 2F01                   	MOVE.l	d1,-(sp)				; save d1
 5270/    1E2C : 2200                   	MOVE.l	d0,d1					; mantissa to d1
 5271/    1E2E : 7000                   	MOVEQ		#0,d0					; clear d0
 5272/    1E30 : 102B 0594              	MOVE.b	FAC1_e(a3),d0			; get exponent byte
 5273/    1E34 : 6714                   	BEQ.s		LAB_24D8				; if exponent is zero then clean up and exit
 5274/    1E36 :                        LAB_24D6
 5275/    1E36 : D281                   	ADD.l		d1,d1					; shift mantissa, ADD is quicker for a single
 5276/    1E38 :                        								; shift
 5277/    1E38 : 5BC8 FFFC              	DBMI		d0,LAB_24D6				; decrement exponent and loop if mantissa and
 5278/    1E3C :                        								; exponent +ve
 5279/    1E3C :                        
 5280/    1E3C : 4A40                   	TST.w		d0					; test exponent
 5281/    1E3E : 670A                   	BEQ.s		LAB_24D8				; if exponent is zero make FAC1 zero
 5282/    1E40 :                        
 5283/    1E40 : 6A02                   	BPL.s		LAB_24D7				; if exponent is >zero go save FAC1
 5284/    1E42 :                        
 5285/    1E42 : 7001                   	MOVEQ		#1,d0					; else set for zero after correction
 5286/    1E44 :                        LAB_24D7
 5287/    1E44 : 5300                   	SUBQ.b	#1,d0					; adjust exponent for loop
 5288/    1E46 : 2741 0590              	MOVE.l	d1,FAC1_m(a3)			; save normalised mantissa
 5289/    1E4A :                        LAB_24D8
 5290/    1E4A : 221F                   	MOVE.l	(sp)+,d1				; restore d1
 5291/    1E4C : 1740 0594              	MOVE.b	d0,FAC1_e(a3)			; save corrected exponent
 5292/    1E50 :                        LAB_24DA
 5293/    1E50 : 4E75                   	RTS
 5294/    1E52 :                        
 5295/    1E52 :                        
 5296/    1E52 :                        ;************************************************************************************
 5297/    1E52 :                        ;
 5298/    1E52 :                        ; perform LOG()
 5299/    1E52 :                        
 5300/    1E52 :                        LAB_LOG
 5301/    1E52 : 4A2B 0595              	TST.b		FAC1_s(a3)				; test sign
 5302/    1E56 : 6B00 E812              	BMI		LAB_FCER				; if -ve do function call error/warm start
 5303/    1E5A :                        
 5304/    1E5A : 7E00                   	MOVEQ		#0,d7					; clear d7
 5305/    1E5C : 1747 059E              	MOVE.b	d7,FAC_sc(a3)			; clear sign compare
 5306/    1E60 : 1E2B 0594              	MOVE.b	FAC1_e(a3),d7			; get exponent
 5307/    1E64 : 6700 E804              	BEQ		LAB_FCER				; if 0 do function call error/warm start
 5308/    1E68 :                        
 5309/    1E68 : 9EBC 0000 0081         	SUB.l		#$81,d7				; normalise exponent
 5310/    1E6E : 177C 0081 0594         	MOVE.b	#$81,FAC1_e(a3)			; force a value between 1 and 2
 5311/    1E74 : 2C2B 0590              	MOVE.l	FAC1_m(a3),d6			; copy mantissa
 5312/    1E78 :                        
 5313/    1E78 : 277C 8000 0000 0598    	MOVE.l	#$80000000,FAC2_m(a3)		; set mantissa for 1
 5314/    1E80 : 377C 8100 059C         	MOVE.w	#$8100,FAC2_e(a3)			; set exponent for 1
 5315/    1E86 : 6100 FF18              	BSR		LAB_ADD				; find arg+1
 5316/    1E8A : 7000                   	MOVEQ		#0,d0					; setup for calc skip
 5317/    1E8C : 3740 059C              	MOVE.w	d0,FAC2_e(a3)			; set FAC1 for zero result
 5318/    1E90 : DC86                   	ADD.l		d6,d6					; shift 1 bit out
 5319/    1E92 : 2746 0598              	MOVE.l	d6,FAC2_m(a3)			; put back FAC2
 5320/    1E96 : 6758                   	BEQ.s		LAB_LONN				; if 0 skip calculation
 5321/    1E98 :                        
 5322/    1E98 : 377C 8000 059C         	MOVE.w	#$8000,FAC2_e(a3)			; set exponent for .5
 5323/    1E9E : 6100 0130              	BSR		LAB_DIVIDE				; do (arg-1)/(arg+1)
 5324/    1EA2 : 4A2B 0594              	TST.b		FAC1_e(a3)				; test exponent
 5325/    1EA6 : 6748                   	BEQ.s		LAB_LONN				; if 0 skip calculation
 5326/    1EA8 :                        
 5327/    1EA8 : 122B 0594              	MOVE.b	FAC1_e(a3),d1			; get exponent
 5328/    1EAC : 923C 0082              	SUB.b		#$82,d1				; normalise and two integer bits
 5329/    1EB0 : 4401                   	NEG.b		d1					; negate for shift
 5330/    1EB2 :                        ;	CMP.b		#$1F,d1				; will mantissa vanish?
 5331/    1EB2 :                        ;	BGT.s		LAB_dunno				; if so do ???
 5332/    1EB2 :                        
 5333/    1EB2 : 202B 0590              	MOVE.l	FAC1_m(a3),d0			; get mantissa
 5334/    1EB6 : E2A8                   	LSR.l		d1,d0					; shift in two integer bits
 5335/    1EB8 :                        
 5336/    1EB8 :                        ; d0 = arg
 5337/    1EB8 :                        ; d0 = x, d1 = y
 5338/    1EB8 :                        ; d2 = x1, d3 = y1
 5339/    1EB8 :                        ; d4 = shift count
 5340/    1EB8 :                        ; d5 = loop count
 5341/    1EB8 :                        ; d6 = z
 5342/    1EB8 :                        ; a0 = table pointer
 5343/    1EB8 :                        
 5344/    1EB8 : 7C00                   	MOVEQ		#0,d6					; z = 0
 5345/    1EBA : 223C 4000 0000         	MOVE.l	#1<<30,d1				; y = 1
 5346/    1EC0 : 41FA 1408              	LEA		TAB_HTHET(pc),a0			; get pointer to hyperbolic tangent table
 5347/    1EC4 : 7A1E                   	MOVEQ		#30,d5				; loop 31 times
 5348/    1EC6 : 7801                   	MOVEQ		#1,d4					; set shift count
 5349/    1EC8 : 6006                   	BRA.s		LAB_LOCC				; entry point for loop
 5350/    1ECA :                        
 5351/    1ECA :                        LAB_LAAD
 5352/    1ECA : E8A2                   	ASR.l		d4,d2					; x1 >> i
 5353/    1ECC : 9282                   	SUB.l		d2,d1					; y = y - x1
 5354/    1ECE : DC90                   	ADD.l		(a0),d6				; z = z + tanh(i)
 5355/    1ED0 :                        LAB_LOCC
 5356/    1ED0 : 2400                   	MOVE.l	d0,d2					; x1 = x
 5357/    1ED2 : 2601                   	MOVE.l	d1,d3					; y1 = Y
 5358/    1ED4 : E8A3                   	ASR.l		d4,d3					; y1 >> i
 5359/    1ED6 : 6402                   	BCC.s		LAB_LOLP
 5360/    1ED8 :                        
 5361/    1ED8 : 5283                   	ADDQ.l	#1,d3
 5362/    1EDA :                        LAB_LOLP
 5363/    1EDA : 9083                   	SUB.l		d3,d0					; x = x - y1
 5364/    1EDC : 6AEC                   	BPL.s		LAB_LAAD				; branch if > 0
 5365/    1EDE :                        
 5366/    1EDE : 2002                   	MOVE.l	d2,d0					; get x back
 5367/    1EE0 : 5848                   	ADDQ.w	#4,a0					; next entry
 5368/    1EE2 : 5284                   	ADDQ.l	#1,d4					; next i
 5369/    1EE4 : E28B                   	LSR.l		#1,d3					; /2
 5370/    1EE6 : 6704                   	BEQ.s		LAB_LOCX				; branch y1 = 0
 5371/    1EE8 :                        
 5372/    1EE8 : 51CD FFF0              	DBF		d5,LAB_LOLP				; decrement and loop if not done
 5373/    1EEC :                        
 5374/    1EEC :                        								; now sort out the result
 5375/    1EEC :                        LAB_LOCX
 5376/    1EEC : DC86                   	ADD.l		d6,d6					; *2
 5377/    1EEE : 2006                   	MOVE.l	d6,d0					; setup for d7 = 0
 5378/    1EF0 :                        LAB_LONN
 5379/    1EF0 : 2800                   	MOVE.l	d0,d4					; save cordic result
 5380/    1EF2 : 7A00                   	MOVEQ		#0,d5					; set default exponent sign
 5381/    1EF4 : 4A87                   	TST.l		d7					; check original exponent sign
 5382/    1EF6 : 6716                   	BEQ.s		LAB_LOXO				; branch if original was 0
 5383/    1EF8 :                        
 5384/    1EF8 : 6A04                   	BPL.s		LAB_LOXP				; branch if was +ve
 5385/    1EFA :                        
 5386/    1EFA : 4487                   	NEG.l		d7					; make original exponent +ve
 5387/    1EFC : 7A80                   	MOVEQ		#$80-$100,d5			; make sign -ve
 5388/    1EFE :                        LAB_LOXP
 5389/    1EFE : 1745 0595              	MOVE.b	d5,FAC1_s(a3)			; save original exponent sign
 5390/    1F02 : 4847                   	SWAP		d7					; 16 bit shift
 5391/    1F04 : E18F                   	LSL.l		#8,d7					; easy first part
 5392/    1F06 : 7A88                   	MOVEQ		#$88-$100,d5			; start with byte
 5393/    1F08 :                        LAB_LONE
 5394/    1F08 : 5385                   	SUBQ.l	#1,d5					; decrement exponent
 5395/    1F0A : DE87                   	ADD.l		d7,d7					; shift mantissa
 5396/    1F0C : 6AFA                   	BPL.s		LAB_LONE				; loop if not normal
 5397/    1F0E :                        
 5398/    1F0E :                        LAB_LOXO
 5399/    1F0E : 2747 0590              	MOVE.l	d7,FAC1_m(a3)			; save original exponent as mantissa
 5400/    1F12 : 1745 0594              	MOVE.b	d5,FAC1_e(a3)			; save exponent for this
 5401/    1F16 : 277C B172 17F8 0598    	MOVE.l	#$B17217F8,FAC2_m(a3)		; LOG(2) mantissa
 5402/    1F1E : 377C 8000 059C         	MOVE.w	#$8000,FAC2_e(a3)			; LOG(2) exponent & sign
 5403/    1F24 : 176B 0595 059E         	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; make sign compare = FAC1 sign
 5404/    1F2A : 6118                   	BSR.s		LAB_MULTIPLY			; do multiply
 5405/    1F2C : 2744 0598              	MOVE.l	d4,FAC2_m(a3)			; save cordic result
 5406/    1F30 : 6710                   	BEQ.s		LAB_LOWZ				; branch if zero
 5407/    1F32 :                        
 5408/    1F32 : 377C 8200 059C         	MOVE.w	#$8200,FAC2_e(a3)			; set exponent & sign
 5409/    1F38 : 176B 0595 059E         	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; clear sign compare
 5410/    1F3E : 6100 FE60              	BSR		LAB_ADD				; and add for final result
 5411/    1F42 :                        
 5412/    1F42 :                        LAB_LOWZ
 5413/    1F42 : 4E75                   	RTS
 5414/    1F44 :                        
 5415/    1F44 :                        
 5416/    1F44 :                        ;************************************************************************************
 5417/    1F44 :                        ;
 5418/    1F44 :                        ; multiply FAC1 by FAC2
 5419/    1F44 :                        
 5420/    1F44 :                        LAB_MULTIPLY
 5421/    1F44 : 48E7 F800              	MOVEM.l	d0-d4,-(sp)				; save registers
 5422/    1F48 : 4A2B 0594              	TST.b		FAC1_e(a3)				; test FAC1 exponent
 5423/    1F4C : 6776                   	BEQ.s		LAB_MUUF				; if exponent zero go make result zero
 5424/    1F4E :                        
 5425/    1F4E : 102B 059C              	MOVE.b	FAC2_e(a3),d0			; get FAC2 exponent
 5426/    1F52 : 6770                   	BEQ.s		LAB_MUUF				; if exponent zero go make result zero
 5427/    1F54 :                        
 5428/    1F54 : 176B 059E 0595         	MOVE.b	FAC_sc(a3),FAC1_s(a3)		; sign compare becomes sign
 5429/    1F5A :                        
 5430/    1F5A : D02B 0594              	ADD.b		FAC1_e(a3),d0			; multiply exponents by adding
 5431/    1F5E : 640A                   	BCC.s		LAB_MNOC				; branch if no carry
 5432/    1F60 :                        
 5433/    1F60 : 903C 0080              	SUB.b		#$80,d0				; normalise result
 5434/    1F64 : 6400 E700              	BCC		LAB_OFER				; if no carry do overflow
 5435/    1F68 :                        
 5436/    1F68 : 6006                   	BRA.s		LAB_MADD				; branch
 5437/    1F6A :                        
 5438/    1F6A :                        								; no carry for exponent add
 5439/    1F6A :                        LAB_MNOC
 5440/    1F6A : 903C 0080              	SUB.b		#$80,d0				; normalise result
 5441/    1F6E : 6554                   	BCS.s		LAB_MUUF				; return zero if underflow
 5442/    1F70 :                        
 5443/    1F70 :                        LAB_MADD
 5444/    1F70 : 1740 0594              	MOVE.b	d0,FAC1_e(a3)			; save exponent
 5445/    1F74 :                        
 5446/    1F74 :                        								; d1 (FAC1) x d2 (FAC2)
 5447/    1F74 : 222B 0590              	MOVE.l	FAC1_m(a3),d1			; get FAC1 mantissa
 5448/    1F78 : 242B 0598              	MOVE.l	FAC2_m(a3),d2			; get FAC2 mantissa
 5449/    1F7C :                        
 5450/    1F7C : 3801                   	MOVE.w	d1,d4					; copy low word FAC1
 5451/    1F7E : 2001                   	MOVE.l	d1,d0					; copy long word FAC1
 5452/    1F80 : 4840                   	SWAP		d0					; high word FAC1 to low word FAC1
 5453/    1F82 : 3600                   	MOVE.w	d0,d3					; copy high word FAC1
 5454/    1F84 :                        
 5455/    1F84 : C2C2                   	MULU		d2,d1					; low word FAC2 x low word FAC1
 5456/    1F86 : C0C2                   	MULU		d2,d0					; low word FAC2 x high word FAC1
 5457/    1F88 : 4842                   	SWAP		d2					; high word FAC2 to low word FAC2
 5458/    1F8A : C8C2                   	MULU		d2,d4					; high word FAC2 x low word FAC1
 5459/    1F8C : C6C2                   	MULU		d2,d3					; high word FAC2 x high word FAC1
 5460/    1F8E :                        
 5461/    1F8E :                        ; done multiply, now add partial products
 5462/    1F8E :                        
 5463/    1F8E :                        ;			d1 =					aaaa  ----	FAC2_L x FAC1_L
 5464/    1F8E :                        ;			d0 =				bbbb  aaaa		FAC2_L x FAC1_H
 5465/    1F8E :                        ;			d4 =				bbbb  aaaa		FAC2_H x FAC1_L
 5466/    1F8E :                        ;			d3 =			cccc  bbbb			FAC2_H x FAC1_H
 5467/    1F8E :                        ;			product =		mmmm  mmmm
 5468/    1F8E :                        
 5469/    1F8E : D2BC 0000 8000         	ADD.L		#$8000,d1				; round up lowest word
 5470/    1F94 : 4241                   	CLR.w		d1					; clear low word, don't need it
 5471/    1F96 : 4841                   	SWAP		d1					; align high word
 5472/    1F98 : D280                   	ADD.l		d0,d1					; add FAC2_L x FAC1_H (can't be carry)
 5473/    1F9A :                        LAB_MUF1
 5474/    1F9A : D284                   	ADD.l		d4,d1					; now add intermediate (FAC2_H x FAC1_L)
 5475/    1F9C : 6406                   	BCC.s		LAB_MUF2				; branch if no carry
 5476/    1F9E :                        
 5477/    1F9E : D6BC 0001 0000         	ADD.l		#$10000,d3				; else correct result
 5478/    1FA4 :                        LAB_MUF2
 5479/    1FA4 : D2BC 0000 8000         	ADD.l		#$8000,d1				; round up low word
 5480/    1FAA : 4241                   	CLR.w		d1					; clear low word
 5481/    1FAC : 4841                   	SWAP		d1					; align for final add
 5482/    1FAE : D283                   	ADD.l		d3,d1					; add FAC2_H x FAC1_H, result
 5483/    1FB0 : 6B08                   	BMI.s		LAB_MUF3				; branch if normalisation not needed
 5484/    1FB2 :                        
 5485/    1FB2 : D281                   	ADD.l		d1,d1					; shift mantissa
 5486/    1FB4 : 532B 0594              	SUBQ.b	#1,FAC1_e(a3)			; adjust exponent
 5487/    1FB8 : 670A                   	BEQ.s		LAB_MUUF				; branch if underflow
 5488/    1FBA :                        
 5489/    1FBA :                        LAB_MUF3
 5490/    1FBA : 2741 0590              	MOVE.l	d1,FAC1_m(a3)			; save mantissa
 5491/    1FBE :                        LAB_MUEX
 5492/    1FBE : 4CDF 001F              	MOVEM.l	(sp)+,d0-d4				; restore registers
 5493/    1FC2 : 4E75                   	RTS
 5494/    1FC4 :                        								; either zero or underflow result
 5495/    1FC4 :                        LAB_MUUF
 5496/    1FC4 : 7000                   	MOVEQ		#0,d0					; quick clear
 5497/    1FC6 : 2740 0590              	MOVE.l	d0,FAC1_m(a3)			; clear mantissa
 5498/    1FCA : 3740 0594              	MOVE.w	d0,FAC1_e(a3)			; clear sign and exponent
 5499/    1FCE : 60EE                   	BRA.s		LAB_MUEX				; restore regs & exit
 5500/    1FD0 :                        
 5501/    1FD0 :                        
 5502/    1FD0 :                        ;************************************************************************************
 5503/    1FD0 :                        ;
 5504/    1FD0 :                        ; do FAC2/FAC1, result in FAC1
 5505/    1FD0 :                        ; fast hardware divide version
 5506/    1FD0 :                        
 5507/    1FD0 :                        LAB_DIVIDE
 5508/    1FD0 : 2F07                   	MOVE.l	d7,-(sp)				; save d7
 5509/    1FD2 : 7000                   	MOVEQ		#0,d0					; clear FAC2 exponent
 5510/    1FD4 : 2400                   	MOVE.l	d0,d2					; clear FAC1 exponent
 5511/    1FD6 :                        
 5512/    1FD6 : 142B 0594              	MOVE.b	FAC1_e(a3),d2			; get FAC1 exponent
 5513/    1FDA : 6700 E676              	BEQ		LAB_DZER				; if zero go do /0 error
 5514/    1FDE :                        
 5515/    1FDE : 102B 059C              	MOVE.b	FAC2_e(a3),d0			; get FAC2 exponent
 5516/    1FE2 : 6766                   	BEQ.s		LAB_DIV0				; if zero return zero
 5517/    1FE4 :                        
 5518/    1FE4 : 9042                   	SUB.w		d2,d0					; get result exponent by subtracting
 5519/    1FE6 : D07C 0080              	ADD.w		#$80,d0				; correct 16 bit exponent result
 5520/    1FEA :                        
 5521/    1FEA : 176B 059E 0595         	MOVE.b	FAC_sc(a3),FAC1_s(a3)		; sign compare is result sign
 5522/    1FF0 :                        
 5523/    1FF0 :                        ; now to do 32/32 bit mantissa divide
 5524/    1FF0 :                        
 5525/    1FF0 : 422B 059F              	CLR.b		flag(a3)				; clear 'flag' byte
 5526/    1FF4 : 262B 0590              	MOVE.l	FAC1_m(a3),d3			; get FAC1 mantissa
 5527/    1FF8 : 282B 0598              	MOVE.l	FAC2_m(a3),d4			; get FAC2 mantissa
 5528/    1FFC : B883                   	CMP.l		d3,d4					; compare FAC2 with FAC1 mantissa
 5529/    1FFE : 6744                   	BEQ.s		LAB_MAN1				; set mantissa result = 1 if equal
 5530/    2000 :                        
 5531/    2000 : 6506                   	BCS.s		AC1gtAC2				; branch if FAC1 > FAC2
 5532/    2002 :                        
 5533/    2002 : 9883                   	SUB.l		d3,d4					; subtract FAC1 from FAC2, result now must be <1
 5534/    2004 : 562B 059F              	ADDQ.b	#3,flag(a3)				; FAC2>FAC1 so set 'flag' byte
 5535/    2008 :                        AC1gtAC2
 5536/    2008 : 6146                   	BSR.s		LAB_32_16				; do 32/16 divide
 5537/    200A : 4841                   	SWAP		d1					; move 16 bit result to high word
 5538/    200C : 2802                   	MOVE.l	d2,d4					; copy remainder longword
 5539/    200E : 6142                   	BSR.s		LAB_3216				; do 32/16 divide again (skip copy d4 to d2)
 5540/    2010 : 84C5                   	DIVU.w	d5,d2					; now divide remainder to make guard word
 5541/    2012 : 1E2B 059F              	MOVE.b	flag(a3),d7				; now normalise, get flag byte back
 5542/    2016 : 6708                   	BEQ.s		LAB_DIVX				; skip add if null
 5543/    2018 :                        
 5544/    2018 :                        ; else result was >1 so we need to add 1 to result mantissa and adjust exponent
 5545/    2018 :                        
 5546/    2018 : E20F                   	LSR.b		#1,d7					; shift 1 into eXtend
 5547/    201A : E291                   	ROXR.l	#1,d1					; shift extend result >>
 5548/    201C : E252                   	ROXR.w	#1,d2					; shift extend guard word >>
 5549/    201E : 5200                   	ADDQ.b	#1,d0					; adjust exponent
 5550/    2020 :                        
 5551/    2020 :                        ; now round result to 32 bits
 5552/    2020 :                        
 5553/    2020 :                        LAB_DIVX
 5554/    2020 : D442                   	ADD.w		d2,d2					; guard bit into eXtend bit
 5555/    2022 : 6408                   	BCC.s		L_DIVRND				; branch if guard=0
 5556/    2024 :                        
 5557/    2024 : 5281                   	ADDQ.l	#1,d1					; add guard to mantissa
 5558/    2026 : 6404                   	BCC.s		L_DIVRND				; branch if no overflow
 5559/    2028 :                        
 5560/    2028 :                        LAB_SET1
 5561/    2028 : E291                   	ROXR.l	#1,d1					; shift extend result >>
 5562/    202A : 5240                   	ADDQ.w	#1,d0					; adjust exponent
 5563/    202C :                        
 5564/    202C :                        								; test for over/under flow
 5565/    202C :                        L_DIVRND
 5566/    202C : 3600                   	MOVE.w	d0,d3					; copy exponent
 5567/    202E : 6B1A                   	BMI.s		LAB_DIV0				; if -ve return zero
 5568/    2030 :                        
 5569/    2030 : 0243 FF00              	ANDI.w	#$FF00,d3				; mask word high byte
 5570/    2034 : 6600 E630              	BNE		LAB_OFER				; branch if overflow
 5571/    2038 :                        
 5572/    2038 :                        								; move result into FAC1
 5573/    2038 :                        LAB_XDIV
 5574/    2038 : 2E1F                   	MOVE.l	(sp)+,d7				; restore d7
 5575/    203A : 1740 0594              	MOVE.b	d0,FAC1_e(a3)			; save result exponent
 5576/    203E : 2741 0590              	MOVE.l	d1,FAC1_m(a3)			; save result mantissa
 5577/    2042 : 4E75                   	RTS
 5578/    2044 :                        
 5579/    2044 :                        ; FAC1 mantissa = FAC2 mantissa so set result mantissa
 5580/    2044 :                        
 5581/    2044 :                        LAB_MAN1
 5582/    2044 : 7201                   	MOVEQ		#1,d1					; set bit
 5583/    2046 : E2A9                   	LSR.l		d1,d1					; bit into eXtend
 5584/    2048 : 60DE                   	BRA.s		LAB_SET1				; set mantissa, adjust exponent and exit
 5585/    204A :                        
 5586/    204A :                        ; result is zero
 5587/    204A :                        
 5588/    204A :                        LAB_DIV0
 5589/    204A : 7000                   	MOVEQ		#0,d0					; zero exponent & sign
 5590/    204C : 2200                   	MOVE.l	d0,d1					; zero mantissa
 5591/    204E : 60E8                   	BRA		LAB_XDIV				; exit divide
 5592/    2050 :                        
 5593/    2050 :                        ; divide 16 bits into 32, AB/Ex
 5594/    2050 :                        ;
 5595/    2050 :                        ; d4			AAAA	BBBB				; 32 bit numerator
 5596/    2050 :                        ; d3			EEEE	xxxx				; 16 bit denominator
 5597/    2050 :                        ;
 5598/    2050 :                        ; returns -
 5599/    2050 :                        ;
 5600/    2050 :                        ; d1			xxxx	DDDD				; 16 bit result
 5601/    2050 :                        ; d2				HHHH	IIII			; 32 bit remainder
 5602/    2050 :                        
 5603/    2050 :                        LAB_32_16
 5604/    2050 : 2404                   	MOVE.l	d4,d2					; copy FAC2 mantissa		(AB)
 5605/    2052 :                        LAB_3216
 5606/    2052 : 2A03                   	MOVE.l	d3,d5					; copy FAC1 mantissa		(EF)
 5607/    2054 : 4245                   	CLR.w		d5					; clear low word d1		(Ex)
 5608/    2056 : 4845                   	SWAP		d5					; swap high word to low word	(xE)
 5609/    2058 :                        
 5610/    2058 :                        ; d3			EEEE	FFFF				; denominator copy
 5611/    2058 :                        ; d5		0000	EEEE					; denominator high word
 5612/    2058 :                        ; d2			AAAA	BBBB				; numerator copy
 5613/    2058 :                        ; d4			AAAA	BBBB				; numerator
 5614/    2058 :                        
 5615/    2058 : 88C5                   	DIVU.w	d5,d4					; do FAC2/FAC1 high word	(AB/E)
 5616/    205A : 6802                   	BVC.s		LAB_LT_1				; if no overflow DIV was ok
 5617/    205C :                        
 5618/    205C : 78FF                   	MOVEQ		#-1,d4				; else set default value
 5619/    205E :                        
 5620/    205E :                        ; done the divide, now check the result, we have ...
 5621/    205E :                        
 5622/    205E :                        ; d3			EEEE	FFFF				; denominator copy
 5623/    205E :                        ; d5		0000	EEEE					; denominator high word
 5624/    205E :                        ; d2			AAAA	BBBB				; numerator copy
 5625/    205E :                        ; d4			MMMM	DDDD				; result MOD and DIV
 5626/    205E :                        
 5627/    205E :                        LAB_LT_1
 5628/    205E : 3C04                   	MOVE.w	d4,d6					; copy 16 bit result
 5629/    2060 : 3204                   	MOVE.w	d4,d1					; copy 16 bit result again
 5630/    2062 :                        
 5631/    2062 :                        ; we now have ..
 5632/    2062 :                        ; d3			EEEE	FFFF				; denominator copy
 5633/    2062 :                        ; d5		0000	EEEE					; denominator high word
 5634/    2062 :                        ; d6			xxxx  DDDD				; result DIV copy
 5635/    2062 :                        ; d1			xxxx  DDDD				; result DIV copy
 5636/    2062 :                        ; d2			AAAA	BBBB				; numerator copy
 5637/    2062 :                        ; d4			MMMM	DDDD				; result MOD and DIV
 5638/    2062 :                        
 5639/    2062 :                        ; now multiply out 32 bit denominator by 16 bit result
 5640/    2062 :                        ; QRS = AB*D
 5641/    2062 :                        
 5642/    2062 : CCC3                   	MULU.w	d3,d6					; FFFF	; DDDD =       rrrr  SSSS
 5643/    2064 : C8C5                   	MULU.w	d5,d4					; EEEE	; DDDD = QQQQ  rrrr
 5644/    2066 :                        
 5645/    2066 :                        ; we now have ..
 5646/    2066 :                        ; d3			EEEE	FFFF				; denominator copy
 5647/    2066 :                        ; d5		0000	EEEE					; denominator high word
 5648/    2066 :                        ; d6				rrrr  SSSS			; 48 bit result partial low
 5649/    2066 :                        ; d1			xxxx  DDDD				; result DIV copy
 5650/    2066 :                        ; d2			AAAA	BBBB				; numerator copy
 5651/    2066 :                        ; d4			QQQQ	rrrr				; 48 bit result partial
 5652/    2066 :                        
 5653/    2066 : 3E06                   	MOVE.w	d6,d7					; copy low word of low multiply
 5654/    2068 :                        
 5655/    2068 :                        ; d7				xxxx	SSSS			; 48 bit result partial low
 5656/    2068 :                        
 5657/    2068 : 4246                   	CLR.w		d6					; clear low word of low multiply
 5658/    206A : 4846                   	SWAP		d6					; high word of low multiply to low word
 5659/    206C :                        
 5660/    206C :                        ; d6			0000	rrrr				; high word of 48 bit result partial low
 5661/    206C :                        
 5662/    206C : D886                   	ADD.l		d6,d4
 5663/    206E :                        
 5664/    206E :                        ; d4			QQQQ	RRRR				; 48 bit result partial high longword
 5665/    206E :                        
 5666/    206E : 7C00                   	MOVEQ		#0,d6					; clear to extend numerator to 48 bits
 5667/    2070 :                        
 5668/    2070 :                        ; now do GHI = AB0 - QRS (which is the remainder)
 5669/    2070 :                        
 5670/    2070 : 9C47                   	SUB.w		d7,d6					; low word subtract
 5671/    2072 :                        
 5672/    2072 :                        ; d6				xxxx	IIII			; remainder low word
 5673/    2072 :                        
 5674/    2072 : 9584                   	SUBX.l	d4,d2					; high longword subtract
 5675/    2074 :                        
 5676/    2074 :                        ; d2			GGGG	HHHH				; remainder high longword
 5677/    2074 :                        
 5678/    2074 :                        ; now if we got the divide correct then the remainder high longword will be +ve
 5679/    2074 :                        
 5680/    2074 : 6A08                   	BPL.s		L_DDIV				; branch if result is ok (<needed)
 5681/    2076 :                        
 5682/    2076 :                        ; remainder was -ve so DDDD is too big
 5683/    2076 :                        
 5684/    2076 :                        LAB_REMM
 5685/    2076 : 5341                   	SUBQ.w	#1,d1					; adjust DDDD
 5686/    2078 :                        
 5687/    2078 :                        ; d3				xxxx	FFFF			; denominator copy
 5688/    2078 :                        ; d6				xxxx	IIII			; remainder low word
 5689/    2078 :                        
 5690/    2078 : DC43                   	ADD.w		d3,d6					; add EF*1 low remainder low word
 5691/    207A :                        
 5692/    207A :                        ; d5			0000	EEEE				; denominator high word
 5693/    207A :                        ; d2			GGGG	HHHH				; remainder high longword
 5694/    207A :                        
 5695/    207A : D585                   	ADDX.l	d5,d2					; add extend EF*1 to remainder high longword
 5696/    207C : 6BF8                   	BMI.s		LAB_REMM				; loop if result still too big
 5697/    207E :                        
 5698/    207E :                        ; all done and result correct or <
 5699/    207E :                        
 5700/    207E :                        L_DDIV
 5701/    207E : 4842                   	SWAP		d2					; remainder mid word to high word
 5702/    2080 :                        
 5703/    2080 :                        ; d2			HHHH	GGGG				; (high word /should/ be $0000)
 5704/    2080 :                        
 5705/    2080 : 3406                   	MOVE.w	d6,d2					; remainder in high word
 5706/    2082 :                        
 5707/    2082 :                        ; d2				HHHH	IIII			; now is 32 bit remainder
 5708/    2082 :                        ; d1			xxxx	DDDD				; 16 bit result
 5709/    2082 :                        
 5710/    2082 : 4E75                   	RTS
 5711/    2084 :                        
 5712/    2084 :                        
 5713/    2084 :                        ;************************************************************************************
 5714/    2084 :                        ;
 5715/    2084 :                        ; unpack memory (a0) into FAC1
 5716/    2084 :                        
 5717/    2084 :                        LAB_UFAC
 5718/    2084 : 2010                   	MOVE.l	(a0),d0				; get packed value
 5719/    2086 : 4840                   	SWAP		d0					; exponent and sign into least significant word
 5720/    2088 : 3740 0594              	MOVE.w	d0,FAC1_e(a3)			; save exponent and sign
 5721/    208C : 6708                   	BEQ.s		LAB_NB1T				; branch if exponent (and the rest) zero
 5722/    208E :                        
 5723/    208E : 807C 0080              	OR.w		#$80,d0				; set MSb
 5724/    2092 : 4840                   	SWAP		d0					; word order back to normal
 5725/    2094 : E180                   	ASL.l		#8,d0					; shift exponent & clear guard byte
 5726/    2096 :                        LAB_NB1T
 5727/    2096 : 2740 0590              	MOVE.l	d0,FAC1_m(a3)			; move into FAC1
 5728/    209A :                        
 5729/    209A : 102B 0594              	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
 5730/    209E : 4E75                   	RTS
 5731/    20A0 :                        
 5732/    20A0 :                        
 5733/    20A0 :                        ;************************************************************************************
 5734/    20A0 :                        ;
 5735/    20A0 :                        ; set numeric variable, pack FAC1 into Lvarpl
 5736/    20A0 :                        
 5737/    20A0 :                        LAB_PFAC
 5738/    20A0 : 2F08                   	MOVE.l	a0,-(sp)				; save pointer
 5739/    20A2 : 206B 0472              	MOVEA.l	Lvarpl(a3),a0			; get destination pointer
 5740/    20A6 : 082B 0006 05B5         	BTST		#6,Dtypef(a3)			; test data type
 5741/    20AC : 670C                   	BEQ.s		LAB_277C				; branch if floating
 5742/    20AE :                        
 5743/    20AE : 6100 00C6              	BSR		LAB_2831				; convert FAC1 floating to fixed
 5744/    20B2 :                        								; result in d0 and Itemp
 5745/    20B2 : 2080                   	MOVE.l	d0,(a0)				; save in var
 5746/    20B4 : 205F                   	MOVE.l	(sp)+,a0				; restore pointer
 5747/    20B6 : 4E75                   	RTS
 5748/    20B8 :                        
 5749/    20B8 :                        
 5750/    20B8 :                        ;************************************************************************************
 5751/    20B8 :                        ;
 5752/    20B8 :                        ; normalise round and pack FAC1 into (a0)
 5753/    20B8 :                        
 5754/    20B8 :                        LAB_2778
 5755/    20B8 : 2F08                   	MOVE.l	a0,-(sp)				; save pointer
 5756/    20BA :                        LAB_277C
 5757/    20BA : 6100 FD60              	BSR		LAB_24D5				; normalise FAC1
 5758/    20BE : 612C                   	BSR.s		LAB_27BA				; round FAC1
 5759/    20C0 : 202B 0590              	MOVE.l	FAC1_m(a3),d0			; get FAC1 mantissa
 5760/    20C4 : E098                   	ROR.l		#8,d0					; align 24/32 bit mantissa
 5761/    20C6 : 4840                   	SWAP		d0					; exponent/sign into 0-15
 5762/    20C8 : C07C 007F              	AND.w		#$7F,d0				; clear exponent and sign bit
 5763/    20CC : 022B 0080 0595         	ANDI.b	#$80,FAC1_s(a3)			; clear non sign bits in sign
 5764/    20D2 : 806B 0594              	OR.w		FAC1_e(a3),d0			; OR in exponent and sign
 5765/    20D6 : 4840                   	SWAP		d0					; move exponent and sign back to 16-31
 5766/    20D8 : 2080                   	MOVE.l	d0,(a0)				; store in destination
 5767/    20DA : 205F                   	MOVE.l	(sp)+,a0				; restore pointer
 5768/    20DC : 4E75                   	RTS
 5769/    20DE :                        
 5770/    20DE :                        
 5771/    20DE :                        ;************************************************************************************
 5772/    20DE :                        ;
 5773/    20DE :                        ; copy FAC2 to FAC1
 5774/    20DE :                        
 5775/    20DE :                        LAB_279B
 5776/    20DE : 376B 059C 0594         	MOVE.w	FAC2_e(a3),FAC1_e(a3)		; copy exponent & sign
 5777/    20E4 : 276B 0598 0590         	MOVE.l	FAC2_m(a3),FAC1_m(a3)		; copy mantissa
 5778/    20EA : 4E75                   	RTS
 5779/    20EC :                        
 5780/    20EC :                        
 5781/    20EC :                        ;************************************************************************************
 5782/    20EC :                        ;
 5783/    20EC :                        ; round FAC1
 5784/    20EC :                        
 5785/    20EC :                        LAB_27BA
 5786/    20EC : 102B 0594              	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
 5787/    20F0 : 6720                   	BEQ.s		LAB_27C4				; branch if zero
 5788/    20F2 :                        
 5789/    20F2 : 202B 0590              	MOVE.l	FAC1_m(a3),d0			; get FAC1
 5790/    20F6 : D0BC 0000 0080         	ADD.l		#$80,d0				; round to 24 bit
 5791/    20FC : 640A                   	BCC.s		LAB_27C3				; branch if no overflow
 5792/    20FE :                        
 5793/    20FE : E290                   	ROXR.l	#1,d0					; shift FAC1 mantissa
 5794/    2100 : 522B 0594              	ADDQ.b	#1,FAC1_e(a3)			; correct exponent
 5795/    2104 : 6500 E560              	BCS		LAB_OFER				; if carry do overflow error & warm start
 5796/    2108 :                        
 5797/    2108 :                        LAB_27C3
 5798/    2108 : C03C 0000              	AND.b		#$00,d0				; clear guard byte
 5799/    210C : 2740 0590              	MOVE.l	d0,FAC1_m(a3)			; save back to FAC1
 5800/    2110 : 4E75                   	RTS
 5801/    2112 :                        
 5802/    2112 :                        LAB_27C4
 5803/    2112 : 1740 0595              	MOVE.b	d0,FAC1_s(a3)			; make zero always +ve
 5804/    2116 :                        RTS_017
 5805/    2116 : 4E75                   	RTS
 5806/    2118 :                        
 5807/    2118 :                        
 5808/    2118 :                        ;************************************************************************************
 5809/    2118 :                        ;
 5810/    2118 :                        ; get FAC1 sign
 5811/    2118 :                        ; return d0=-1,C=1/-ve d0=+1,C=0/+ve
 5812/    2118 :                        
 5813/    2118 :                        LAB_27CA
 5814/    2118 : 7000                   	MOVEQ		#0,d0					; clear d0
 5815/    211A : 102B 0594              	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
 5816/    211E : 67F6                   	BEQ.s		RTS_017				; exit if zero (already correct SGN(0)=0)
 5817/    2120 :                        
 5818/    2120 :                        
 5819/    2120 :                        ;************************************************************************************
 5820/    2120 :                        ;
 5821/    2120 :                        ; return d0=-1,C=1/-ve d0=+1,C=0/+ve
 5822/    2120 :                        ; no = 0 check
 5823/    2120 :                        
 5824/    2120 :                        LAB_27CE
 5825/    2120 : 102B 0595              	MOVE.b	FAC1_s(a3),d0			; else get FAC1 sign (b7)
 5826/    2124 :                        
 5827/    2124 :                        
 5828/    2124 :                        ;************************************************************************************
 5829/    2124 :                        ;
 5830/    2124 :                        ; return d0=-1,C=1/-ve d0=+1,C=0/+ve
 5831/    2124 :                        ; no = 0 check, sign in d0
 5832/    2124 :                        
 5833/    2124 :                        LAB_27D0
 5834/    2124 : 4880                   	EXT.w		d0					; make word
 5835/    2126 : 48C0                   	EXT.l		d0					; make longword
 5836/    2128 : E080                   	ASR.l		#8,d0					; move sign bit through byte to carry
 5837/    212A : 65EA                   	BCS.s		RTS_017				; exit if carry set
 5838/    212C :                        
 5839/    212C : 7001                   	MOVEQ		#1,d0					; set result for +ve sign
 5840/    212E : 4E75                   	RTS
 5841/    2130 :                        
 5842/    2130 :                        
 5843/    2130 :                        ;************************************************************************************
 5844/    2130 :                        ;
 5845/    2130 :                        ; perform SGN()
 5846/    2130 :                        
 5847/    2130 :                        LAB_SGN
 5848/    2130 : 61E6                   	BSR.s		LAB_27CA				; get FAC1 sign
 5849/    2132 :                        								; return d0=-1/-ve d0=+1/+ve
 5850/    2132 :                        
 5851/    2132 :                        
 5852/    2132 :                        ;************************************************************************************
 5853/    2132 :                        ;
 5854/    2132 :                        ; save d0 as integer longword
 5855/    2132 :                        
 5856/    2132 :                        LAB_27DB
 5857/    2132 : 2740 0590              	MOVE.l	d0,FAC1_m(a3)			; save FAC1 mantissa
 5858/    2136 : 377C A000 0594         	MOVE.w	#$A000,FAC1_e(a3)			; set FAC1 exponent & sign
 5859/    213C : D080                   	ADD.l		d0,d0					; top bit into carry
 5860/    213E : 6000 FCD0              	BRA		LAB_24D0				; do +/- (carry is sign) & normalise FAC1
 5861/    2142 :                        
 5862/    2142 :                        
 5863/    2142 :                        ;************************************************************************************
 5864/    2142 :                        ;
 5865/    2142 :                        ; perform ABS()
 5866/    2142 :                        
 5867/    2142 :                        LAB_ABS
 5868/    2142 : 177C 0000 0595         	MOVE.b	#0,FAC1_s(a3)			; clear FAC1 sign
 5869/    2148 : 4E75                   	RTS
 5870/    214A :                        
 5871/    214A :                        
 5872/    214A :                        ;************************************************************************************
 5873/    214A :                        ;
 5874/    214A :                        ; compare FAC1 with FAC2
 5875/    214A :                        ; returns d0=+1 Cb=0 if FAC1 > FAC2
 5876/    214A :                        ; returns d0= 0 Cb=0 if FAC1 = FAC2
 5877/    214A :                        ; returns d0=-1 Cb=1 if FAC1 < FAC2
 5878/    214A :                        
 5879/    214A :                        LAB_27FA
 5880/    214A : 122B 059C              	MOVE.b	FAC2_e(a3),d1			; get FAC2 exponent
 5881/    214E : 67C8                   	BEQ.s		LAB_27CA				; branch if FAC2 exponent=0 & get FAC1 sign
 5882/    2150 :                        								; d0=-1,C=1/-ve d0=+1,C=0/+ve
 5883/    2150 :                        
 5884/    2150 : 102B 059E              	MOVE.b	FAC_sc(a3),d0			; get FAC sign compare
 5885/    2154 : 6BCA                   	BMI.s		LAB_27CE				; if signs <> do return d0=-1,C=1/-ve
 5886/    2156 :                        								; d0=+1,C=0/+ve & return
 5887/    2156 :                        
 5888/    2156 : 102B 0595              	MOVE.b	FAC1_s(a3),d0			; get FAC1 sign
 5889/    215A : B22B 0594              	CMP.b		FAC1_e(a3),d1			; compare FAC1 exponent with FAC2 exponent
 5890/    215E : 660A                   	BNE.s		LAB_2828				; branch if different
 5891/    2160 :                        
 5892/    2160 : 222B 0598              	MOVE.l	FAC2_m(a3),d1			; get FAC2 mantissa
 5893/    2164 : B2AB 0590              	CMP.l		FAC1_m(a3),d1			; compare mantissas
 5894/    2168 : 6708                   	BEQ.s		LAB_282F				; exit if mantissas equal
 5895/    216A :                        
 5896/    216A :                        ; gets here if number <> FAC1
 5897/    216A :                        
 5898/    216A :                        LAB_2828
 5899/    216A : 65B8                   	BCS.s		LAB_27D0				; if FAC1 > FAC2 return d0=-1,C=1/-ve d0=+1,
 5900/    216C :                        								; C=0/+ve
 5901/    216C :                        
 5902/    216C : 0A00 0080              	EORI.b	#$80,d0				; else toggle FAC1 sign
 5903/    2170 :                        LAB_282E
 5904/    2170 : 60B2                   	BRA.s		LAB_27D0				; return d0=-1,C=1/-ve d0=+1,C=0/+ve
 5905/    2172 :                        
 5906/    2172 :                        LAB_282F
 5907/    2172 : 7000                   	MOVEQ		#0,d0					; clear result
 5908/    2174 : 4E75                   	RTS
 5909/    2176 :                        
 5910/    2176 :                        
 5911/    2176 :                        ;************************************************************************************
 5912/    2176 :                        ;
 5913/    2176 :                        ; convert FAC1 floating to fixed
 5914/    2176 :                        ; result in d0 and Itemp, sets flags correctly
 5915/    2176 :                        
 5916/    2176 :                        LAB_2831
 5917/    2176 : 202B 0590              	MOVE.l	FAC1_m(a3),d0			; copy mantissa
 5918/    217A : 6732                   	BEQ.s		LAB_284J				; branch if mantissa = 0
 5919/    217C :                        
 5920/    217C : 2F01                   	MOVE.l	d1,-(sp)				; save d1
 5921/    217E : 123C 00A0              	MOVE.b		#$A0,d1				; set for no floating bits
 5922/    2182 : 922B 0594              	SUB.b		FAC1_e(a3),d1			; subtract FAC1 exponent
 5923/    2186 : 6500 E4DE              	BCS		LAB_OFER				; do overflow if too big
 5924/    218A :                        
 5925/    218A : 660E                   	BNE.s		LAB_284G				; branch if exponent was not $A0
 5926/    218C :                        
 5927/    218C : 4A2B 0595              	TST.b		FAC1_s(a3)				; test FAC1 sign
 5928/    2190 : 6A1A                   	BPL.s		LAB_284H				; branch if FAC1 +ve
 5929/    2192 :                        
 5930/    2192 : 4480                   	NEG.l		d0
 5931/    2194 : 6916                   	BVS.s		LAB_284H				; branch if was $80000000
 5932/    2196 :                        
 5933/    2196 : 6000 E4CE              	BRA		LAB_OFER				; do overflow if too big
 5934/    219A :                        
 5935/    219A :                        LAB_284G
 5936/    219A : B23C 0020              	CMP.b		#$20,d1				; compare with minimum result for integer
 5937/    219E : 6502                   	BCS.s		LAB_284L				; if < minimum just do shift
 5938/    21A0 :                        
 5939/    21A0 : 7000                   	MOVEQ		#0,d0					; else return zero
 5940/    21A2 :                        LAB_284L
 5941/    21A2 : E2A8                   	LSR.l		d1,d0					; shift integer
 5942/    21A4 :                        
 5943/    21A4 : 4A2B 0595              	TST.b		FAC1_s(a3)				; test FAC1 sign (b7)
 5944/    21A8 : 6A02                   	BPL.s		LAB_284H				; branch if FAC1 +ve
 5945/    21AA :                        
 5946/    21AA : 4480                   	NEG.l		d0					; negate integer value
 5947/    21AC :                        LAB_284H
 5948/    21AC : 221F                   	MOVE.l	(sp)+,d1				; restore d1
 5949/    21AE :                        LAB_284J
 5950/    21AE : 2740 042A              	MOVE.l	d0,Itemp(a3)			; save result to Itemp
 5951/    21B2 : 4E75                   	RTS
 5952/    21B4 :                        
 5953/    21B4 :                        
 5954/    21B4 :                        ;************************************************************************************
 5955/    21B4 :                        ;
 5956/    21B4 :                        ; perform INT()
 5957/    21B4 :                        
 5958/    21B4 :                        LAB_INT
 5959/    21B4 : 103C 00A0              	MOVE.b		#$A0,d0				; set for no floating bits
 5960/    21B8 : 902B 0594              	SUB.b		FAC1_e(a3),d0			; subtract FAC1 exponent
 5961/    21BC : 6310                   	BLS.s		LAB_IRTS				; exit if exponent >= $A0
 5962/    21BE :                        								; (too big for fraction part!)
 5963/    21BE :                        
 5964/    21BE : B03C 0020              	CMP.b		#$20,d0				; compare with minimum result for integer
 5965/    21C2 : 6400 0262              	BCC		LAB_POZE				; if >= minimum go return 0
 5966/    21C6 :                        								; (too small for integer part!)
 5967/    21C6 :                        
 5968/    21C6 : 72FF                   	MOVEQ		#-1,d1				; set integer mask
 5969/    21C8 : E1A1                   	ASL.l		d0,d1					; shift mask [8+2*d0]
 5970/    21CA : C3AB 0590              	AND.l		d1,FAC1_m(a3)			; mask mantissa
 5971/    21CE :                        LAB_IRTS
 5972/    21CE : 4E75                   	RTS
 5973/    21D0 :                        
 5974/    21D0 :                        
 5975/    21D0 :                        ;************************************************************************************
 5976/    21D0 :                        ;
 5977/    21D0 :                        ; print " in line [LINE #]"
 5978/    21D0 :                        
 5979/    21D0 :                        LAB_2953
 5980/    21D0 : 41FA 1800              	LEA		LAB_LMSG(pc),a0			; point to " in line " message
 5981/    21D4 : 6100 ED1C              	BSR		LAB_18C3				; print null terminated string
 5982/    21D8 :                        
 5983/    21D8 :                        								; Print Basic line #
 5984/    21D8 : 202B 0452              	MOVE.l	Clinel(a3),d0			; get current line
 5985/    21DC :                        
 5986/    21DC :                        
 5987/    21DC :                        ;************************************************************************************
 5988/    21DC :                        ;
 5989/    21DC :                        ; print d0 as unsigned integer
 5990/    21DC :                        
 5991/    21DC :                        LAB_295E
 5992/    21DC : 43FA 0DEE              	LEA		Bin2dec(pc),a1			; get table address
 5993/    21E0 : 7200                   	MOVEQ		#0,d1					; table index
 5994/    21E2 : 41EB 05CC              	LEA		Usdss(a3),a0			; output string start
 5995/    21E6 : 2401                   	MOVE.l	d1,d2					; output string index
 5996/    21E8 :                        LAB_2967
 5997/    21E8 : 2631 1000              	MOVE.l	(a1,d1.w),d3			; get table value
 5998/    21EC : 6714                   	BEQ.s		LAB_2969				; exit if end marker
 5999/    21EE :                        
 6000/    21EE : 782F                   	MOVEQ		#'0'-1,d4				; set character to "0"-1
 6001/    21F0 :                        LAB_2968
 6002/    21F0 : 5244                   	ADDQ.w	#1,d4					; next numeric character
 6003/    21F2 : 9083                   	SUB.l		d3,d0					; subtract table value
 6004/    21F4 : 6AFA                   	BPL.s		LAB_2968				; not overdone so loop
 6005/    21F6 :                        
 6006/    21F6 : D083                   	ADD.l		d3,d0					; correct value
 6007/    21F8 : 1184 2000              	MOVE.b	d4,(a0,d2.w)			; character out to string
 6008/    21FC : 5841                   	ADDQ.w	#4,d1					; increment table pointer
 6009/    21FE : 5242                   	ADDQ.w	#1,d2					; increment output string pointer
 6010/    2200 : 60E6                   	BRA.s		LAB_2967				; loop
 6011/    2202 :                        
 6012/    2202 :                        LAB_2969
 6013/    2202 : D03C 0030              	ADD.b		#'0',d0				; make last character
 6014/    2206 : 1180 2000              	MOVE.b	d0,(a0,d2.w)			; character out to string
 6015/    220A : 5348                   	SUBQ.w	#1,a0					; decrement a0 (allow simple loop)
 6016/    220C :                        
 6017/    220C :                        								; now find non zero start of string
 6018/    220C :                        LAB_296A
 6019/    220C : 5248                   	ADDQ.w	#1,a0					; increment a0 (this will never carry to b16)
 6020/    220E : 43EB 05D5              	LEA		BHsend-1(a3),a1			; get string end
 6021/    2212 : B1C9                   	CMPA.l	a1,a0					; are we at end
 6022/    2214 : 6700 ECDC              	BEQ		LAB_18C3				; if so print null terminated string and RETURN
 6023/    2218 :                        
 6024/    2218 : 0C10 0030              	CMPI.b	#'0',(a0)				; is character "0" ?
 6025/    221C : 67EE                   	BEQ.s		LAB_296A				; loop if so
 6026/    221E :                        
 6027/    221E : 6000 ECD2              	BRA		LAB_18C3				; print null terminated string from memory & RET
 6028/    2222 :                        
 6029/    2222 :                        
 6030/    2222 :                        ;************************************************************************************
 6031/    2222 :                        ;
 6032/    2222 :                        ; convert FAC1 to ASCII string result in (a0)
 6033/    2222 :                        ; STR$() function enters here
 6034/    2222 :                        
 6035/    2222 :                        ; now outputs 7 significant digits
 6036/    2222 :                        
 6037/    2222 :                        ; d0 is character out
 6038/    2222 :                        ; d1 is save index
 6039/    2222 :                        ; d2 is gash
 6040/    2222 :                        
 6041/    2222 :                        ; a0 is output string pointer
 6042/    2222 :                        
 6043/    2222 :                        LAB_2970
 6044/    2222 : 43EB 05C6              	LEA		Decss(a3),a1			; set output string start
 6045/    2226 :                        
 6046/    2226 : 7420                   	MOVEQ		#' ',d2				; character = " ", assume +ve
 6047/    2228 : 08AB 0007 0595         	BCLR.b	#7,FAC1_s(a3)			; test and clear FAC1 sign (b7)
 6048/    222E : 6702                   	BEQ.s		LAB_2978				; branch if +ve
 6049/    2230 :                        
 6050/    2230 : 742D                   	MOVEQ		#'-',d2				; else character = "-"
 6051/    2232 :                        LAB_2978
 6052/    2232 : 1282                   	MOVE.b	d2,(a1)				; save the sign character
 6053/    2234 : 142B 0594              	MOVE.b	FAC1_e(a3),d2			; get FAC1 exponent
 6054/    2238 : 6608                   	BNE.s		LAB_2989				; branch if FAC1<>0
 6055/    223A :                        
 6056/    223A :                        								; exponent was $00 so FAC1 is 0
 6057/    223A : 7030                   	MOVEQ		#'0',d0				; set character = "0"
 6058/    223C : 7201                   	MOVEQ		#1,d1					; set output string index
 6059/    223E : 6000 01A8              	BRA		LAB_2A89				; save last character, [EOT] & exit
 6060/    2242 :                        
 6061/    2242 :                        								; FAC1 is some non zero value
 6062/    2242 :                        LAB_2989
 6063/    2242 : 177C 0000 05AC         	MOVE.b	#0,numexp(a3)			; clear number exponent count
 6064/    2248 : B43C 0081              	CMP.b		#$81,d2				; compare FAC1 exponent with $81 (>1.00000)
 6065/    224C :                        
 6066/    224C : 6448                   	BCC.s		LAB_299C				; branch if FAC1=>1
 6067/    224E :                        
 6068/    224E :                        								; else FAC1 < 1
 6069/    224E : 277C 9896 8000 0598    	MOVE.l	#$98968000,FAC2_m(a3)		; 10000000 mantissa
 6070/    2256 : 377C 9800 059C         	MOVE.w	#$9800,FAC2_e(a3)			; 10000000 exponent & sign
 6071/    225C : 176B 0595 059E         	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; make FAC1 sign sign compare
 6072/    2262 : 6100 FCE0              	BSR		LAB_MULTIPLY			; do FAC2*FAC1
 6073/    2266 :                        
 6074/    2266 : 177C 00F9 05AC         	MOVE.b	#$F9,numexp(a3)			; set number exponent count (-7)
 6075/    226C : 6028                   	BRA.s		LAB_299C				; go test for fit
 6076/    226E :                        
 6077/    226E :                        LAB_29B9
 6078/    226E : 376B 0594 059C         	MOVE.w	FAC1_e(a3),FAC2_e(a3)		; copy exponent & sign from FAC1 to FAC2
 6079/    2274 : 276B 0590 0598         	MOVE.l	FAC1_m(a3),FAC2_m(a3)		; copy FAC1 mantissa to FAC2 mantissa
 6080/    227A : 176B 0595 059E         	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; save FAC1_s as sign compare
 6081/    2280 :                        
 6082/    2280 : 277C CCCC CCCD 0590    	MOVE.l	#$CCCCCCCD,FAC1_m(a3)		; 1/10 mantissa
 6083/    2288 : 377C 7D00 0594         	MOVE.w	#$7D00,FAC1_e(a3)			; 1/10 exponent & sign
 6084/    228E : 6100 FCB4              	BSR		LAB_MULTIPLY			; do FAC2*FAC1, effectively divide by 10 but
 6085/    2292 :                        								; faster
 6086/    2292 :                        
 6087/    2292 : 522B 05AC              	ADDQ.b	#1,numexp(a3)			; increment number exponent count
 6088/    2296 :                        LAB_299C
 6089/    2296 : 277C 9896 7F70 0598    	MOVE.l	#$98967F70,FAC2_m(a3)		; 9999999.4375 mantissa
 6090/    229E : 377C 9800 059C         	MOVE.w	#$9800,FAC2_e(a3)			; 9999999.4375 exponent & sign
 6091/    22A4 :                        								; (max before scientific notation)
 6092/    22A4 : 6100 0150              	BSR		LAB_27F0				; fast compare FAC1 with FAC2
 6093/    22A8 :                        								; returns d0=+1 C=0 if FAC1 > FAC2
 6094/    22A8 :                        								; returns d0= 0 C=0 if FAC1 = FAC2
 6095/    22A8 :                        								; returns d0=-1 C=1 if FAC1 < FAC2
 6096/    22A8 : 62C4                   	BHI.s		LAB_29B9				; go do /10 if FAC1 > 9999999.4375
 6097/    22AA :                        
 6098/    22AA : 6750                   	BEQ.s		LAB_29C3				; branch if FAC1 = 9999999.4375
 6099/    22AC :                        
 6100/    22AC :                        								; FAC1 < 9999999.4375
 6101/    22AC : 277C F423 F800 0598    	MOVE.l	#$F423F800,FAC2_m(a3)		; set mantissa for 999999.5
 6102/    22B4 : 377C 9400 059C         	MOVE.w	#$9400,FAC2_e(a3)			; set exponent for 999999.5
 6103/    22BA :                        
 6104/    22BA : 41EB 0590              	LEA		FAC1_m(a3),a0			; set pointer for x10
 6105/    22BE :                        LAB_29A7
 6106/    22BE : 6100 0136              	BSR		LAB_27F0				; fast compare FAC1 with FAC2
 6107/    22C2 :                        								; returns d0=+1 C=0 if FAC1 > FAC2
 6108/    22C2 :                        								; returns d0= 0 C=0 if FAC1 = FAC2
 6109/    22C2 :                        								; returns d0=-1 C=1 if FAC1 < FAC2
 6110/    22C2 : 6220                   	BHI.s		LAB_29C0				; branch if FAC1 > 99999.9375,no decimal places
 6111/    22C4 :                        
 6112/    22C4 :                        								; FAC1 <= 999999.5 so do x 10
 6113/    22C4 : 2010                   	MOVE.l	(a0),d0				; get FAC1 mantissa
 6114/    22C6 : 1228 0004              	MOVE.b	4(a0),d1				; get FAC1 exponent
 6115/    22CA : 2400                   	MOVE.l	d0,d2					; copy it
 6116/    22CC : E488                   	LSR.l		#2,d0					; /4
 6117/    22CE : D082                   	ADD.l		d2,d0					; add FAC1 (x1.125)
 6118/    22D0 : 6404                   	BCC.s		LAB_29B7				; branch if no carry
 6119/    22D2 :                        
 6120/    22D2 : E290                   	ROXR.l	#1,d0					; shift carry back in
 6121/    22D4 : 5201                   	ADDQ.b	#1,d1					; increment exponent (never overflows)
 6122/    22D6 :                        LAB_29B7
 6123/    22D6 : 5601                   	ADDQ.b	#3,d1					; correct exponent ( 8 x 1.125 = 10 )
 6124/    22D8 :                        								; (never overflows)
 6125/    22D8 : 2080                   	MOVE.l	d0,(a0)				; save new mantissa
 6126/    22DA : 1141 0004              	MOVE.b	d1,4(a0)				; save new exponent
 6127/    22DE : 532B 05AC              	SUBQ.b	#1,numexp(a3)			; decrement number exponent count
 6128/    22E2 : 60DA                   	BRA.s		LAB_29A7				; go test again
 6129/    22E4 :                        
 6130/    22E4 :                        								; now we have just the digits to do
 6131/    22E4 :                        LAB_29C0
 6132/    22E4 : 277C 8000 0000 0598    	MOVE.l	#$80000000,FAC2_m(a3)		; set mantissa for 0.5
 6133/    22EC : 377C 8000 059C         	MOVE.w	#$8000,FAC2_e(a3)			; set exponent for 0.5
 6134/    22F2 : 176B 0595 059E         	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; sign compare = sign
 6135/    22F8 : 6100 FAA6              	BSR		LAB_ADD				; add the 0.5 to FAC1 (round FAC1)
 6136/    22FC :                        
 6137/    22FC :                        LAB_29C3
 6138/    22FC : 6100 FE78              	BSR		LAB_2831				; convert FAC1 floating to fixed
 6139/    2300 :                        								; result in d0 and Itemp
 6140/    2300 : 7401                   	MOVEQ		#$01,d2				; set default digits before dp = 1
 6141/    2302 : 102B 05AC              	MOVE.b	numexp(a3),d0			; get number exponent count
 6142/    2306 : D03C 0008              	ADD.b		#8,d0					; allow 7 digits before point
 6143/    230A : 6B0C                   	BMI.s		LAB_29D9				; if -ve then 1 digit before dp
 6144/    230C :                        
 6145/    230C : B03C 0009              	CMP.b		#$09,d0				; d0>=9 if n>=1E7
 6146/    2310 : 6406                   	BCC.s		LAB_29D9				; branch if >= $09
 6147/    2312 :                        
 6148/    2312 :                        								; < $08
 6149/    2312 : 5300                   	SUBQ.b	#1,d0					; take 1 from digit count
 6150/    2314 : 1400                   	MOVE.b	d0,d2					; copy byte
 6151/    2316 : 7002                   	MOVEQ		#$02,d0				; set exponent adjust
 6152/    2318 :                        LAB_29D9
 6153/    2318 : 7200                   	MOVEQ		#0,d1					; set output string index
 6154/    231A : 5500                   	SUBQ.b	#2,d0					; -2
 6155/    231C : 1740 05AD              	MOVE.b	d0,expcnt(a3)			; save exponent adjust
 6156/    2320 : 1742 05AC              	MOVE.b	d2,numexp(a3)			; save digits before dp count
 6157/    2324 : 1002                   	MOVE.b	d2,d0					; copy digits before dp count
 6158/    2326 : 6702                   	BEQ.s		LAB_29E4				; branch if no digits before dp
 6159/    2328 :                        
 6160/    2328 : 6A14                   	BPL.s		LAB_29F7				; branch if digits before dp
 6161/    232A :                        
 6162/    232A :                        LAB_29E4
 6163/    232A : 5281                   	ADDQ.l	#1,d1					; increment index
 6164/    232C : 13BC 002E 1000         	MOVE.b	#'.',(a1,d1.w)			; save to output string
 6165/    2332 :                        
 6166/    2332 : 4A02                   	TST.b		d2					; test digits before dp count
 6167/    2334 : 6708                   	BEQ.s		LAB_29F7				; branch if no digits before dp
 6168/    2336 :                        
 6169/    2336 : 5281                   	ADDQ.l	#1,d1					; increment index
 6170/    2338 : 13BC 0030 1000         	MOVE.b	#'0',(a1,d1.w)			; save to output string
 6171/    233E :                        LAB_29F7
 6172/    233E : 7400                   	MOVEQ		#0,d2					; clear index (point to 1,000,000)
 6173/    2340 : 7080                   	MOVEQ		#$80-$100,d0			; set output character
 6174/    2342 :                        LAB_29FB
 6175/    2342 : 41FA 1122              	LEA		LAB_2A9A(pc),a0			; get base of table
 6176/    2346 : 2630 2000              	MOVE.l	(a0,d2.w),d3			; get table value
 6177/    234A :                        LAB_29FD
 6178/    234A : 5200                   	ADDQ.b	#1,d0					; increment output character
 6179/    234C : D7AB 042A              	ADD.l		d3,Itemp(a3)			; add to (now fixed) mantissa
 6180/    2350 : 0800 0007              	BTST		#7,d0					; set test sense (z flag only)
 6181/    2354 : 6504                   	BCS.s		LAB_2A18				; did carry so has wrapped past zero
 6182/    2356 :                        
 6183/    2356 : 67F2                   	BEQ.s		LAB_29FD				; no wrap and +ve test so try again
 6184/    2358 :                        
 6185/    2358 : 6002                   	BRA.s		LAB_2A1A				; found this digit
 6186/    235A :                        
 6187/    235A :                        LAB_2A18
 6188/    235A : 66EE                   	BNE.s		LAB_29FD				; wrap and -ve test so try again
 6189/    235C :                        
 6190/    235C :                        LAB_2A1A
 6191/    235C : 6406                   	BCC.s		LAB_2A21				; branch if +ve test result
 6192/    235E :                        
 6193/    235E : 4400                   	NEG.b		d0					; negate the digit number
 6194/    2360 : D03C 000B              	ADD.b		#$0B,d0				; and subtract from 11 decimal
 6195/    2364 :                        LAB_2A21
 6196/    2364 : D03C 002F              	ADD.b		#$2F,d0				; add "0"-1 to result
 6197/    2368 : 5842                   	ADDQ.w	#4,d2					; increment index to next less power of ten
 6198/    236A : 5241                   	ADDQ.w	#1,d1					; increment output string index
 6199/    236C : 1600                   	MOVE.b	d0,d3					; copy character to d3
 6200/    236E : C63C 007F              	AND.b		#$7F,d3				; mask out top bit
 6201/    2372 : 1383 1000              	MOVE.b	d3,(a1,d1.w)			; save to output string
 6202/    2376 : 042B 0001 05AC         	SUB.b		#1,numexp(a3)			; decrement # of characters before the dp
 6203/    237C : 6608                   	BNE.s		LAB_2A3B				; branch if still characters to do
 6204/    237E :                        
 6205/    237E :                        								; else output the point
 6206/    237E : 5281                   	ADDQ.l	#1,d1					; increment index
 6207/    2380 : 13BC 002E 1000         	MOVE.b	#'.',(a1,d1.w)			; save to output string
 6208/    2386 :                        LAB_2A3B
 6209/    2386 : C03C 0080              	AND.b		#$80,d0				; mask test sense bit
 6210/    238A : 0A00 0080              	EORI.b	#$80,d0				; invert it
 6211/    238E : B43C 001C              	CMP.b		#LAB_2A9B-LAB_2A9A,d2		; compare table index with max+4
 6212/    2392 : 66AE                   	BNE.s		LAB_29FB				; loop if not max
 6213/    2394 :                        
 6214/    2394 :                        								; now remove trailing zeroes
 6215/    2394 :                        LAB_2A4B
 6216/    2394 : 1031 1000              	MOVE.b	(a1,d1.w),d0			; get character from output string
 6217/    2398 : 5381                   	SUBQ.l	#1,d1					; decrement output string index
 6218/    239A : B03C 0030              	CMP.b		#'0',d0				; compare with "0"
 6219/    239E : 67F4                   	BEQ.s		LAB_2A4B				; loop until non "0" character found
 6220/    23A0 :                        
 6221/    23A0 : B03C 002E              	CMP.b		#'.',d0				; compare with "."
 6222/    23A4 : 6702                   	BEQ.s		LAB_2A58				; branch if was dp
 6223/    23A6 :                        
 6224/    23A6 :                        								; else restore last character
 6225/    23A6 : 5281                   	ADDQ.l	#1,d1					; increment output string index
 6226/    23A8 :                        LAB_2A58
 6227/    23A8 : 13BC 002B 1002         	MOVE.b	#'+',2(a1,d1.w)			; save character "+" to output string
 6228/    23AE : 4A2B 05AD              	TST.b		expcnt(a3)				; test exponent count
 6229/    23B2 : 6738                   	BEQ.s		LAB_2A8C				; if zero go set null terminator & exit
 6230/    23B4 :                        
 6231/    23B4 :                        								; exponent isn't zero so write exponent
 6232/    23B4 : 6A0A                   	BPL.s		LAB_2A68				; branch if exponent count +ve
 6233/    23B6 :                        
 6234/    23B6 : 13BC 002D 1002         	MOVE.b	#'-',2(a1,d1.w)			; save character "-" to output string
 6235/    23BC : 442B 05AD              	NEG.b		expcnt(a3)				; convert -ve to +ve
 6236/    23C0 :                        LAB_2A68
 6237/    23C0 : 13BC 0045 1001         	MOVE.b	#'E',1(a1,d1.w)			; save character "E" to output string
 6238/    23C6 : 142B 05AD              	MOVE.b	expcnt(a3),d2			; get exponent count
 6239/    23CA : 702F                   	MOVEQ		#$2F,d0				; one less than "0" character
 6240/    23CC :                        LAB_2A74
 6241/    23CC : 5200                   	ADDQ.b	#1,d0					; increment 10's character
 6242/    23CE : 943C 000A              	SUB.b		#$0A,d2				; subtract 10 from exponent count
 6243/    23D2 : 64F8                   	BCC.s		LAB_2A74				; loop while still >= 0
 6244/    23D4 :                        
 6245/    23D4 : D43C 003A              	ADD.b		#$3A,d2				; add character ":", $30+$0A, result is 10-value
 6246/    23D8 : 1380 1003              	MOVE.b	d0,3(a1,d1.w)			; save 10's character to output string
 6247/    23DC : 1382 1004              	MOVE.b	d2,4(a1,d1.w)			; save 1's character to output string
 6248/    23E0 : 13BC 0000 1005         	MOVE.b	#0,5(a1,d1.w)			; save null terminator after last character
 6249/    23E6 : 600A                   	BRA.s		LAB_2A91				; go set string pointer (a0) and exit
 6250/    23E8 :                        
 6251/    23E8 :                        LAB_2A89
 6252/    23E8 : 1380 1000              	MOVE.b	d0,(a1,d1.w)			; save last character to output string
 6253/    23EC :                        LAB_2A8C
 6254/    23EC : 13BC 0000 1001         	MOVE.b	#0,1(a1,d1.w)			; save null terminator after last character
 6255/    23F2 :                        LAB_2A91
 6256/    23F2 : 2049                   	MOVEA.l	a1,a0					; set result string pointer (a0)
 6257/    23F4 : 4E75                   	RTS
 6258/    23F6 :                        
 6259/    23F6 :                        
 6260/    23F6 :                        ;************************************************************************************
 6261/    23F6 :                        ;
 6262/    23F6 :                        ; fast compare FAC1 with FAC2
 6263/    23F6 :                        ; assumes both are +ve and FAC2>0
 6264/    23F6 :                        ; returns d0=+1 C=0 if FAC1 > FAC2
 6265/    23F6 :                        ; returns d0= 0 C=0 if FAC1 = FAC2
 6266/    23F6 :                        ; returns d0=-1 C=1 if FAC1 < FAC2
 6267/    23F6 :                        
 6268/    23F6 :                        LAB_27F0
 6269/    23F6 : 7000                   	MOVEQ		#0,d0					; set for FAC1 = FAC2
 6270/    23F8 : 122B 059C              	MOVE.b	FAC2_e(a3),d1			; get FAC2 exponent
 6271/    23FC : B22B 0594              	CMP.b		FAC1_e(a3),d1			; compare FAC1 exponent with FAC2 exponent
 6272/    2400 : 660A                   	BNE.s		LAB_27F1				; branch if different
 6273/    2402 :                        
 6274/    2402 : 222B 0598              	MOVE.l	FAC2_m(a3),d1			; get FAC2 mantissa
 6275/    2406 : B2AB 0590              	CMP.l		FAC1_m(a3),d1			; compare mantissas
 6276/    240A : 6708                   	BEQ.s		LAB_27F3				; exit if mantissas equal
 6277/    240C :                        
 6278/    240C :                        LAB_27F1
 6279/    240C : 6504                   	BCS.s		LAB_27F2				; if FAC1 > FAC2 return d0=+1,C=0
 6280/    240E :                        
 6281/    240E : 5380                   	SUBQ.l	#1,d0					; else FAC1 < FAC2 return d0=-1,C=1
 6282/    2410 : 4E75                   	RTS
 6283/    2412 :                        
 6284/    2412 :                        LAB_27F2
 6285/    2412 : 5280                   	ADDQ.l	#1,d0
 6286/    2414 :                        LAB_27F3
 6287/    2414 : 4E75                   	RTS
 6288/    2416 :                        
 6289/    2416 :                        
 6290/    2416 :                        ;************************************************************************************
 6291/    2416 :                        ;
 6292/    2416 :                        ; make FAC1 = 1
 6293/    2416 :                        
 6294/    2416 :                        LAB_POON
 6295/    2416 : 277C 8000 0000 0590    	MOVE.l	#$80000000,FAC1_m(a3)		; 1 mantissa
 6296/    241E : 377C 8100 0594         	MOVE.w	#$8100,FAC1_e(a3)			; 1 exonent & sign
 6297/    2424 : 4E75                   	RTS
 6298/    2426 :                        
 6299/    2426 :                        
 6300/    2426 :                        ;************************************************************************************
 6301/    2426 :                        ;
 6302/    2426 :                        ; make FAC1 = 0
 6303/    2426 :                        
 6304/    2426 :                        LAB_POZE
 6305/    2426 : 7000                   	MOVEQ		#0,d0					; clear longword
 6306/    2428 : 2740 0590              	MOVE.l	d0,FAC1_m(a3)			; 0 mantissa
 6307/    242C : 3740 0594              	MOVE.w	d0,FAC1_e(a3)			; 0 exonent & sign
 6308/    2430 : 4E75                   	RTS
 6309/    2432 :                        
 6310/    2432 :                        
 6311/    2432 :                        ;************************************************************************************
 6312/    2432 :                        ;
 6313/    2432 :                        ; perform power function
 6314/    2432 :                        ; the number is in FAC2, the power is in FAC1
 6315/    2432 :                        ; no longer trashes Itemp
 6316/    2432 :                        
 6317/    2432 :                        LAB_POWER
 6318/    2432 : 4A2B 0594              	TST.b		FAC1_e(a3)				; test power
 6319/    2436 : 67DE                   	BEQ.s		LAB_POON				; if zero go return 1
 6320/    2438 :                        
 6321/    2438 : 4A2B 059C              	TST.b		FAC2_e(a3)				; test number
 6322/    243C : 67E8                   	BEQ.s		LAB_POZE				; if zero go return 0
 6323/    243E :                        
 6324/    243E : 1F2B 059D              	MOVE.b	FAC2_s(a3),-(sp)			; save number sign
 6325/    2442 : 6A20                   	BPL.s		LAB_POWP				; power of positive number
 6326/    2444 :                        
 6327/    2444 : 7200                   	MOVEQ		#0,d1					; clear d1
 6328/    2446 : 1741 059D              	MOVE.b	d1,FAC2_s(a3)			; make sign +ve
 6329/    244A :                        
 6330/    244A :                        								; number sign was -ve and can only be raised to
 6331/    244A :                        								; an integer power which gives an x +j0 result,
 6332/    244A :                        								; else do 'function call' error
 6333/    244A : 122B 0594              	MOVE.b	FAC1_e(a3),d1			; get power exponent
 6334/    244E : 927C 0080              	SUB.w		#$80,d1				; normalise to .5
 6335/    2452 : 6300 E216              	BLS		LAB_FCER				; if 0<power<1 then do 'function call' error
 6336/    2456 :                        
 6337/    2456 :                        								; now shift all the integer bits out
 6338/    2456 : 202B 0590              	MOVE.l	FAC1_m(a3),d0			; get power mantissa
 6339/    245A : E3A0                   	ASL.l		d1,d0					; shift mantissa
 6340/    245C : 6600 E20C              	BNE		LAB_FCER				; if power<>INT(power) then do 'function call'
 6341/    2460 :                        								; error
 6342/    2460 :                        
 6343/    2460 : 6502                   	BCS.s		LAB_POWP				; if integer value odd then leave result -ve
 6344/    2462 :                        
 6345/    2462 : 1E80                   	MOVE.b	d0,(sp)				; save result sign +ve
 6346/    2464 :                        LAB_POWP
 6347/    2464 : 2F2B 0590              	MOVE.l	FAC1_m(a3),-(sp)			; save power mantissa
 6348/    2468 : 3F2B 0594              	MOVE.w	FAC1_e(a3),-(sp)			; save power sign & exponent
 6349/    246C :                        
 6350/    246C : 6100 FC70              	BSR		LAB_279B				; copy number to FAC1
 6351/    2470 : 6100 F9E0              	BSR		LAB_LOG				; find log of number
 6352/    2474 :                        
 6353/    2474 : 301F                   	MOVE.w	(sp)+,d0				; get power sign & exponent
 6354/    2476 : 275F 0598              	MOVE.l	(sp)+,FAC2_m(a3)			; get power mantissa
 6355/    247A : 3740 059C              	MOVE.w	d0,FAC2_e(a3)			; save sign & exponent to FAC2
 6356/    247E : 1740 059E              	MOVE.b	d0,FAC_sc(a3)			; save sign as sign compare
 6357/    2482 : 102B 0595              	MOVE.b	FAC1_s(a3),d0			; get FAC1 sign
 6358/    2486 : B12B 059E              	EOR.b		d0,FAC_sc(a3)			; make sign compare (FAC1_s EOR FAC2_s)
 6359/    248A :                        
 6360/    248A : 6100 FAB8              	BSR		LAB_MULTIPLY			; multiply by power
 6361/    248E : 6158                   	BSR.s		LAB_EXP				; find exponential
 6362/    2490 : 175F 0595              	MOVE.b	(sp)+,FAC1_s(a3)			; restore number sign
 6363/    2494 : 4E75                   	RTS
 6364/    2496 :                        
 6365/    2496 :                        
 6366/    2496 :                        ;************************************************************************************
 6367/    2496 :                        ;
 6368/    2496 :                        ; do - FAC1
 6369/    2496 :                        
 6370/    2496 :                        LAB_GTHAN
 6371/    2496 : 4A2B 0594              	TST.b		FAC1_e(a3)				; test for non zero FAC1
 6372/    249A : 6706                   	BEQ.s		RTS_020				; branch if null
 6373/    249C :                        
 6374/    249C : 0A2B 0080 0595         	EORI.b	#$80,FAC1_s(a3)			; (else) toggle FAC1 sign bit
 6375/    24A2 :                        RTS_020
 6376/    24A2 : 4E75                   	RTS
 6377/    24A4 :                        
 6378/    24A4 :                        
 6379/    24A4 :                        ;************************************************************************************
 6380/    24A4 :                        ;
 6381/    24A4 :                        								; return +1
 6382/    24A4 :                        LAB_EX1
 6383/    24A4 : 277C 8000 0000 0590    	MOVE.l	#$80000000,FAC1_m(a3)		; +1 mantissa
 6384/    24AC : 377C 8100 0594         	MOVE.w	#$8100,FAC1_e(a3)			; +1 sign & exponent
 6385/    24B2 : 4E75                   	RTS
 6386/    24B4 :                        								; do over/under flow
 6387/    24B4 :                        LAB_EXOU
 6388/    24B4 : 4A2B 0595              	TST.b		FAC1_s(a3)				; test sign
 6389/    24B8 : 6A00 E1AC              	BPL		LAB_OFER				; was +ve so do overflow error
 6390/    24BC :                        
 6391/    24BC :                        								; else underflow so return zero
 6392/    24BC : 7000                   	MOVEQ		#0,d0					; clear longword
 6393/    24BE : 2740 0590              	MOVE.l	d0,FAC1_m(a3)			; 0 mantissa
 6394/    24C2 : 3740 0594              	MOVE.w	d0,FAC1_e(a3)			; 0 sign & exponent
 6395/    24C6 : 4E75                   	RTS
 6396/    24C8 :                        								; fraction was zero so do 2^n
 6397/    24C8 :                        LAB_EXOF
 6398/    24C8 : 277C 8000 0000 0590    	MOVE.l	#$80000000,FAC1_m(a3)		; +n mantissa
 6399/    24D0 : 177C 0000 0595         	MOVE.b	#0,FAC1_s(a3)			; clear sign
 6400/    24D6 : 4A2B 05B4              	TST.b		cosout(a3)				; test sign flag
 6401/    24DA : 6A02                   	BPL.s		LAB_EXOL				; branch if +ve
 6402/    24DC :                        
 6403/    24DC : 4481                   	NEG.l		d1					; else do 1/2^n
 6404/    24DE :                        LAB_EXOL
 6405/    24DE : D23C 0081              	ADD.b		#$81,d1				; adjust exponent
 6406/    24E2 : 1741 0594              	MOVE.b	d1,FAC1_e(a3)			; save exponent
 6407/    24E6 : 4E75                   	RTS
 6408/    24E8 :                        
 6409/    24E8 :                        ; perform EXP()	(x^e)
 6410/    24E8 :                        ; valid input range is -88 to +88
 6411/    24E8 :                        
 6412/    24E8 :                        LAB_EXP
 6413/    24E8 : 102B 0594              	MOVE.b	FAC1_e(a3),d0			; get exponent
 6414/    24EC : 67B6                   	BEQ.s		LAB_EX1				; return 1 for zero in
 6415/    24EE :                        
 6416/    24EE : B03C 0064              	CMP.b		#$64,d0				; compare exponent with min
 6417/    24F2 : 65B0                   	BCS.s		LAB_EX1				; if smaller just return 1
 6418/    24F4 :                        
 6419/    24F4 :                        ;	MOVEM.l	d1-d6/a0,-(sp)			; save the registers
 6420/    24F4 : 177C 0000 05B4         	MOVE.b	#0,cosout(a3)			; flag +ve number
 6421/    24FA : 222B 0590              	MOVE.l	FAC1_m(a3),d1			; get mantissa
 6422/    24FE : B03C 0087              	CMP.b		#$87,d0				; compare exponent with max
 6423/    2502 : 62B0                   	BHI.s		LAB_EXOU				; go do over/under flow if greater
 6424/    2504 :                        
 6425/    2504 : 6608                   	BNE.s		LAB_EXCM				; branch if less
 6426/    2506 :                        
 6427/    2506 :                        								; else is 2^7
 6428/    2506 : B2BC B00F 33C7         	CMP.l		#$B00F33C7,d1			; compare mantissa with n*2^7 max
 6429/    250C : 64A6                   	BCC.s		LAB_EXOU				; if => go over/underflow
 6430/    250E :                        
 6431/    250E :                        LAB_EXCM
 6432/    250E : 4A2B 0595              	TST.b		FAC1_s(a3)				; test sign
 6433/    2512 : 6A0C                   	BPL.s		LAB_EXPS				; branch if arg +ve
 6434/    2514 :                        
 6435/    2514 : 177C 00FF 05B4         	MOVE.b	#$FF,cosout(a3)			; flag -ve number
 6436/    251A : 177C 0000 0595         	MOVE.b	#0,FAC1_s(a3)			; take absolute value
 6437/    2520 :                        LAB_EXPS
 6438/    2520 :                        								; now do n/LOG(2)
 6439/    2520 : 277C B8AA 3B29 0598    	MOVE.l	#$B8AA3B29,FAC2_m(a3)		; 1/LOG(2) mantissa
 6440/    2528 : 377C 8100 059C         	MOVE.w	#$8100,FAC2_e(a3)			; 1/LOG(2) exponent & sign
 6441/    252E : 177C 0000 059E         	MOVE.b	#0,FAC_sc(a3)			; we know they're both +ve
 6442/    2534 : 6100 FA0E              	BSR		LAB_MULTIPLY			; effectively divide by log(2)
 6443/    2538 :                        
 6444/    2538 :                        								; max here is +/- 127
 6445/    2538 :                        								; now separate integer and fraction
 6446/    2538 : 177C 0000 05D9         	MOVE.b	#0,tpower(a3)			; clear exponent add byte
 6447/    253E : 1A2B 0594              	MOVE.b	FAC1_e(a3),d5			; get exponent
 6448/    2542 : 9A3C 0080              	SUB.b		#$80,d5				; normalise
 6449/    2546 : 6324                   	BLS.s		LAB_ESML				; branch if < 1 (d5 is 0 or -ve)
 6450/    2548 :                        
 6451/    2548 :                        								; result is > 1
 6452/    2548 : 202B 0590              	MOVE.l	FAC1_m(a3),d0			; get mantissa
 6453/    254C : 2200                   	MOVE.l	d0,d1					; copy it
 6454/    254E : 2C05                   	MOVE.l	d5,d6					; copy normalised exponent
 6455/    2550 :                        
 6456/    2550 : 4446                   	NEG.w		d6					; make -ve
 6457/    2552 : DC7C 0020              	ADD.w		#32,d6				; is now 32-d6
 6458/    2556 : ECA9                   	LSR.l		d6,d1					; just integer bits
 6459/    2558 : 1741 05D9              	MOVE.b	d1,tpower(a3)			; set exponent add byte
 6460/    255C :                        
 6461/    255C : EBA8                   	LSL.l		d5,d0					; shift out integer bits
 6462/    255E : 6700 FF68              	BEQ		LAB_EXOF				; fraction is zero so do 2^n
 6463/    2562 :                        
 6464/    2562 : 2740 0590              	MOVE.l	d0,FAC1_m(a3)			; fraction to FAC1
 6465/    2566 : 377C 8000 0594         	MOVE.w	#$8000,FAC1_e(a3)			; set exponent & sign
 6466/    256C :                        
 6467/    256C :                        								; multiple was < 1
 6468/    256C :                        LAB_ESML
 6469/    256C : 277C B172 17F8 0598    	MOVE.l	#$B17217F8,FAC2_m(a3)		; LOG(2) mantissa
 6470/    2574 : 377C 8000 059C         	MOVE.w	#$8000,FAC2_e(a3)			; LOG(2) exponent & sign
 6471/    257A : 177C 0000 059E         	MOVE.b	#0,FAC_sc(a3)			; clear sign compare
 6472/    2580 : 6100 F9C2              	BSR		LAB_MULTIPLY			; multiply by log(2)
 6473/    2584 :                        
 6474/    2584 : 202B 0590              	MOVE.l	FAC1_m(a3),d0			; get mantissa
 6475/    2588 : 1A2B 0594              	MOVE.b	FAC1_e(a3),d5			; get exponent
 6476/    258C : 9A7C 0082              	SUB.w		#$82,d5				; normalise and -2 (result is -1 to -30)
 6477/    2590 : 4445                   	NEG.w		d5					; make +ve
 6478/    2592 : EAA8                   	LSR.l		d5,d0					; shift for 2 integer bits
 6479/    2594 :                        
 6480/    2594 :                        ; d0 = arg
 6481/    2594 :                        ; d6 = x, d1 = y
 6482/    2594 :                        ; d2 = x1, d3 = y1
 6483/    2594 :                        ; d4 = shift count
 6484/    2594 :                        ; d5 = loop count
 6485/    2594 :                        								; now do cordic set-up
 6486/    2594 : 7200                   	MOVEQ		#0,d1					; y = 0
 6487/    2596 : 2C3C 26A3 D110         	MOVE.l	#KFCTSEED,d6			; x = 1 with jkh inverse factored out
 6488/    259C : 41FA 0D2C              	LEA		TAB_HTHET(pc),a0			; get pointer to hyperbolic arctan table
 6489/    25A0 : 7800                   	MOVEQ		#0,d4					; clear shift count
 6490/    25A2 :                         
 6491/    25A2 :                        								; cordic loop, shifts 4 and 13 (and 39
 6492/    25A2 :                        								; if it went that far) need to be repeated
 6493/    25A2 : 7A03                   	MOVEQ		#3,d5					; 4 loops
 6494/    25A4 : 6136                   	BSR.s		LAB_EXCC				; do loops 1 through 4
 6495/    25A6 : 5948                   	SUBQ.w	#4,a0					; do table entry again
 6496/    25A8 : 5384                   	SUBQ.l	#1,d4					; do shift count again
 6497/    25AA : 7A09                   	MOVEQ		#9,d5					; 10 loops
 6498/    25AC : 612E                   	BSR.s		LAB_EXCC				; do loops 4 (again) through 13
 6499/    25AE : 5948                   	SUBQ.w	#4,a0					; do table entry again
 6500/    25B0 : 5384                   	SUBQ.l	#1,d4					; do shift count again
 6501/    25B2 : 7A12                   	MOVEQ		#18,d5				; 19 loops
 6502/    25B4 : 6126                   	BSR.s		LAB_EXCC				; do loops 13 (again) through 31
 6503/    25B6 :                         
 6504/    25B6 :                        								; now get the result
 6505/    25B6 : 4A2B 05B4              	TST.b		cosout(a3)				; test sign flag
 6506/    25BA : 6A06                   	BPL.s		LAB_EXPL				; branch if +ve
 6507/    25BC :                        
 6508/    25BC : 4481                   	NEG.l		d1					; do -y
 6509/    25BE : 442B 05D9              	NEG.b		tpower(a3)				; do -exp
 6510/    25C2 :                        LAB_EXPL
 6511/    25C2 : 7083                   	MOVEQ		#$83-$100,d0			; set exponent
 6512/    25C4 : DC81                   	ADD.l		d1,d6					; y = y +/- x
 6513/    25C6 : 6B06                   	BMI.s		LAB_EXRN				; branch if result normal
 6514/    25C8 :                        
 6515/    25C8 :                        LAB_EXNN
 6516/    25C8 : 5380                   	SUBQ.l	#1,d0					; decrement exponent
 6517/    25CA : DC86                   	ADD.l		d6,d6					; shift mantissa
 6518/    25CC : 6AFA                   	BPL.s		LAB_EXNN				; loop if not normal
 6519/    25CE :                        
 6520/    25CE :                        LAB_EXRN
 6521/    25CE : 2746 0590              	MOVE.l	d6,FAC1_m(a3)			; save exponent result
 6522/    25D2 : D02B 05D9              	ADD.b		tpower(a3),d0			; add integer part
 6523/    25D6 : 1740 0594              	MOVE.b	d0,FAC1_e(a3)			; save exponent
 6524/    25DA :                        ;	MOVEM.l	(sp)+,d1-d6/a0			; restore registers
 6525/    25DA : 4E75                   	RTS
 6526/    25DC :                         
 6527/    25DC :                        								; cordic loop
 6528/    25DC :                        LAB_EXCC
 6529/    25DC : 5284                   	ADDQ.l	#1,d4					; increment shift count
 6530/    25DE : 2406                   	MOVE.l	d6,d2					; x1 = x
 6531/    25E0 : E8A2                   	ASR.l		d4,d2					; x1 >> n
 6532/    25E2 : 2601                   	MOVE.l	d1,d3					; y1 = y
 6533/    25E4 : E8A3                   	ASR.l		d4,d3					; y1 >> n
 6534/    25E6 : 4A80                   	TST.l		d0					; test arg
 6535/    25E8 : 6B0C                   	BMI.s		LAB_EXAD				; branch if -ve
 6536/    25EA :                        
 6537/    25EA : D282                   	ADD.l		d2,d1					; y = y + x1
 6538/    25EC : DC83                   	ADD.l		d3,d6					; x = x + y1
 6539/    25EE : 9098                   	SUB.l		(a0)+,d0				; arg = arg - atnh(a0)
 6540/    25F0 : 51CD FFEA              	DBF		d5,LAB_EXCC				; decrement and loop if not done
 6541/    25F4 :                        
 6542/    25F4 : 4E75                   	RTS
 6543/    25F6 :                        
 6544/    25F6 :                        LAB_EXAD
 6545/    25F6 : 9282                   	SUB.l		d2,d1					; y = y - x1
 6546/    25F8 : 9C83                   	SUB.l		d3,d6					; x = x + y1
 6547/    25FA : D098                   	ADD.l		(a0)+,d0				; arg = arg + atnh(a0)
 6548/    25FC : 51CD FFDE              	DBF		d5,LAB_EXCC				; decrement and loop if not done
 6549/    2600 :                        
 6550/    2600 : 4E75                   	RTS
 6551/    2602 :                        
 6552/    2602 :                        
 6553/    2602 :                        ;************************************************************************************
 6554/    2602 :                        ;
 6555/    2602 :                        ; RND(n), 32 bit Galois version. make n=0 for 19th next number in sequence or n<>0
 6556/    2602 :                        ; to get 19th next number in sequence after seed n. This version of the PRNG uses
 6557/    2602 :                        ; the Galois method and a sample of 65536 bytes produced gives the following values.
 6558/    2602 :                        
 6559/    2602 :                        ; Entropy = 7.997442 bits per byte
 6560/    2602 :                        ; Optimum compression would reduce these 65536 bytes by 0 percent
 6561/    2602 :                        
 6562/    2602 :                        ; Chi square distribution for 65536 samples is 232.01, and
 6563/    2602 :                        ; randomly would exceed this value 75.00 percent of the time
 6564/    2602 :                        
 6565/    2602 :                        ; Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
 6566/    2602 :                        ; Monte Carlo value for Pi is 3.122871269, error 0.60 percent
 6567/    2602 :                        ; Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
 6568/    2602 :                        
 6569/    2602 :                        LAB_RND
 6570/    2602 : 4A2B 0594              	TST.b		FAC1_e(a3)				; get FAC1 exponent
 6571/    2606 : 6708                   	BEQ.s		NextPRN				; do next random number if zero
 6572/    2608 :                        
 6573/    2608 :                        								; else get seed into random number store
 6574/    2608 : 41EB 05A0              	LEA		PRNlword(a3),a0			; set PRNG pointer
 6575/    260C : 6100 FAAA              	BSR		LAB_2778				; pack FAC1 into (a0)
 6576/    2610 :                        NextPRN
 6577/    2610 : 72AF                   	MOVEQ		#$AF-$100,d1			; set EOR value
 6578/    2612 : 7412                   	MOVEQ		#18,d2				; do this 19 times
 6579/    2614 : 202B 05A0              	MOVE.l	PRNlword(a3),d0			; get current
 6580/    2618 :                        Ninc0
 6581/    2618 : D080                   	ADD.l		d0,d0					; shift left 1 bit
 6582/    261A : 6402                   	BCC.s		Ninc1					; branch if bit 32 not set
 6583/    261C :                        
 6584/    261C : B300                   	EOR.b		d1,d0					; do Galois LFSR feedback
 6585/    261E :                        Ninc1
 6586/    261E : 51CA FFF8              	DBF		d2,Ninc0				; loop
 6587/    2622 :                        
 6588/    2622 : 2740 05A0              	MOVE.l	d0,PRNlword(a3)			; save back to seed word
 6589/    2626 : 2740 0590              	MOVE.l	d0,FAC1_m(a3)			; copy to FAC1 mantissa
 6590/    262A : 377C 8000 0594         	MOVE.w	#$8000,FAC1_e(a3)			; set the exponent and clear the sign
 6591/    2630 : 6000 F7EA              	BRA		LAB_24D5				; normalise FAC1 & return
 6592/    2634 :                        
 6593/    2634 :                        
 6594/    2634 :                        ;************************************************************************************
 6595/    2634 :                        ;
 6596/    2634 :                        ; cordic TAN(x) routine, TAN(x) = SIN(x)/COS(x)
 6597/    2634 :                        ; x = angle in radians
 6598/    2634 :                        
 6599/    2634 :                        LAB_TAN
 6600/    2634 : 6138                   	BSR.s		LAB_SIN				; go do SIN/COS cordic compute
 6601/    2636 : 376B 0594 059C         	MOVE.w	FAC1_e(a3),FAC2_e(a3)		; copy exponent & sign from FAC1 to FAC2
 6602/    263C : 276B 0590 0598         	MOVE.l	FAC1_m(a3),FAC2_m(a3)		; copy FAC1 mantissa to FAC2 mantissa
 6603/    2642 : 2741 0590              	MOVE.l	d1,FAC1_m(a3)			; get COS(x) mantissa
 6604/    2646 : 1743 0594              	MOVE.b	d3,FAC1_e(a3)			; get COS(x) exponent
 6605/    264A : 6700 E01A              	BEQ		LAB_OFER				; do overflow if COS = 0
 6606/    264E :                        
 6607/    264E : 6100 F7CC              	BSR		LAB_24D5				; normalise FAC1
 6608/    2652 : 6000 F97C              	BRA		LAB_DIVIDE				; do FAC2/FAC1 and return, FAC_sc set by SIN
 6609/    2656 :                        								; COS calculation
 6610/    2656 :                        
 6611/    2656 :                        
 6612/    2656 :                        ;************************************************************************************
 6613/    2656 :                        ;
 6614/    2656 :                        ; cordic SIN(x), COS(x) routine
 6615/    2656 :                        ; x = angle in radians
 6616/    2656 :                        
 6617/    2656 :                        LAB_COS
 6618/    2656 : 277C C90F DAA3 0598    	MOVE.l	#$C90FDAA3,FAC2_m(a3)		; pi/2 mantissa (LSB is rounded up so
 6619/    265E :                        								; COS(PI/2)=0)
 6620/    265E : 377C 8100 059C         	MOVE.w	#$8100,FAC2_e(a3)			; pi/2 exponent and sign
 6621/    2664 : 176B 0595 059E         	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; sign = FAC1 sign (b7)
 6622/    266A : 6100 F734              	BSR		LAB_ADD				; add FAC2 to FAC1, adjust for COS(x)
 6623/    266E :                        
 6624/    266E :                        
 6625/    266E :                        ;************************************************************************************
 6626/    266E :                        ;
 6627/    266E :                        ; SIN/COS cordic calculator
 6628/    266E :                        
 6629/    266E :                        LAB_SIN
 6630/    266E : 177C 0000 05B4         	MOVE.b	#0,cosout(a3)			; set needed result
 6631/    2674 :                        
 6632/    2674 : 277C A2F9 836F 0598    	MOVE.l	#$A2F9836F,FAC2_m(a3)		; 1/pi mantissa (LSB is rounded up so SIN(PI)=0)
 6633/    267C : 377C 7F00 059C         	MOVE.w	#$7F00,FAC2_e(a3)			; 1/pi exponent & sign
 6634/    2682 : 176B 0595 059E         	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; sign = FAC1 sign (b7)
 6635/    2688 : 6100 F8BA              	BSR		LAB_MULTIPLY			; multiply by 1/pi
 6636/    268C :                        
 6637/    268C : 102B 0594              	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
 6638/    2690 : 671C                   	BEQ.s		LAB_SCZE				; branch if zero
 6639/    2692 :                        
 6640/    2692 : 41FA 0B36              	LEA		TAB_SNCO(pc),a0			; get pointer to constants table
 6641/    2696 : 2C2B 0590              	MOVE.l	FAC1_m(a3),d6			; get FAC1 mantissa
 6642/    269A : 5300                   	SUBQ.b	#1,d0					; 2 radians in 360 degrees so /2
 6643/    269C : 6710                   	BEQ.s		LAB_SCZE				; branch if zero
 6644/    269E :                        
 6645/    269E : 903C 0080              	SUB.b		#$80,d0				; normalise exponent
 6646/    26A2 : 6B18                   	BMI.s		LAB_SCL0				; branch if < 1
 6647/    26A4 :                        
 6648/    26A4 :                        								; X is > 1
 6649/    26A4 : B03C 0020              	CMP.b		#$20,d0				; is it >= 2^32
 6650/    26A8 : 6404                   	BCC.s		LAB_SCZE				; may as well do zero
 6651/    26AA :                        
 6652/    26AA : E1AE                   	LSL.l		d0,d6					; shift out integer part bits
 6653/    26AC : 6618                   	BNE.s		LAB_CORD				; if fraction go test quadrant and adjust
 6654/    26AE :                        
 6655/    26AE :                        								; else no fraction so do zero
 6656/    26AE :                        LAB_SCZE
 6657/    26AE : 7481                   	MOVEQ		#$81-$100,d2			; set exponent for 1.0
 6658/    26B0 : 7600                   	MOVEQ		#0,d3					; set exponent for 0.0
 6659/    26B2 : 203C 8000 0000         	MOVE.l	#$80000000,d0			; mantissa for 1.0
 6660/    26B8 : 2203                   	MOVE.l	d3,d1					; mantissa for 0.0
 6661/    26BA : 6062                   	BRA.s		outloop				; go output it
 6662/    26BC :                        
 6663/    26BC :                        								; x is < 1
 6664/    26BC :                        LAB_SCL0
 6665/    26BC : 4400                   	NEG.b		d0					; make +ve
 6666/    26BE : B03C 001E              	CMP.b		#$1E,d0				; is it <= 2^-30
 6667/    26C2 : 64EA                   	BCC.s		LAB_SCZE				; may as well do zero
 6668/    26C4 :                        
 6669/    26C4 : E0AE                   	LSR.l		d0,d6					; shift out <= 2^-32 bits
 6670/    26C6 :                        
 6671/    26C6 :                        ; cordic calculator, argument in d6
 6672/    26C6 :                        ; table pointer in a0, returns in d0-d3
 6673/    26C6 :                        
 6674/    26C6 :                        LAB_CORD
 6675/    26C6 : 176B 0595 059E         	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; copy as sign compare for TAN
 6676/    26CC : DC86                   	ADD.l		d6,d6					; shift 0.5 bit into carry
 6677/    26CE : 6406                   	BCC.s		LAB_LTPF				; branch if less than 0.5
 6678/    26D0 :                        
 6679/    26D0 : 0A2B 00FF 0595         	EORI.b	#$FF,FAC1_s(a3)			; toggle result sign
 6680/    26D6 :                        LAB_LTPF
 6681/    26D6 : DC86                   	ADD.l		d6,d6					; shift 0.25 bit into carry
 6682/    26D8 : 640C                   	BCC.s		LAB_LTPT				; branch if less than 0.25
 6683/    26DA :                        
 6684/    26DA : 0A2B 00FF 05B4         	EORI.b	#$FF,cosout(a3)			; toggle needed result
 6685/    26E0 : 0A2B 00FF 059E         	EORI.b	#$FF,FAC_sc(a3)			; toggle sign compare for TAN
 6686/    26E6 :                        
 6687/    26E6 :                        LAB_LTPT
 6688/    26E6 : E48E                   	LSR.l		#2,d6					; shift the bits back (clear integer bits)
 6689/    26E8 : 67C4                   	BEQ.s		LAB_SCZE				; no fraction so go do zero
 6690/    26EA :                        
 6691/    26EA :                        								; set start values
 6692/    26EA : 7A01                   	MOVEQ		#1,d5					; set bit count
 6693/    26EC : 2028 FFFC              	MOVE.l	-4(a0),d0				; get multiply constant (1st itteration d0)
 6694/    26F0 : 2200                   	MOVE.l	d0,d1					; 1st itteration d1
 6695/    26F2 : 9C98                   	SUB.l		(a0)+,d6				; 1st always +ve so do 1st step
 6696/    26F4 : 6008                   	BRA.s		mainloop				; jump into routine
 6697/    26F6 :                        
 6698/    26F6 :                        subloop
 6699/    26F6 : 9C98                   	SUB.l		(a0)+,d6				; z = z - arctan(i)/2pi
 6700/    26F8 : 9083                   	SUB.l		d3,d0					; x = x - y1
 6701/    26FA : D282                   	ADD.l		d2,d1					; y = y + x1
 6702/    26FC : 6012                   	BRA.s		nexta					; back to main loop
 6703/    26FE :                        
 6704/    26FE :                        mainloop
 6705/    26FE : 2400                   	MOVE.l	d0,d2					; x1 = x
 6706/    2700 : EAA2                   	ASR.l		d5,d2					; / (2 ^ i)
 6707/    2702 : 2601                   	MOVE.l	d1,d3					; y1 = y
 6708/    2704 : EAA3                   	ASR.l		d5,d3					; / (2 ^ i)
 6709/    2706 : 4A86                   	TST.l		d6					; test sign (is 2^0 bit)
 6710/    2708 : 6AEC                   	BPL.s		subloop				; go do subtract if > 1
 6711/    270A :                        
 6712/    270A : DC98                   	ADD.l		(a0)+,d6				; z = z + arctan(i)/2pi
 6713/    270C : D083                   	ADD.l		d3,d0					; x = x + y1
 6714/    270E : 9282                   	SUB.l		d2,d1					; y = y + x1
 6715/    2710 :                        nexta
 6716/    2710 : 5285                   	ADDQ.l	#1,d5					; i = i + 1
 6717/    2712 : BABC 0000 001E         	CMP.l		#$1E,d5				; check end condition
 6718/    2718 : 66E4                   	BNE.s		mainloop				; loop if not all done
 6719/    271A :                        
 6720/    271A :                        								; now untangle output value
 6721/    271A : 7481                   	MOVEQ		#$81-$100,d2			; set exponent for 0 to .99 rec.
 6722/    271C : 2602                   	MOVE.l	d2,d3					; copy it for cos output
 6723/    271E :                        outloop
 6724/    271E : 4A2B 05B4              	TST.b		cosout(a3)				; did we want cos output?
 6725/    2722 : 6B04                   	BMI.s		subexit				; if so skip
 6726/    2724 :                        
 6727/    2724 : C141                   	EXG		d0,d1					; swap SIN and COS mantissas
 6728/    2726 : C543                   	EXG		d2,d3					; swap SIN and COS exponents
 6729/    2728 :                        subexit
 6730/    2728 : 2740 0590              	MOVE.l	d0,FAC1_m(a3)			; set result mantissa
 6731/    272C : 1742 0594              	MOVE.b	d2,FAC1_e(a3)			; set result exponent
 6732/    2730 : 6000 F6EA              	BRA		LAB_24D5				; normalise FAC1 & return
 6733/    2734 :                        
 6734/    2734 :                        
 6735/    2734 :                        
 6736/    2734 :                        ;************************************************************************************
 6737/    2734 :                        ;
 6738/    2734 :                        ; perform ATN()
 6739/    2734 :                        
 6740/    2734 :                        LAB_ATN
 6741/    2734 : 102B 0594              	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
 6742/    2738 : 6700 00AC              	BEQ		RTS_021				; ATN(0) = 0 so skip calculation
 6743/    273C :                        
 6744/    273C : 177C 0000 05B4         	MOVE.b	#0,cosout(a3)			; set result needed
 6745/    2742 : B03C 0081              	CMP.b		#$81,d0				; compare exponent with 1
 6746/    2746 : 6528                   	BCS.s		LAB_ATLE				; branch if n<1
 6747/    2748 :                        
 6748/    2748 : 6608                   	BNE.s		LAB_ATGO				; branch if n>1
 6749/    274A :                        
 6750/    274A : 202B 0590              	MOVE.l	FAC1_m(a3),d0			; get mantissa
 6751/    274E : D080                   	ADD.l		d0,d0					; shift left
 6752/    2750 : 671E                   	BEQ.s		LAB_ATLE				; branch if n=1
 6753/    2752 :                        
 6754/    2752 :                        LAB_ATGO
 6755/    2752 : 277C 8000 0000 0598    	MOVE.l	#$80000000,FAC2_m(a3)		; set mantissa for 1
 6756/    275A : 377C 8100 059C         	MOVE.w	#$8100,FAC2_e(a3)			; set exponent for 1
 6757/    2760 : 176B 0595 059E         	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; sign compare = sign
 6758/    2766 : 6100 F868              	BSR		LAB_DIVIDE				; do 1/n
 6759/    276A : 177C 00FF 05B4         	MOVE.b	#$FF,cosout(a3)			; set inverse result needed
 6760/    2770 :                        LAB_ATLE
 6761/    2770 : 202B 0590              	MOVE.l	FAC1_m(a3),d0			; get FAC1 mantissa
 6762/    2774 : 123C 0082              	MOVE.b		#$82,d1				; set to correct exponent
 6763/    2778 : 922B 0594              	SUB.b		FAC1_e(a3),d1			; subtract FAC1 exponent (always <= 1)
 6764/    277C : E2A8                   	LSR.l		d1,d0					; shift in two integer part bits
 6765/    277E : 41FA 0ACA              	LEA		TAB_ATNC(pc),a0			; get pointer to arctan table
 6766/    2782 : 7C00                   	MOVEQ		#0,d6					; Z = 0
 6767/    2784 : 223C 4000 0000         	MOVE.l	#1<<30,d1				; y = 1
 6768/    278A : 7A1D                   	MOVEQ		#29,d5				; loop 30 times
 6769/    278C : 7801                   	MOVEQ		#1,d4					; shift counter
 6770/    278E : 6006                   	BRA.s		LAB_ATCD				; enter loop
 6771/    2790 :                        
 6772/    2790 :                        LAB_ATNP
 6773/    2790 : E8A2                   	ASR.l		d4,d2					; x1 / 2^i
 6774/    2792 : D282                   	ADD.l		d2,d1					; y = y + x1
 6775/    2794 : DC90                   	ADD.l		(a0),d6				; z = z + atn(i)
 6776/    2796 :                        LAB_ATCD
 6777/    2796 : 2400                   	MOVE.l	d0,d2					; x1 = x
 6778/    2798 : 2601                   	MOVE.l	d1,d3					; y1 = y
 6779/    279A : E8A3                   	ASR.l		d4,d3					; y1 / 2^i
 6780/    279C :                        LAB_CATN
 6781/    279C : 9083                   	SUB.l		d3,d0					; x = x - y1
 6782/    279E : 6AF0                   	BPL.s		LAB_ATNP				; branch if x >= 0
 6783/    27A0 :                        
 6784/    27A0 : 2002                   	MOVE.l	d2,d0					; else get x back
 6785/    27A2 : 5848                   	ADDQ.w	#4,a0					; increment pointer
 6786/    27A4 : 5284                   	ADDQ.l	#1,d4					; increment i
 6787/    27A6 : E283                   	ASR.l		#1,d3					; y1 / 2^i
 6788/    27A8 : 51CD FFF2              	DBF		d5,LAB_CATN				; decrement and loop if not done
 6789/    27AC :                        
 6790/    27AC : 177C 0082 0594         	MOVE.b	#$82,FAC1_e(a3)			; set new exponent
 6791/    27B2 : 2746 0590              	MOVE.l	d6,FAC1_m(a3)			; save mantissa
 6792/    27B6 : 6100 F664              	BSR		LAB_24D5				; normalise FAC1
 6793/    27BA :                        
 6794/    27BA : 4A2B 05B4              	TST.b		cosout(a3)				; was it > 1 ?
 6795/    27BE : 6A26                   	BPL.s		RTS_021				; branch if not
 6796/    27C0 :                        
 6797/    27C0 : 1E2B 0595              	MOVE.b	FAC1_s(a3),d7			; get sign
 6798/    27C4 : 177C 0000 0595         	MOVE.b	#0,FAC1_s(a3)			; clear sign
 6799/    27CA : 277C C90F DAA2 0598    	MOVE.l	#$C90FDAA2,FAC2_m(a3)		; set -(pi/2)
 6800/    27D2 : 377C 8180 059C         	MOVE.w	#$8180,FAC2_e(a3)			; set exponent and sign
 6801/    27D8 : 177C 00FF 059E         	MOVE.b	#$FF,FAC_sc(a3)			; set sign compare
 6802/    27DE : 6100 F5C0              	BSR		LAB_ADD				; perform addition, FAC2 to FAC1
 6803/    27E2 : 1747 0595              	MOVE.b	d7,FAC1_s(a3)			; restore sign
 6804/    27E6 :                        RTS_021
 6805/    27E6 : 4E75                   	RTS
 6806/    27E8 :                        
 6807/    27E8 :                        
 6808/    27E8 :                        ;************************************************************************************
 6809/    27E8 :                        ;
 6810/    27E8 :                        ; perform BITSET
 6811/    27E8 :                        
 6812/    27E8 :                        LAB_BITSET
 6813/    27E8 : 6100 F496              	BSR		LAB_GADB				; get two parameters for POKE or WAIT
 6814/    27EC :                        								; first parameter in a0, second in d0
 6815/    27EC : B03C 0008              	CMP.b		#$08,d0				; only 0 to 7 are allowed
 6816/    27F0 : 6400 DE78              	BCC		LAB_FCER				; branch if > 7
 6817/    27F4 :                        
 6818/    27F4 : 01D0                   	BSET		d0,(a0)				; set bit
 6819/    27F6 : 4E75                   	RTS
 6820/    27F8 :                        
 6821/    27F8 :                        
 6822/    27F8 :                        ;************************************************************************************
 6823/    27F8 :                        ;
 6824/    27F8 :                        ; perform BITCLR
 6825/    27F8 :                        
 6826/    27F8 :                        LAB_BITCLR
 6827/    27F8 : 6100 F486              	BSR		LAB_GADB				; get two parameters for POKE or WAIT
 6828/    27FC :                        								; first parameter in a0, second in d0
 6829/    27FC : B03C 0008              	CMP.b		#$08,d0				; only 0 to 7 are allowed
 6830/    2800 : 6400 DE68              	BCC		LAB_FCER				; branch if > 7
 6831/    2804 :                        
 6832/    2804 : 0190                   	BCLR		d0,(a0)				; clear bit
 6833/    2806 : 4E75                   	RTS
 6834/    2808 :                        
 6835/    2808 :                        
 6836/    2808 :                        ;************************************************************************************
 6837/    2808 :                        ;
 6838/    2808 :                        ; perform BITTST()
 6839/    2808 :                        
 6840/    2808 :                        LAB_BTST
 6841/    2808 : 101D                   	MOVE.b	(a5)+,d0				; increment BASIC pointer
 6842/    280A : 6100 F474              	BSR		LAB_GADB				; get two parameters for POKE or WAIT
 6843/    280E :                        								; first parameter in a0, second in d0
 6844/    280E : B03C 0008              	CMP.b		#$08,d0				; only 0 to 7 are allowed
 6845/    2812 : 6400 DE56              	BCC		LAB_FCER				; branch if > 7
 6846/    2816 :                        
 6847/    2816 : 2200                   	MOVE.l	d0,d1					; copy bit # to test
 6848/    2818 : 6100 EAA4              	BSR		LAB_GBYT				; get next BASIC byte
 6849/    281C : B03C 0029              	CMP.b		#')',d0				; is next character ")"
 6850/    2820 : 6600 DE54              	BNE		LAB_SNER				; if not ")" go do syntax error, then warm start
 6851/    2824 :                        
 6852/    2824 : 6100 EA96              	BSR		LAB_IGBY				; update execute pointer (to character past ")")
 6853/    2828 : 7000                   	MOVEQ		#0,d0					; set the result as zero
 6854/    282A : 0310                   	BTST		d1,(a0)				; test bit
 6855/    282C : 6700 F904              	BEQ		LAB_27DB				; branch if zero (already correct)
 6856/    2830 :                        
 6857/    2830 : 70FF                   	MOVEQ		#-1,d0				; set for -1 result
 6858/    2832 : 6000 F8FE              	BRA		LAB_27DB				; go do SGN tail
 6859/    2836 :                        
 6860/    2836 :                        
 6861/    2836 :                        ;************************************************************************************
 6862/    2836 :                        ;
 6863/    2836 :                        ; perform USING$()
 6864/    2836 :                        
 6865/    2836 : =$0                    fsd		EQU	 0						;   (sp) format string descriptor pointer
 6866/    2836 : =$4                    fsti	EQU	 4						;  4(sp) format string this index
 6867/    2836 : =$6                    fsli	EQU	 6						;  6(sp) format string last index
 6868/    2836 : =$8                    fsdpi	EQU	 8						;  8(sp) format string decimal point index
 6869/    2836 : =$A                    fsdc	EQU	10						; 10(sp) format string decimal characters
 6870/    2836 : =$8                    fend	EQU	12-4						;  x(sp) end-4, fsd is popped by itself
 6871/    2836 :                        
 6872/    2836 : ='#'                   ofchr	EQU	'#'						; the overflow character
 6873/    2836 :                        
 6874/    2836 :                        LAB_USINGS
 6875/    2836 : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type, $80=string
 6876/    283A : 6A00 DDE6              	BPL		LAB_FOER				; if not string type go do format error
 6877/    283E :                        
 6878/    283E : 246B 0590              	MOVEA.l	FAC1_m(a3),a2			; get the format string descriptor pointer
 6879/    2842 : 3E2A 0004              	MOVE.w	4(a2),d7				; get the format string length
 6880/    2846 : 6700 DDDA              	BEQ		LAB_FOER				; if null string go do format error
 6881/    284A :                        
 6882/    284A :                        ; clear the format string values
 6883/    284A :                        
 6884/    284A : 7000                   	MOVEQ		#0,d0					; clear d0
 6885/    284C : 3F00                   	MOVE.w	d0,-(sp)				; clear the format string decimal characters
 6886/    284E : 3F00                   	MOVE.w	d0,-(sp)				; clear the format string decimal point index
 6887/    2850 : 3F00                   	MOVE.w	d0,-(sp)				; clear the format string last index
 6888/    2852 : 3F00                   	MOVE.w	d0,-(sp)				; clear the format string this index
 6889/    2854 : 2F0A                   	MOVE.l	a2,-(sp)				; save the format string descriptor pointer
 6890/    2856 :                        
 6891/    2856 :                        ; make a null return string for the first string add
 6892/    2856 :                        
 6893/    2856 : 7200                   	MOVEQ		#0,d1					; make a null string
 6894/    2858 : 2041                   	MOVEA.l	d1,a0					; with a null pointer
 6895/    285A : 6100 F0BE              	BSR		LAB_RTST				; push a string on the descriptor stack
 6896/    285E :                        								; a0 = pointer, d1 = length
 6897/    285E :                        
 6898/    285E :                        ; do the USING$() function next value
 6899/    285E :                        
 6900/    285E : 101D                   	MOVE.b	(a5)+,d0				; get the next BASIC byte
 6901/    2860 :                        LAB_U002
 6902/    2860 : B03C 002C              	CMP.b		#',',d0				; compare with comma
 6903/    2864 : 6600 DE10              	BNE		LAB_SNER				; if not "," go do syntax error
 6904/    2868 :                        
 6905/    2868 : 6100 028E              	BSR		LAB_ProcFo				; process the format string
 6906/    286C : 4A02                   	TST.b		d2					; test the special characters flag
 6907/    286E : 6700 DDB2              	BEQ		LAB_FOER				; if no special characters go do format error
 6908/    2872 :                        
 6909/    2872 : 6100 E8E8              	BSR		LAB_EVEX				; evaluate the expression
 6910/    2876 : 4A2B 05B5              	TST.b		Dtypef(a3)				; test the data type
 6911/    287A : 6B00 DDCE              	BMI		LAB_TMER				; if string type go do type missmatch error
 6912/    287E :                        
 6913/    287E : 4A2B 0594              	TST.b		FAC1_e(a3)				; test FAC1 exponent
 6914/    2882 : 6732                   	BEQ.s		LAB_U004				; if FAC1 = 0 skip the rounding
 6915/    2884 :                        
 6916/    2884 : 322F 000A              	MOVE.w	fsdc(sp),d1				; get the format string decimal character count
 6917/    2888 : B27C 0008              	CMP.w		#8,d1					; compare the fraction digit count with 8
 6918/    288C : 6428                   	BCC.s		LAB_U004				; if >= 8 skip the rounding
 6919/    288E :                        
 6920/    288E : 3001                   	MOVE.w	d1,d0					; else copy the fraction digit count
 6921/    2890 : D241                   	ADD.w		d1,d1					;	; 2
 6922/    2892 : D240                   	ADD.w		d0,d1					;	; 3
 6923/    2894 : D241                   	ADD.w		d1,d1					;	; 6
 6924/    2896 : 41FA 0844              	LEA		LAB_P_10(pc),a0			; get the rounding table base
 6925/    289A : 2770 1002 0598         	MOVE.l	2(a0,d1.w),FAC2_m(a3)		; get the rounding mantissa
 6926/    28A0 : 3030 1000              	MOVE.w	(a0,d1.w),d0			; get the rounding exponent
 6927/    28A4 : 907C 0100              	SUB.w		#$100,d0				; effectively divide the mantissa by 2
 6928/    28A8 : 3740 059C              	MOVE.w	d0,FAC2_e(a3)			; save the rounding exponent
 6929/    28AC : 177C 0000 059E         	MOVE.b	#$00,FAC_sc(a3)			; clear the sign compare
 6930/    28B2 : 6100 F4EC              	BSR		LAB_ADD				; round the value to n places
 6931/    28B6 :                        LAB_U004
 6932/    28B6 : 6100 F96A              	BSR		LAB_2970				; convert FAC1 to string - not on stack
 6933/    28BA :                        
 6934/    28BA : 6100 01FE              	BSR		LAB_DupFmt				; duplicate the processed format string section
 6935/    28BE :                        								; returns length in d1, pointer in a0
 6936/    28BE :                        
 6937/    28BE :                        ; process the number string, length in d6, decimal point index in d2
 6938/    28BE :                        
 6939/    28BE : 45EB 05C6              	LEA		Decss(a3),a2			; set the number string start
 6940/    28C2 : 7C00                   	MOVEQ		#0,d6					; clear the number string index
 6941/    28C4 : 782E                   	MOVEQ		#'.',d4				; set the decimal point character
 6942/    28C6 :                        LAB_U005
 6943/    28C6 : 3406                   	MOVE.w	d6,d2					; save the index to flag the decimal point
 6944/    28C8 :                        LAB_U006
 6945/    28C8 : 5246                   	ADDQ.w	#1,d6					; increment the number string index
 6946/    28CA : 1032 6000              	MOVE.b	(a2,d6.w),d0			; get a number string character
 6947/    28CE : 677A                   	BEQ.s		LAB_U010				; if null then number complete
 6948/    28D0 :                        
 6949/    28D0 : B03C 0045              	CMP.b		#'E',d0				; compare the character with an "E"
 6950/    28D4 : 6706                   	BEQ.s		LAB_U008				; was sx[.x]Esxx so go handle sci notation
 6951/    28D6 :                        
 6952/    28D6 : B004                   	CMP.b		d4,d0					; compare the character with "."
 6953/    28D8 : 66EE                   	BNE.s		LAB_U006				; if not decimal point go get the next digit
 6954/    28DA :                        
 6955/    28DA : 60EA                   	BRA.s		LAB_U005				; go save the index and get the next digit
 6956/    28DC :                        
 6957/    28DC :                        ; have found an sx[.x]Esxx number, the [.x] will not be present for a single digit
 6958/    28DC :                        
 6959/    28DC :                        LAB_U008
 6960/    28DC : 3606                   	MOVE.w	d6,d3					; copy the index to the "E"
 6961/    28DE : 5343                   	SUBQ.w	#1,d3					; -1 gives the last digit index
 6962/    28E0 :                        
 6963/    28E0 : 5246                   	ADDQ.w	#1,d6					; increment the index to the exponent sign
 6964/    28E2 : 1032 6000              	MOVE.b	(a2,d6.w),d0			; get the exponent sign character
 6965/    28E6 : B03C 002D              	CMP.b		#'-',d0				; compare the exponent sign with "-"
 6966/    28EA : 6600 DD7E              	BNE		LAB_FCER				; if it wasn't sx[.x]E-xx go do function
 6967/    28EE :                        								; call error
 6968/    28EE :                        
 6969/    28EE :                        ; found an sx[.x]E-xx number so check the exponent magnitude
 6970/    28EE :                        
 6971/    28EE : 5246                   	ADDQ.w	#1,d6					; increment the index to the exponent 10s
 6972/    28F0 : 1032 6000              	MOVE.b	(a2,d6.w),d0			; get the exponent 10s character
 6973/    28F4 : B03C 0030              	CMP.b		#'0',d0				; compare the exponent 10s with "0"
 6974/    28F8 : 6704                   	BEQ.s		LAB_U009				; if it was sx[.x]E-0x go get the exponent
 6975/    28FA :                        								; 1s character
 6976/    28FA :                        
 6977/    28FA : 700A                   	MOVEQ		#10,d0				; else start writing at index 10
 6978/    28FC : 6008                   	BRA.s		LAB_U00A				; go copy the digits
 6979/    28FE :                        
 6980/    28FE :                        ; found an sx[.x]E-0x number so get the exponent magnitude
 6981/    28FE :                        
 6982/    28FE :                        LAB_U009
 6983/    28FE : 5246                   	ADDQ.w	#1,d6					; increment the index to the exponent 1s
 6984/    2900 : 700F                   	MOVEQ		#$0F,d0				; set the mask for the exponent 1s digit
 6985/    2902 : C032 6000              	AND.b		(a2,d6.w),d0			; get and convert the exponent 1s digit
 6986/    2906 :                        LAB_U00A
 6987/    2906 : 3403                   	MOVE.w	d3,d2					; copy the number last digit index
 6988/    2908 : 0C42 0001              	CMPI.w	#1,d2					; is the number of the form sxE-0x
 6989/    290C : 6602                   	BNE.s		LAB_U00B				; if it is sx.xE-0x skip the increment
 6990/    290E :                        
 6991/    290E :                        								; else make room for the decimal point
 6992/    290E : 5242                   	ADDQ.w	#1,d2					; add 1 to the write index
 6993/    2910 :                        LAB_U00B
 6994/    2910 : D440                   	ADD.w		d0,d2					; add the exponent 1s to the write index
 6995/    2912 : 700A                   	MOVEQ		#10,d0				; set the maximum write index
 6996/    2914 : 9042                   	SUB.w		d2,d0					; compare the index with the maximum
 6997/    2916 : 6E0C                   	BGT.s		LAB_U00C				; if the index < the maximum continue
 6998/    2918 :                        
 6999/    2918 : D440                   	ADD.w		d0,d2					; else set the index to the maximum
 7000/    291A : D640                   	ADD.w		d0,d3					; adjust the read index
 7001/    291C : 0C43 0001              	CMPI.w	#1,d3					; compare the adjusted index with 1
 7002/    2920 : 6E02                   	BGT.s		LAB_U00C				; if > 1 continue
 7003/    2922 :                        
 7004/    2922 : 7600                   	MOVEQ		#0,d3					; else allow for the decimal point
 7005/    2924 :                        LAB_U00C
 7006/    2924 : 3C02                   	MOVE.w		d2,d6					; copy the write index as the number
 7007/    2926 :                        								; string length
 7008/    2926 : 7000                   	MOVEQ		#0,d0					; clear d0 to null terminate the number
 7009/    2928 :                        								; string
 7010/    2928 :                        LAB_U00D
 7011/    2928 : 1580 2000              	MOVE.b	d0,(a2,d2.w)			; save the character to the number string
 7012/    292C : 5342                   	SUBQ.w	#1,d2					; decrement the number write index
 7013/    292E : 0C42 0001              	CMPI.w	#1,d2					; compare the number write index with 1
 7014/    2932 : 6712                   	BEQ.s		LAB_U00F				; if at the decimal point go save it
 7015/    2934 :                        
 7016/    2934 :                        								; else write a digit to the number string
 7017/    2934 : 7030                   	MOVEQ		#'0',d0				; default to "0"
 7018/    2936 : 4A43                   	TST.w		d3					; test the number read index
 7019/    2938 : 67EE                   	BEQ.s		LAB_U00D				; if zero just go save the "0"
 7020/    293A :                        
 7021/    293A :                        LAB_U00E
 7022/    293A : 1032 3000              	MOVE.b	(a2,d3.w),d0			; read the next number digit
 7023/    293E : 5343                   	SUBQ.w	#1,d3					; decrement the read index
 7024/    2940 : B004                   	CMP.b		d4,d0					; compare the digit with "."
 7025/    2942 : 66E4                   	BNE.s		LAB_U00D				; if not "." go save the digit
 7026/    2944 :                        
 7027/    2944 : 60F4                   	BRA.s		LAB_U00E				; else go get the next digit
 7028/    2946 :                        
 7029/    2946 :                        LAB_U00F
 7030/    2946 : 1584 2000              	MOVE.b	d4,(a2,d2.w)			; save the decimal point
 7031/    294A :                        LAB_U010
 7032/    294A : 4A42                   	TST.w		d2					; test the number string decimal point index
 7033/    294C : 6602                   	BNE.s		LAB_U014				; if dp present skip the reset
 7034/    294E :                        
 7035/    294E : 3406                   	MOVE.w	d6,d2					; make the decimal point index = the length
 7036/    2950 :                        
 7037/    2950 :                        ; copy the fractional digit characters from the number string
 7038/    2950 :                        
 7039/    2950 :                        LAB_U014
 7040/    2950 : 3602                   	MOVE.w	d2,d3					; copy the number string decimal point index
 7041/    2952 : 5243                   	ADDQ.w	#1,d3					; increment the number string index
 7042/    2954 : 382F 0008              	MOVE.w	fsdpi(sp),d4			; get the new format string decimal point index
 7043/    2958 :                        LAB_U018
 7044/    2958 : 5244                   	ADDQ.w	#1,d4					; increment the new format string index
 7045/    295A : B244                   	CMP.w		d4,d1					; compare it with the new format string length
 7046/    295C : 6322                   	BLS.s		LAB_U022				; if done the fraction digits go do integer
 7047/    295E :                        
 7048/    295E : 1030 4000              	MOVE.b	(a0,d4.w),d0			; get a new format string character
 7049/    2962 : B03C 0025              	CMP.b		#'%',d0				; compare it with "%"
 7050/    2966 : 6706                   	BEQ.s		LAB_U01C				; if "%" go copy a number character
 7051/    2968 :                        
 7052/    2968 : B03C 0023              	CMP.b		#'#',d0				; compare it with "#"
 7053/    296C : 66EA                   	BNE.s		LAB_U018				; if not "#" go do the next new format character
 7054/    296E :                        
 7055/    296E :                        LAB_U01C
 7056/    296E : 7030                   	MOVEQ		#'0',d0				; default to "0" character
 7057/    2970 : BC43                   	CMP.w		d3,d6					; compare the number string index with length
 7058/    2972 : 6306                   	BLS.s		LAB_U020				; if there skip the character get
 7059/    2974 :                        
 7060/    2974 : 1032 3000              	MOVE.b	(a2,d3.w),d0			; get a character from the number string
 7061/    2978 : 5243                   	ADDQ.w	#1,d3					; increment the number string index
 7062/    297A :                        LAB_U020
 7063/    297A : 1180 4000              	MOVE.b	d0,(a0,d4.w)			; save the number character to the new format
 7064/    297E :                        								; string
 7065/    297E : 60D8                   	BRA.s		LAB_U018				; go do the next new format character
 7066/    2980 :                        
 7067/    2980 :                        ; now copy the integer digit characters from the number string
 7068/    2980 :                        
 7069/    2980 :                        LAB_U022
 7070/    2980 : 7C00                   	MOVEQ		#0,d6					; clear the sign done flag
 7071/    2982 : 7A00                   	MOVEQ		#0,d5					; clear the sign present flag
 7072/    2984 : 5342                   	SUBQ.w	#1,d2					; decrement the number string index
 7073/    2986 : 6608                   	BNE.s		LAB_U026				; if not now at sign continue
 7074/    2988 :                        
 7075/    2988 : 7401                   	MOVEQ		#1,d2					; increment the number string index
 7076/    298A : 15BC 0030 2000         	MOVE.b	#'0',(a2,d2.w)			; replace the point with a zero
 7077/    2990 :                        LAB_U026
 7078/    2990 : 382F 0008              	MOVE.w	fsdpi(sp),d4			; get the new format string decimal point index
 7079/    2994 : B244                   	CMP.w		d4,d1					; compare it with the new format string length
 7080/    2996 : 6402                   	BCC.s		LAB_U02A				; if within the string go use the index
 7081/    2998 :                        
 7082/    2998 : 3801                   	MOVE.w	d1,d4					; else set the index to the end of the string
 7083/    299A :                        LAB_U02A
 7084/    299A : 5344                   	SUBQ.w	#1,d4					; decrement the new format string index
 7085/    299C : 6B62                   	BMI.s		LAB_U03E				; if all done go test for any overflow
 7086/    299E :                        
 7087/    299E : 1030 4000              	MOVE.b	(a0,d4.w),d0			; else get a new format string character
 7088/    29A2 :                        
 7089/    29A2 : 7E30                   	MOVEQ		#'0',d7				; default to "0" character
 7090/    29A4 : B03C 0025              	CMP.b		#'%',d0				; compare it with "%"
 7091/    29A8 : 6708                   	BEQ.s		LAB_U02B				; if "%" go copy a number character
 7092/    29AA :                        
 7093/    29AA : 7E20                   	MOVEQ		#' ',d7				; default to " " character
 7094/    29AC : B03C 0023              	CMP.b		#'#',d0				; compare it with "#"
 7095/    29B0 : 6606                   	BNE.s		LAB_U02C				; if not "#" go try ","
 7096/    29B2 :                        
 7097/    29B2 :                        LAB_U02B
 7098/    29B2 : 4A42                   	TST.w		d2					; test the number string index
 7099/    29B4 : 6634                   	BNE.s		LAB_U036				; if not at the sign go get a number character
 7100/    29B6 :                        
 7101/    29B6 : 6042                   	BRA.s		LAB_U03C				; else go save the default character
 7102/    29B8 :                        
 7103/    29B8 :                        LAB_U02C
 7104/    29B8 : B03C 002C              	CMP.b		#',',d0				; compare it with ","
 7105/    29BC : 6610                   	BNE.s		LAB_U030				; if not "," go try the sign characters
 7106/    29BE :                        
 7107/    29BE : 4A42                   	TST.w		d2					; test the number string index
 7108/    29C0 : 6608                   	BNE.s		LAB_U02E				; if not at the sign keep the ","
 7109/    29C2 :                        
 7110/    29C2 : 0C30 0025 40FF         	CMP.b		#'%',-1(a0,d4.w)			; else compare the next format string character
 7111/    29C8 :                        								; with "%"
 7112/    29C8 : 6630                   	BNE.s		LAB_U03C				; if not "%" keep the default character
 7113/    29CA :                        
 7114/    29CA :                        LAB_U02E
 7115/    29CA : 1E00                   	MOVE.b	d0,d7					; else use the "," character
 7116/    29CC : 602C                   	BRA.s		LAB_U03C				; go save the character to the string
 7117/    29CE :                        
 7118/    29CE :                        LAB_U030
 7119/    29CE : B03C 002D              	CMP.b		#'-',d0				; compare it with "-"
 7120/    29D2 : 6710                   	BEQ.s		LAB_U034				; if "-" go do the sign character
 7121/    29D4 :                        
 7122/    29D4 : B03C 002B              	CMP.b		#'+',d0				; compare it with "+"
 7123/    29D8 : 66C0                   	BNE.s		LAB_U02A				; if not "+" go do the next new format character
 7124/    29DA :                        
 7125/    29DA : 0C12 002D              	CMP.b		#'-',(a2)				; compare the sign character with "-"
 7126/    29DE : 6704                   	BEQ.s		LAB_U034				; if "-" don't change the sign character
 7127/    29E0 :                        
 7128/    29E0 : 14BC 002B              	MOVE.b	#'+',(a2)				; else make the sign character "+"
 7129/    29E4 :                        LAB_U034
 7130/    29E4 : 1A00                   	MOVE.b	d0,d5					; set the sign present flag
 7131/    29E6 : 4A42                   	TST.w		d2					; test the number string index
 7132/    29E8 : 6708                   	BEQ.s		LAB_U038				; if at the sign keep the default character
 7133/    29EA :                        
 7134/    29EA :                        LAB_U036
 7135/    29EA : 1E32 2000              	MOVE.b	(a2,d2.w),d7			; else get a character from the number string
 7136/    29EE : 5342                   	SUBQ.w	#1,d2					; decrement the number string index
 7137/    29F0 : 6008                   	BRA.s		LAB_U03C				; go save the character
 7138/    29F2 :                        
 7139/    29F2 :                        LAB_U038
 7140/    29F2 : 4A06                   	TST.b		d6					; test the sign done flag
 7141/    29F4 : 6604                   	BNE.s		LAB_U03C				; if the sign has been done go use the space
 7142/    29F6 :                        								; character
 7143/    29F6 :                        
 7144/    29F6 : 1E12                   	MOVE.b	(a2),d7				; else get the sign character
 7145/    29F8 : 1C07                   	MOVE.b	d7,d6					; flag that the sign has been done
 7146/    29FA :                        LAB_U03C
 7147/    29FA : 1187 4000              	MOVE.b	d7,(a0,d4.w)			; save the number character to the new format
 7148/    29FE :                        								; string
 7149/    29FE : 609A                   	BRA.s		LAB_U02A				; go do the next new format character
 7150/    2A00 :                        
 7151/    2A00 :                        ; test for overflow conditions
 7152/    2A00 :                        
 7153/    2A00 :                        LAB_U03E
 7154/    2A00 : 4A42                   	TST.w		d2					; test the number string index
 7155/    2A02 : 6614                   	BNE.s		LAB_U040				; if all the digits aren't done go output
 7156/    2A04 :                        								; an overflow indication
 7157/    2A04 :                        
 7158/    2A04 :                        ; test for sign overflows
 7159/    2A04 :                        
 7160/    2A04 : 4A05                   	TST.b		d5					; test the sign present flag
 7161/    2A06 : 6754                   	BEQ.s		LAB_U04A				; if no sign present go add the string
 7162/    2A08 :                        
 7163/    2A08 :                        ; there was a sign in the format string
 7164/    2A08 :                        
 7165/    2A08 : 4A06                   	TST.b		d6					; test the sign done flag
 7166/    2A0A : 6650                   	BNE.s		LAB_U04A				; if the sign is done go add the string
 7167/    2A0C :                        
 7168/    2A0C :                        ; the sign isn't done so see if it was mandatory
 7169/    2A0C :                        
 7170/    2A0C : 0C05 002B              	CMPI.b	#'+',d5				; compare the sign with "+"
 7171/    2A10 : 6706                   	BEQ.s		LAB_U040				; if it was "+" go output an overflow
 7172/    2A12 :                        								; indication
 7173/    2A12 :                        
 7174/    2A12 :                        ; the sign wasn't mandatory but the number may have been negative
 7175/    2A12 :                        
 7176/    2A12 : 0C12 002D              	CMP.b		#'-',(a2)				; compare the sign character with "-"
 7177/    2A16 : 6644                   	BNE.s		LAB_U04A				; if it wasn't "-" go add the string
 7178/    2A18 :                        
 7179/    2A18 :                        ; else the sign was "-" and a sign hasn't been output so ..
 7180/    2A18 :                        
 7181/    2A18 :                        ; the number overflowed the format string so replace all the special format characters
 7182/    2A18 :                        ; with the overflow character
 7183/    2A18 :                        
 7184/    2A18 :                        LAB_U040
 7185/    2A18 : 7A23                   	MOVEQ		#ofchr,d5				; set the overflow character
 7186/    2A1A : 3E01                   	MOVE.w	d1,d7					; copy the new format string length
 7187/    2A1C : 5347                   	SUBQ.w	#1,d7					; adjust for the loop type
 7188/    2A1E : 3C2F 0004              	MOVE.w	fsti(sp),d6				; copy the new format string last index
 7189/    2A22 : 5346                   	SUBQ.w	#1,d6					; -1 gives the last character of this string
 7190/    2A24 : 6E02                   	BGT.s		LAB_U044				; if not zero continue
 7191/    2A26 :                        
 7192/    2A26 : 3C07                   	MOVE.w	d7,d6					; else set the format string index to the end
 7193/    2A28 :                        LAB_U044
 7194/    2A28 : 1031 6000              	MOVE.b	(a1,d6.w),d0			; get a character from the format string
 7195/    2A2C : 0C00 0023              	CMPI.b	#'#',d0				; compare it with "#" special format character
 7196/    2A30 : 671E                   	BEQ.s		LAB_U046				; if "#" go use the overflow character
 7197/    2A32 :                        
 7198/    2A32 : 0C00 0025              	CMPI.b	#'%',d0				; compare it with "%" special format character
 7199/    2A36 : 6718                   	BEQ.s		LAB_U046				; if "%" go use the overflow character
 7200/    2A38 :                        
 7201/    2A38 : 0C00 002C              	CMPI.b	#',',d0				; compare it with "," special format character
 7202/    2A3C : 6712                   	BEQ.s		LAB_U046				; if "," go use the overflow character
 7203/    2A3E :                        
 7204/    2A3E : 0C00 002B              	CMPI.b	#'+',d0				; compare it with "+" special format character
 7205/    2A42 : 670C                   	BEQ.s		LAB_U046				; if "+" go use the overflow character
 7206/    2A44 :                        
 7207/    2A44 : 0C00 002D              	CMPI.b	#'-',d0				; compare it with "-" special format character
 7208/    2A48 : 6706                   	BEQ.s		LAB_U046				; if "-" go use the overflow character
 7209/    2A4A :                        
 7210/    2A4A : 0C00 002E              	CMPI.b	#'.',d0				; compare it with "." special format character
 7211/    2A4E : 6602                   	BNE.s		LAB_U048				; if not "." skip the using overflow character
 7212/    2A50 :                        
 7213/    2A50 :                        LAB_U046
 7214/    2A50 : 1005                   	MOVE.b	d5,d0					; use the overflow character
 7215/    2A52 :                        LAB_U048
 7216/    2A52 : 1180 7000              	MOVE.b	d0,(a0,d7.w)			; save the character to the new format string
 7217/    2A56 : 5346                   	SUBQ.w	#1,d6					; decrement the format string index
 7218/    2A58 : 51CF FFCE              	DBF		d7,LAB_U044				; decrement the count and loop if not all done
 7219/    2A5C :                        
 7220/    2A5C :                        ; add the new string to the previous string
 7221/    2A5C :                        
 7222/    2A5C :                        LAB_U04A
 7223/    2A5C : 41EC 0006              	LEA		6(a4),a0				; get the descriptor pointer for string 1
 7224/    2A60 : 274C 0590              	MOVE.l	a4,FAC1_m(a3)			; save the descriptor pointer for string 2
 7225/    2A64 : 6100 F004              	BSR		LAB_224E				; concatenate the strings
 7226/    2A68 :                        
 7227/    2A68 :                        ; now check for any tail on the format string
 7228/    2A68 :                        
 7229/    2A68 : 302F 0004              	MOVE.w	fsti(sp),d0				; get this index
 7230/    2A6C : 6720                   	BEQ.s		LAB_U04C				; if at start of string skip the output
 7231/    2A6E :                        
 7232/    2A6E : 3F40 0006              	MOVE.w	d0,fsli(sp)				; save this index to the last index
 7233/    2A72 : 6100 0084              	BSR		LAB_ProcFo				; now process the format string
 7234/    2A76 : 4A02                   	TST.b		d2					; test the special characters flag
 7235/    2A78 : 6614                   	BNE.s		LAB_U04C				; if special characters present skip the output
 7236/    2A7A :                        
 7237/    2A7A :                        ; else output the new string part
 7238/    2A7A :                        
 7239/    2A7A : 613E                   	BSR.s		LAB_DupFmt				; duplicate the processed format string section
 7240/    2A7C : 3F6F 0004 0006         	MOVE.w	fsti(sp),fsli(sp)			; copy this index to the last index
 7241/    2A82 :                        
 7242/    2A82 :                        ; add the new string to the previous string
 7243/    2A82 :                        
 7244/    2A82 : 41EC 0006              	LEA		6(a4),a0				; get the descriptor pointer for string 1
 7245/    2A86 : 274C 0590              	MOVE.l	a4,FAC1_m(a3)			; save the descriptor pointer for string 2
 7246/    2A8A : 6100 EFDE              	BSR		LAB_224E				; concatenate the strings
 7247/    2A8E :                        
 7248/    2A8E :                        ; check for another value or end of function
 7249/    2A8E :                        
 7250/    2A8E :                        LAB_U04C
 7251/    2A8E : 101D                   	MOVE.b	(a5)+,d0				; get the next BASIC byte
 7252/    2A90 : B03C 0029              	CMP.b		#')',d0				; compare with close bracket
 7253/    2A94 : 6600 FDCA              	BNE		LAB_U002				; if not ")" go do next value
 7254/    2A98 :                        
 7255/    2A98 :                        ; pop the result string off the descriptor stack
 7256/    2A98 :                        
 7257/    2A98 : 204C                   	MOVEA.l	a4,a0					; copy the result string descriptor pointer
 7258/    2A9A : 222B 0446              	MOVE.l	Sstorl(a3),d1			; save the bottom of string space
 7259/    2A9E : 6100 F02C              	BSR		LAB_22BA				; pop (a0) descriptor, returns with ..
 7260/    2AA2 :                        								; d0 = length, a0 = pointer
 7261/    2AA2 : 2741 0446              	MOVE.l	d1,Sstorl(a3)			; restore the bottom of string space
 7262/    2AA6 : 2248                   	MOVEA.l	a0,a1					; copy the string result pointer
 7263/    2AA8 : 3200                   	MOVE.w	d0,d1					; copy the string result length
 7264/    2AAA :                        
 7265/    2AAA :                        ; pop the format string off the descriptor stack
 7266/    2AAA :                        
 7267/    2AAA : 205F                   	MOVEA.l	(sp)+,a0				; pull the format string descriptor pointer
 7268/    2AAC : 6100 F01E              	BSR		LAB_22BA				; pop (a0) descriptor, returns with ..
 7269/    2AB0 :                        								; d0 = length, a0 = pointer
 7270/    2AB0 :                        
 7271/    2AB0 : 4FEF 0008              	LEA		fend(sp),sp				; dump the saved values
 7272/    2AB4 :                        
 7273/    2AB4 :                        ; push the result string back on the descriptor stack and return
 7274/    2AB4 :                        
 7275/    2AB4 : 2049                   	MOVEA.l	a1,a0					; copy the result string pointer back
 7276/    2AB6 : 6000 EE62              	BRA		LAB_RTST				; push a string on the descriptor stack and
 7277/    2ABA :                        								; return. a0 = pointer, d1 = length
 7278/    2ABA :                        
 7279/    2ABA :                        
 7280/    2ABA :                        ;************************************************************************************
 7281/    2ABA :                        ;
 7282/    2ABA :                        ; duplicate the processed format string section
 7283/    2ABA :                        
 7284/    2ABA :                        								; make a string as long as the format string
 7285/    2ABA :                        LAB_DupFmt
 7286/    2ABA : 226F 0004              	MOVEA.l	4+fsd(sp),a1			; get the format string descriptor pointer
 7287/    2ABE : 3E29 0004              	MOVE.w	4(a1),d7				; get the format string length
 7288/    2AC2 : 342F 000A              	MOVE.w	4+fsli(sp),d2			; get the format string last index
 7289/    2AC6 : 3C2F 0008              	MOVE.w	4+fsti(sp),d6			; get the format string this index
 7290/    2ACA : 3206                   	MOVE.w	d6,d1					; copy the format string this index
 7291/    2ACC : 9242                   	SUB.w		d2,d1					; subtract the format string last index
 7292/    2ACE : 6202                   	BHI.s		LAB_D002				; if > 0 skip the correction
 7293/    2AD0 :                        
 7294/    2AD0 : D247                   	ADD.w		d7,d1					; else add the format string length as the
 7295/    2AD2 :                        								; correction
 7296/    2AD2 :                        LAB_D002
 7297/    2AD2 : 6100 EE60              	BSR		LAB_2115				; make string space d1 bytes long
 7298/    2AD6 :                        								; return a0/Sutill = pointer, others unchanged
 7299/    2AD6 :                        
 7300/    2AD6 :                        ; push the new string on the descriptor stack
 7301/    2AD6 :                        
 7302/    2AD6 : 6100 EE42              	BSR		LAB_RTST				; push a string on the descriptor stack and
 7303/    2ADA :                        								; return. a0 = pointer, d1 = length
 7304/    2ADA :                        
 7305/    2ADA :                        ; copy the characters from the format string
 7306/    2ADA :                        
 7307/    2ADA : 226F 0004              	MOVEA.l	4+fsd(sp),a1			; get the format string descriptor pointer
 7308/    2ADE : 2251                   	MOVEA.l	(a1),a1				; get the format string pointer
 7309/    2AE0 : 7800                   	MOVEQ		#0,d4					; clear the new string index
 7310/    2AE2 :                        LAB_D00A
 7311/    2AE2 : 11B1 2000 4000         	MOVE.b	(a1,d2.w),(a0,d4.w)		; get a character from the format string and
 7312/    2AE8 :                        								; save it to the new string
 7313/    2AE8 : 5244                   	ADDQ.w	#1,d4					; increment the new string index
 7314/    2AEA : 5242                   	ADDQ.w	#1,d2					; increment the format string index
 7315/    2AEC : BE42                   	CMP.w		d2,d7					; compare the format index with the length
 7316/    2AEE : 6602                   	BNE.s		LAB_D00E				; if not there skip the reset
 7317/    2AF0 :                        
 7318/    2AF0 : 7400                   	MOVEQ		#0,d2					; else reset the format string index
 7319/    2AF2 :                        LAB_D00E
 7320/    2AF2 : BC42                   	CMP.w		d2,d6					; compare the index with this index
 7321/    2AF4 : 66EC                   	BNE.s		LAB_D00A				; if not equal go do the next character
 7322/    2AF6 :                        
 7323/    2AF6 : 4E75                   	RTS
 7324/    2AF8 :                        
 7325/    2AF8 :                        
 7326/    2AF8 :                        ;************************************************************************************
 7327/    2AF8 :                        ;
 7328/    2AF8 :                        ; process the format string
 7329/    2AF8 :                        
 7330/    2AF8 :                        LAB_ProcFo
 7331/    2AF8 : 226F 0004              	MOVEA.l	4+fsd(sp),a1			; get the format string descriptor pointer
 7332/    2AFC : 3E29 0004              	MOVE.w	4(a1),d7				; get the format string length
 7333/    2B00 : 2251                   	MOVEA.l	(a1),a1				; get the format string pointer
 7334/    2B02 : 3C2F 000A              	MOVE.w	4+fsli(sp),d6			; get the format string last index
 7335/    2B06 :                        
 7336/    2B06 : 3F47 000C              	MOVE.w	d7,4+fsdpi(sp)			; set the format string decimal point index
 7337/    2B0A :                        ;##	MOVE.w	#-1,4+fsdpi(sp)			; set the format string decimal point index
 7338/    2B0A : 7A00                   	MOVEQ		#0,d5					; no decimal point
 7339/    2B0C : 7600                   	MOVEQ		#0,d3					; no decimal characters
 7340/    2B0E : 7400                   	MOVEQ		#0,d2					; no special characters
 7341/    2B10 :                        LAB_P004
 7342/    2B10 : 1031 6000              	MOVE.b	(a1,d6.w),d0			; get a format string byte
 7343/    2B14 :                        
 7344/    2B14 : B03C 002C              	CMP.b		#',',d0				; compare it with ","
 7345/    2B18 : 6742                   	BEQ.s		LAB_P01A				; if "," go do the next format string byte
 7346/    2B1A :                        
 7347/    2B1A : B03C 0023              	CMP.b		#'#',d0				; compare it with "#"
 7348/    2B1E : 6706                   	BEQ.s		LAB_P008				; if "#" go flag special characters
 7349/    2B20 :                        
 7350/    2B20 : B03C 0025              	CMP.b		#'%',d0				; compare it with "%"
 7351/    2B24 : 6608                   	BNE.s		LAB_P00C				; if not "%" go try "+"
 7352/    2B26 :                        
 7353/    2B26 :                        LAB_P008
 7354/    2B26 : 4A85                   	TST.l		d5					; test the decimal point flag
 7355/    2B28 : 6A10                   	BPL.s		LAB_P00E				; if no point skip counting decimal characters
 7356/    2B2A :                        
 7357/    2B2A : 5243                   	ADDQ.w	#1,d3					; else increment the decimal character count
 7358/    2B2C : 602E                   	BRA.s		LAB_P01A				; go do the next character
 7359/    2B2E :                        
 7360/    2B2E :                        LAB_P00C
 7361/    2B2E : B03C 002B              	CMP.b		#'+',d0				; compare it with "+"
 7362/    2B32 : 6706                   	BEQ.s		LAB_P00E				; if "+" go flag special characters
 7363/    2B34 :                        
 7364/    2B34 : B03C 002D              	CMP.b		#'-',d0				; compare it with "-"
 7365/    2B38 : 6604                   	BNE.s		LAB_P010				; if not "-" go check decimal point
 7366/    2B3A :                        
 7367/    2B3A :                        LAB_P00E
 7368/    2B3A : 8400                   	OR.b		d0,d2					; flag special characters
 7369/    2B3C : 601E                   	BRA.s		LAB_P01A				; go do the next character
 7370/    2B3E :                        
 7371/    2B3E :                        LAB_P010
 7372/    2B3E : B03C 002E              	CMP.b		#'.',d0				; compare it with "."
 7373/    2B42 : 6614                   	BNE.s		LAB_P018				; if not "." go check next
 7374/    2B44 :                        
 7375/    2B44 :                        ; "." a decimal point
 7376/    2B44 :                        
 7377/    2B44 : 4A85                   	TST.l		d5					; if there is already a decimal point
 7378/    2B46 : 6B14                   	BMI.s		LAB_P01A				; go do the next character
 7379/    2B48 :                        
 7380/    2B48 : 3006                   	MOVE.w	d6,d0					; copy the decimal point index
 7381/    2B4A : 906F 000A              	SUB.w		4+fsli(sp),d0			; calculate it from the scan start
 7382/    2B4E : 3F40 000C              	MOVE.w	d0,4+fsdpi(sp)			; save the decimal point index
 7383/    2B52 : 7AFF                   	MOVEQ		#-1,d5				; flag decimal point
 7384/    2B54 : 8400                   	OR.b		d0,d2					; flag special characters
 7385/    2B56 : 6004                   	BRA.s		LAB_P01A				; go do the next character
 7386/    2B58 :                        
 7387/    2B58 :                        ; was not a special character
 7388/    2B58 :                        
 7389/    2B58 :                        LAB_P018
 7390/    2B58 : 4A02                   	TST.b		d2					; test if there have been special characters
 7391/    2B5A : 6608                   	BNE.s		LAB_P01E				; if so exit the format string process
 7392/    2B5C :                        
 7393/    2B5C :                        LAB_P01A
 7394/    2B5C : 5246                   	ADDQ.w	#1,d6					; increment the format string index
 7395/    2B5E : BE46                   	CMP.w		d6,d7					; compare it with the format string length
 7396/    2B60 : 62AE                   	BHI.s		LAB_P004				; if length > index go get the next character
 7397/    2B62 :                        
 7398/    2B62 : 7C00                   	MOVEQ		#0,d6					; length = index so reset the format string
 7399/    2B64 :                        								; index
 7400/    2B64 :                        LAB_P01E
 7401/    2B64 : 3F46 0008              	MOVE.w	d6,4+fsti(sp)			; save the format string this index
 7402/    2B68 : 3F43 000E              	MOVE.w	d3,4+fsdc(sp)			; save the format string decimal characters
 7403/    2B6C :                        
 7404/    2B6C : 4E75                   	RTS
 7405/    2B6E :                        
 7406/    2B6E :                        
 7407/    2B6E :                        ;************************************************************************************
 7408/    2B6E :                        ;
 7409/    2B6E :                        ; perform BIN$()
 7410/    2B6E :                        ; # of leading 0s is in d1, the number is in d0
 7411/    2B6E :                        
 7412/    2B6E :                        LAB_BINS
 7413/    2B6E : B23C 0021              	CMP.b		#$21,d1				; max + 1
 7414/    2B72 : 6400 DAF6              	BCC		LAB_FCER				; exit if too big ( > or = )
 7415/    2B76 :                        
 7416/    2B76 : 741F                   	MOVEQ		#$1F,d2				; bit count-1
 7417/    2B78 : 41EB 05B6              	LEA		Binss(a3),a0			; point to string
 7418/    2B7C : 7830                   	MOVEQ		#$30,d4				; "0" character for ADDX
 7419/    2B7E :                        NextB1
 7420/    2B7E : 7600                   	MOVEQ		#0,d3					; clear byte
 7421/    2B80 : E288                   	LSR.l		#1,d0					; shift bit into Xb
 7422/    2B82 : D704                   	ADDX.b	d4,d3					; add carry and character to zero
 7423/    2B84 : 1183 2000              	MOVE.b	d3,(a0,d2.w)			; save character to string
 7424/    2B88 : 51CA FFF4              	DBF		d2,NextB1				; decrement and loop if not done
 7425/    2B8C :                        
 7426/    2B8C :                        ; this is the exit code and is also used by HEX$()
 7427/    2B8C :                        
 7428/    2B8C :                        EndBHS
 7429/    2B8C : 177C 0000 05D6         	MOVE.b	#0,BHsend(a3)			; null terminate the string
 7430/    2B92 : 4A01                   	TST.b		d1					; test # of characters
 7431/    2B94 : 670E                   	BEQ.s		NextB2				; go truncate string
 7432/    2B96 :                        
 7433/    2B96 : 4481                   	NEG.l		d1					; make -ve
 7434/    2B98 : D2BC 0000 05D6         	ADD.l		#BHsend,d1				; effectively (end-length)
 7435/    2B9E : 41F3 1000              	LEA		0(a3,d1.w),a0			; effectively add (end-length) to pointer
 7436/    2BA2 : 600E                   	BRA.s		BinPr					; go print string
 7437/    2BA4 :                        
 7438/    2BA4 :                        ; truncate string to remove leading "0"s
 7439/    2BA4 :                        
 7440/    2BA4 :                        NextB2
 7441/    2BA4 : 1010                   	MOVE.b	(a0),d0				; get byte
 7442/    2BA6 : 670A                   	BEQ.s		BinPr					; if null then end of string so add 1 and go
 7443/    2BA8 :                        								; print it
 7444/    2BA8 :                        
 7445/    2BA8 : B03C 0030              	CMP.b		#'0',d0				; compare with "0"
 7446/    2BAC : 660E                   	BNE.s		GoPr					; if not "0" then go print string from here
 7447/    2BAE :                        
 7448/    2BAE : 5248                   	ADDQ.w	#1,a0					; else increment pointer
 7449/    2BB0 : 60F2                   	BRA.s		NextB2				; loop always
 7450/    2BB2 :                        
 7451/    2BB2 :                        ; make fixed length output string - ignore overflows!
 7452/    2BB2 :                        
 7453/    2BB2 :                        BinPr
 7454/    2BB2 : 43EB 05D6              	LEA		BHsend(a3),a1			; get string end
 7455/    2BB6 : B1C9                   	CMPA.l	a1,a0					; are we at the string end
 7456/    2BB8 : 6602                   	BNE.s		GoPr					; branch if not
 7457/    2BBA :                        
 7458/    2BBA : 5348                   	SUBQ.w	#1,a0					; else need at least one zero
 7459/    2BBC :                        GoPr
 7460/    2BBC : 6000 ED16              	BRA		LAB_20AE				; print " terminated string to FAC1, stack & RET
 7461/    2BC0 :                        
 7462/    2BC0 :                        
 7463/    2BC0 :                        ;************************************************************************************
 7464/    2BC0 :                        ;
 7465/    2BC0 :                        ; perform HEX$()
 7466/    2BC0 :                        ; # of leading 0s is in d1, the number is in d0
 7467/    2BC0 :                        
 7468/    2BC0 :                        LAB_HEXS
 7469/    2BC0 : B23C 0009              	CMP.b		#$09,d1				; max + 1
 7470/    2BC4 : 6400 DAA4              	BCC		LAB_FCER				; exit if too big ( > or = )
 7471/    2BC8 :                        
 7472/    2BC8 : 7407                   	MOVEQ		#$07,d2				; nibble count-1
 7473/    2BCA : 41EB 05CE              	LEA		Hexss(a3),a0			; point to string
 7474/    2BCE : 7830                   	MOVEQ		#$30,d4				; "0" character for ABCD
 7475/    2BD0 :                        NextH1
 7476/    2BD0 : 1600                   	MOVE.b	d0,d3					; copy lowest byte
 7477/    2BD2 : E898                   	ROR.l		#4,d0					; shift nibble into 0-3
 7478/    2BD4 : C63C 000F              	AND.b		#$0F,d3				; just this nibble
 7479/    2BD8 : 1A03                   	MOVE.b	d3,d5					; copy it
 7480/    2BDA : DA3C 00F6              	ADD.b		#$F6,d5				; set extend bit
 7481/    2BDE : C704                   	ABCD		d4,d3					; decimal add extend and character to zero
 7482/    2BE0 : 1183 2000              	MOVE.b	d3,(a0,d2.w)			; save character to string
 7483/    2BE4 : 51CA FFEA              	DBF		d2,NextH1				; decrement and loop if not done
 7484/    2BE8 :                        
 7485/    2BE8 : 60A2                   	BRA.s		EndBHS				; go process string
 7486/    2BEA :                        
 7487/    2BEA :                        
 7488/    2BEA :                        ;************************************************************************************
 7489/    2BEA :                        ;
 7490/    2BEA :                        ; ctrl-c check routine. includes limited "life" byte save for INGET routine
 7491/    2BEA :                        
 7492/    2BEA :                        VEC_CC
 7493/    2BEA : 4A2B 05E8              	TST.b		ccflag(a3)				; check [CTRL-C] check flag
 7494/    2BEE : 661E                   	BNE.s		RTS_022				; exit if [CTRL-C] check inhibited
 7495/    2BF0 :                        
 7496/    2BF0 : 4EAB 040C              	JSR		V_INPT(a3)				; scan input device
 7497/    2BF4 : 640E                   	BCC.s		LAB_FBA0				; exit if buffer empty
 7498/    2BF6 :                        
 7499/    2BF6 : 1740 05E9              	MOVE.b	d0,ccbyte(a3)			; save received byte
 7500/    2BFA : 177C 0020 05EA         	MOVE.b	#$20,ccnull(a3)			; set "life" timer for bytes countdown
 7501/    2C00 : 6000 DEDE              	BRA		LAB_1636				; return to BASIC
 7502/    2C04 :                        
 7503/    2C04 :                        LAB_FBA0
 7504/    2C04 : 4A2B 05EA              	TST.b		ccnull(a3)				; get countdown byte
 7505/    2C08 : 6704                   	BEQ.s		RTS_022				; exit if finished
 7506/    2C0A :                        
 7507/    2C0A : 532B 05EA              	SUBQ.b	#1,ccnull(a3)			; else decrement countdown
 7508/    2C0E :                        RTS_022
 7509/    2C0E : 4E75                   	RTS
 7510/    2C10 :                        
 7511/    2C10 :                        
 7512/    2C10 :                        ;************************************************************************************
 7513/    2C10 :                        ;
 7514/    2C10 :                        ; get byte from input device, no waiting
 7515/    2C10 :                        ; returns with carry set if byte in A
 7516/    2C10 :                        
 7517/    2C10 :                        INGET
 7518/    2C10 : 4EAB 040C              	JSR		V_INPT(a3)				; call scan input device
 7519/    2C14 : 650A                   	BCS.s		LAB_FB95				; if byte go reset timer
 7520/    2C16 :                        
 7521/    2C16 : 102B 05EA              	MOVE.b	ccnull(a3),d0			; get countdown
 7522/    2C1A : 67F2                   	BEQ.s		RTS_022				; exit if empty
 7523/    2C1C :                        
 7524/    2C1C : 102B 05E9              	MOVE.b	ccbyte(a3),d0			; get last received byte
 7525/    2C20 :                        LAB_FB95
 7526/    2C20 : 177C 0000 05EA         	MOVE.b	#$00,ccnull(a3)			; clear timer because we got a byte
 7527/    2C26 : 003C 0001              	ORI.b		#1,CCR				; set carry, flag we got a byte
 7528/    2C2A : 4E75                   	RTS
 7529/    2C2C :                        
 7530/    2C2C :                        
 7531/    2C2C :                        ;************************************************************************************
 7532/    2C2C :                        ;
 7533/    2C2C :                        ; perform MAX()
 7534/    2C2C :                        
 7535/    2C2C :                        LAB_MAX
 7536/    2C2C : 6100 E530              	BSR		LAB_EVEZ				; evaluate expression (no decrement)
 7537/    2C30 : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type
 7538/    2C34 : 6B00 DA14              	BMI		LAB_TMER				; if string do Type missmatch Error/warm start
 7539/    2C38 :                        
 7540/    2C38 :                        LAB_MAXN
 7541/    2C38 : 612E                   	BSR.s		LAB_PHFA				; push FAC1, evaluate expression,
 7542/    2C3A :                        								; pull FAC2 & compare with FAC1
 7543/    2C3A : 64FC                   	BCC.s		LAB_MAXN				; branch if no swap to do
 7544/    2C3C :                        
 7545/    2C3C : 6100 F4A0              	BSR		LAB_279B				; copy FAC2 to FAC1
 7546/    2C40 : 60F6                   	BRA.s		LAB_MAXN				; go do next
 7547/    2C42 :                        
 7548/    2C42 :                        
 7549/    2C42 :                        ;************************************************************************************
 7550/    2C42 :                        ;
 7551/    2C42 :                        ; perform MIN()
 7552/    2C42 :                        
 7553/    2C42 :                        LAB_MIN
 7554/    2C42 : 6100 E51A              	BSR		LAB_EVEZ				; evaluate expression (no decrement)
 7555/    2C46 : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type
 7556/    2C4A : 6B00 D9FE              	BMI		LAB_TMER				; if string do Type missmatch Error/warm start
 7557/    2C4E :                        
 7558/    2C4E :                        LAB_MINN
 7559/    2C4E : 6118                   	BSR.s		LAB_PHFA				; push FAC1, evaluate expression,
 7560/    2C50 :                        								; pull FAC2 & compare with FAC1
 7561/    2C50 : 63FC                   	BLS.s		LAB_MINN				; branch if no swap to do
 7562/    2C52 :                        
 7563/    2C52 : 6100 F48A              	BSR		LAB_279B				; copy FAC2 to FAC1
 7564/    2C56 : 60F6                   	BRA.s		LAB_MINN				; go do next (branch always)
 7565/    2C58 :                        
 7566/    2C58 :                        ; exit routine. don't bother returning to the loop code
 7567/    2C58 :                        ; check for correct exit, else so syntax error
 7568/    2C58 :                        
 7569/    2C58 :                        LAB_MMEC
 7570/    2C58 : B03C 0029              	CMP.b		#')',d0				; is it end of function?
 7571/    2C5C : 6600 DA18              	BNE		LAB_SNER				; if not do MAX MIN syntax error
 7572/    2C60 :                        
 7573/    2C60 : 4FEF 0004              	LEA		4(sp),sp				; dump return address (faster)
 7574/    2C64 : 6000 E656              	BRA		LAB_IGBY				; update BASIC execute pointer (to chr past ")")
 7575/    2C68 :                        								; and return
 7576/    2C68 :                        
 7577/    2C68 :                        ; check for next, evaluate & return or exit
 7578/    2C68 :                        ; this is the routine that does most of the work
 7579/    2C68 :                        
 7580/    2C68 :                        LAB_PHFA
 7581/    2C68 : 6100 E654              	BSR		LAB_GBYT				; get next BASIC byte
 7582/    2C6C : B03C 002C              	CMP.b		#',',d0				; is there more ?
 7583/    2C70 : 66E6                   	BNE.s		LAB_MMEC				; if not go do end check
 7584/    2C72 :                        
 7585/    2C72 : 3F2B 0594              	MOVE.w	FAC1_e(a3),-(sp)			; push exponent and sign
 7586/    2C76 : 2F2B 0590              	MOVE.l	FAC1_m(a3),-(sp)			; push mantissa
 7587/    2C7A :                        
 7588/    2C7A : 6100 E4E2              	BSR		LAB_EVEZ				; evaluate expression (no decrement)
 7589/    2C7E : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type
 7590/    2C82 : 6B00 D9C6              	BMI		LAB_TMER				; if string do Type missmatch Error/warm start
 7591/    2C86 :                        
 7592/    2C86 :                        
 7593/    2C86 :                        								; pop FAC2 (MAX/MIN expression so far)
 7594/    2C86 : 275F 0598              	MOVE.l	(sp)+,FAC2_m(a3)			; pop mantissa
 7595/    2C8A :                        
 7596/    2C8A : 301F                   	MOVE.w	(sp)+,d0				; pop exponent and sign
 7597/    2C8C : 3740 059C              	MOVE.w	d0,FAC2_e(a3)			; save exponent and sign
 7598/    2C90 : 176B 0595 059E         	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; get FAC1 sign
 7599/    2C96 : B12B 059E              	EOR.b		d0,FAC_sc(a3)			; EOR to create sign compare
 7600/    2C9A : 6000 F4AE              	BRA		LAB_27FA				; compare FAC1 with FAC2 & return
 7601/    2C9E :                        								; returns d0=+1 Cb=0 if FAC1 > FAC2
 7602/    2C9E :                        								; returns d0= 0 Cb=0 if FAC1 = FAC2
 7603/    2C9E :                        								; returns d0=-1 Cb=1 if FAC1 < FAC2
 7604/    2C9E :                        
 7605/    2C9E :                        
 7606/    2C9E :                        ;************************************************************************************
 7607/    2C9E :                        ;
 7608/    2C9E :                        ; perform WIDTH
 7609/    2C9E :                        
 7610/    2C9E :                        LAB_WDTH
 7611/    2C9E : B03C 002C              	CMP.b		#',',d0				; is next byte ","
 7612/    2CA2 : 672C                   	BEQ.s		LAB_TBSZ				; if so do tab size
 7613/    2CA4 :                        
 7614/    2CA4 : 6100 EF82              	BSR		LAB_GTBY				; get byte parameter, result in d0 and Itemp
 7615/    2CA8 : 4A00                   	TST.b		d0					; test result
 7616/    2CAA : 6712                   	BEQ.s		LAB_NSTT				; branch if set for infinite line
 7617/    2CAC :                        
 7618/    2CAC : B03C 0010              	CMP.b		#$10,d0				; else make min width = 16d
 7619/    2CB0 : 6500 D9B8              	BCS		LAB_FCER				; if less do function call error & exit
 7620/    2CB4 :                        
 7621/    2CB4 :                        ; this next compare ensures that we can't exit WIDTH via an error leaving the
 7622/    2CB4 :                        ; tab size greater than the line length.
 7623/    2CB4 :                        
 7624/    2CB4 : B02B 05E2              	CMP.b		TabSiz(a3),d0			; compare with tab size
 7625/    2CB8 : 6404                   	BCC.s		LAB_NSTT				; branch if >= tab size
 7626/    2CBA :                        
 7627/    2CBA : 1740 05E2              	MOVE.b	d0,TabSiz(a3)			; else make tab size = terminal width
 7628/    2CBE :                        LAB_NSTT
 7629/    2CBE : 1740 05E6              	MOVE.b	d0,TWidth(a3)			; set the terminal width
 7630/    2CC2 : 6100 E5FA              	BSR		LAB_GBYT				; get BASIC byte back
 7631/    2CC6 : 672C                   	BEQ.s		WExit					; exit if no following
 7632/    2CC8 :                        
 7633/    2CC8 : B03C 002C              	CMP.b		#',',d0				; else is it ","
 7634/    2CCC : 6600 D9A8              	BNE		LAB_SNER				; if not do syntax error
 7635/    2CD0 :                        
 7636/    2CD0 :                        LAB_TBSZ
 7637/    2CD0 : 6100 EF52              	BSR		LAB_SGBY				; increment and get byte, result in d0 and Itemp
 7638/    2CD4 : 4A00                   	TST.b		d0					; test TAB size
 7639/    2CD6 : 6B00 D992              	BMI		LAB_FCER				; if >127 do function call error & exit
 7640/    2CDA :                        
 7641/    2CDA : B03C 0001              	CMP.b		#1,d0					; compare with min-1
 7642/    2CDE : 6500 D98A              	BCS		LAB_FCER				; if <=1 do function call error & exit
 7643/    2CE2 :                        
 7644/    2CE2 : 122B 05E6              	MOVE.b	TWidth(a3),d1			; set flags for width
 7645/    2CE6 : 6708                   	BEQ.s		LAB_SVTB				; skip check if infinite line
 7646/    2CE8 :                        
 7647/    2CE8 : B02B 05E6              	CMP.b		TWidth(a3),d0			; compare TAB with width
 7648/    2CEC : 6E00 D97C              	BGT		LAB_FCER				; branch if too big
 7649/    2CF0 :                        
 7650/    2CF0 :                        LAB_SVTB
 7651/    2CF0 : 1740 05E2              	MOVE.b	d0,TabSiz(a3)			; save TAB size
 7652/    2CF4 :                        
 7653/    2CF4 :                        ; calculate tab column limit from TAB size. The Iclim is set to the last tab
 7654/    2CF4 :                        ; position on a line that still has at least one whole tab width between it
 7655/    2CF4 :                        ; and the end of the line.
 7656/    2CF4 :                        
 7657/    2CF4 :                        WExit
 7658/    2CF4 : 102B 05E6              	MOVE.b	TWidth(a3),d0			; get width
 7659/    2CF8 : 670A                   	BEQ.s		LAB_WDLP				; branch if infinite line
 7660/    2CFA :                        
 7661/    2CFA : B02B 05E2              	CMP.b		TabSiz(a3),d0			; compare with tab size
 7662/    2CFE : 6404                   	BCC.s		LAB_WDLP				; branch if >= tab size
 7663/    2D00 :                        
 7664/    2D00 : 1740 05E2              	MOVE.b	d0,TabSiz(a3)			; else make tab size = terminal width
 7665/    2D04 :                        LAB_WDLP
 7666/    2D04 : 902B 05E2              	SUB.b		TabSiz(a3),d0			; subtract tab size
 7667/    2D08 : 64FA                   	BCC.s		LAB_WDLP				; loop while no borrow
 7668/    2D0A :                        
 7669/    2D0A : D02B 05E2              	ADD.b		TabSiz(a3),d0			; add tab size back
 7670/    2D0E : D02B 05E2              	ADD.b		TabSiz(a3),d0			; add tab size back again
 7671/    2D12 :                        
 7672/    2D12 : 4400                   	NEG.b		d0					; make -ve
 7673/    2D14 : D02B 05E6              	ADD.b		TWidth(a3),d0			; subtract remainder from width
 7674/    2D18 : 1740 05E7              	MOVE.b	d0,Iclim(a3)			; save tab column limit
 7675/    2D1C :                        RTS_023
 7676/    2D1C : 4E75                   	RTS
 7677/    2D1E :                        
 7678/    2D1E :                        
 7679/    2D1E :                        ;************************************************************************************
 7680/    2D1E :                        ;
 7681/    2D1E :                        ; perform SQR()
 7682/    2D1E :                        
 7683/    2D1E :                        ; d0 is number to find the root of
 7684/    2D1E :                        ; d1 is the root result
 7685/    2D1E :                        ; d2 is the remainder
 7686/    2D1E :                        ; d3 is a counter
 7687/    2D1E :                        ; d4 is temp
 7688/    2D1E :                        
 7689/    2D1E :                        LAB_SQR
 7690/    2D1E : 4A2B 0595              	TST.b		FAC1_s(a3)				; test FAC1 sign
 7691/    2D22 : 6B00 D946              	BMI		LAB_FCER				; if -ve do function call error
 7692/    2D26 :                        
 7693/    2D26 : 4A2B 0594              	TST.b		FAC1_e(a3)				; test exponent
 7694/    2D2A : 67F0                   	BEQ.s		RTS_023				; exit if zero
 7695/    2D2C :                        
 7696/    2D2C : 48E7 7800              	MOVEM.l	d1-d4,-(sp)				; save registers
 7697/    2D30 : 202B 0590              	MOVE.l	FAC1_m(a3),d0			; copy FAC1
 7698/    2D34 : 7400                   	MOVEQ		#0,d2					; clear remainder
 7699/    2D36 : 2202                   	MOVE.l	d2,d1					; clear root
 7700/    2D38 :                        
 7701/    2D38 : 761F                   	MOVEQ		#$1F,d3				; $1F for DBF, 64 pairs of bits to
 7702/    2D3A :                        								; do for a 32 bit result
 7703/    2D3A : 082B 0000 0594         	BTST		#0,FAC1_e(a3)			; test exponent odd/even
 7704/    2D40 : 6606                   	BNE.s		LAB_SQE2				; if odd only 1 shift first time
 7705/    2D42 :                        
 7706/    2D42 :                        LAB_SQE1
 7707/    2D42 : D080                   	ADD.l		d0,d0					; shift highest bit of number ..
 7708/    2D44 : D582                   	ADDX.l	d2,d2					; .. into remainder .. never overflows
 7709/    2D46 : D281                   	ADD.l		d1,d1					; root = root	; 2 .. never overflows
 7710/    2D48 :                        LAB_SQE2
 7711/    2D48 : D080                   	ADD.l		d0,d0					; shift highest bit of number ..
 7712/    2D4A : D582                   	ADDX.l	d2,d2					; .. into remainder .. never overflows
 7713/    2D4C :                        
 7714/    2D4C : 2801                   	MOVE.l	d1,d4					; copy root
 7715/    2D4E : D884                   	ADD.l		d4,d4					; 2n
 7716/    2D50 : 5284                   	ADDQ.l	#1,d4					; 2n+1
 7717/    2D52 :                        
 7718/    2D52 : B484                   	CMP.l		d4,d2					; compare 2n+1 to remainder
 7719/    2D54 : 6504                   	BCS.s		LAB_SQNS				; skip sub if remainder smaller
 7720/    2D56 :                        
 7721/    2D56 : 9484                   	SUB.l		d4,d2					; subtract temp from remainder
 7722/    2D58 : 5281                   	ADDQ.l	#1,d1					; increment root
 7723/    2D5A :                        LAB_SQNS
 7724/    2D5A : 51CB FFE6              	DBF		d3,LAB_SQE1				; loop if not all done
 7725/    2D5E :                        
 7726/    2D5E : 2741 0590              	MOVE.l	d1,FAC1_m(a3)			; save result mantissa
 7727/    2D62 : 102B 0594              	MOVE.b	FAC1_e(a3),d0			; get exponent (d0 is clear here)
 7728/    2D66 : 907C 0080              	SUB.w		#$80,d0				; normalise
 7729/    2D6A : E248                   	LSR.w		#1,d0					; /2
 7730/    2D6C : 6402                   	BCC.s		LAB_SQNA				; skip increment if carry clear
 7731/    2D6E :                        
 7732/    2D6E : 5240                   	ADDQ.w	#1,d0					; add bit zero back in (allow for half shift)
 7733/    2D70 :                        LAB_SQNA
 7734/    2D70 : D07C 0080              	ADD.w		#$80,d0				; re-bias to $80
 7735/    2D74 : 1740 0594              	MOVE.b	d0,FAC1_e(a3)			; save it
 7736/    2D78 : 4CDF 001E              	MOVEM.l	(sp)+,d1-d4				; restore registers
 7737/    2D7C : 6000 F09E              	BRA		LAB_24D5				; normalise FAC1 & return
 7738/    2D80 :                        
 7739/    2D80 :                        
 7740/    2D80 :                        ;************************************************************************************
 7741/    2D80 :                        ;
 7742/    2D80 :                        ; perform VARPTR()
 7743/    2D80 :                        
 7744/    2D80 :                        LAB_VARPTR
 7745/    2D80 : 101D                   	MOVE.b	(a5)+,d0				; increment pointer
 7746/    2D82 :                        LAB_VARCALL
 7747/    2D82 : 6100 E74A              	BSR		LAB_GVAR				; get variable address in a0
 7748/    2D86 : 6100 E522              	BSR		LAB_1BFB				; scan for ")", else do syntax error/warm start
 7749/    2D8A : 2008                   	MOVE.l	a0,d0					; copy the variable address
 7750/    2D8C : 6000 EA30              	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & return
 7751/    2D90 :                        
 7752/    2D90 :                        
 7753/    2D90 :                        ;************************************************************************************
 7754/    2D90 :                        ;
 7755/    2D90 :                        ; perform RAMBASE
 7756/    2D90 :                        
 7757/    2D90 :                        LAB_RAM
 7758/    2D90 : 41F8 0400              	LEA		ram_base,a0			; get start of EhBASIC RAM
 7759/    2D94 : 2008                   	MOVE.l	a0,d0					; copy it
 7760/    2D96 : 6000 EA26              	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & return
 7761/    2D9A :                        
 7762/    2D9A :                        
 7763/    2D9A :                        ;************************************************************************************
 7764/    2D9A :                        ;
 7765/    2D9A :                        ; perform PI
 7766/    2D9A :                        
 7767/    2D9A :                        LAB_PI
 7768/    2D9A : 277C C90F DAA2 0590    	MOVE.l	#$C90FDAA2,FAC1_m(a3)		; pi mantissa (32 bit)
 7769/    2DA2 : 377C 8200 0594         	MOVE.w	#$8200,FAC1_e(a3)			; pi exponent and sign
 7770/    2DA8 : 4E75                   	RTS
 7771/    2DAA :                        
 7772/    2DAA :                        
 7773/    2DAA :                        ;************************************************************************************
 7774/    2DAA :                        ;
 7775/    2DAA :                        ; perform TWOPI
 7776/    2DAA :                        
 7777/    2DAA :                        LAB_TWOPI
 7778/    2DAA : 277C C90F DAA2 0590    	MOVE.l	#$C90FDAA2,FAC1_m(a3)		; 2pi mantissa (32 bit)
 7779/    2DB2 : 377C 8300 0594         	MOVE.w	#$8300,FAC1_e(a3)			; 2pi exponent and sign
 7780/    2DB8 : 4E75                   	RTS
 7781/    2DBA :                        
 7782/    2DBA :                        
 7783/    2DBA :                        ;************************************************************************************
 7784/    2DBA :                        ;
 7785/    2DBA :                        ; get ASCII string equivalent into FAC1 as integer32 or float
 7786/    2DBA :                        
 7787/    2DBA :                        ; entry is with a5 pointing to the first character of the string
 7788/    2DBA :                        ; exit with a5 pointing to the first character after the string
 7789/    2DBA :                        
 7790/    2DBA :                        ; d0 is character
 7791/    2DBA :                        ; d1 is mantissa
 7792/    2DBA :                        ; d2 is partial and table mantissa
 7793/    2DBA :                        ; d3 is mantissa exponent (decimal & binary)
 7794/    2DBA :                        ; d4 is decimal exponent
 7795/    2DBA :                        
 7796/    2DBA :                        ; get FAC1 from string
 7797/    2DBA :                        ; this routine now handles hex and binary values from strings
 7798/    2DBA :                        ; starting with "$" and "%" respectively
 7799/    2DBA :                        
 7800/    2DBA :                        LAB_2887
 7801/    2DBA : 48E7 7C00              	MOVEM.l	d1-d5,-(sp)				; save registers
 7802/    2DBE : 7200                   	MOVEQ		#$00,d1				; clear temp accumulator
 7803/    2DC0 : 2601                   	MOVE.l	d1,d3					; set mantissa decimal exponent count
 7804/    2DC2 : 2801                   	MOVE.l	d1,d4					; clear decimal exponent
 7805/    2DC4 : 1741 0595              	MOVE.b	d1,FAC1_s(a3)			; clear sign byte
 7806/    2DC8 : 1741 05B5              	MOVE.b	d1,Dtypef(a3)			; set float data type
 7807/    2DCC : 1741 05AF              	MOVE.b	d1,expneg(a3)			; clear exponent sign
 7808/    2DD0 : 6100 E4EC              	BSR		LAB_GBYT				; get first byte back
 7809/    2DD4 : 653C                   	BCS.s		LAB_28FE				; go get floating if 1st character numeric
 7810/    2DD6 :                        
 7811/    2DD6 : B03C 002D              	CMP.b		#'-',d0				; or is it -ve number
 7812/    2DDA : 6608                   	BNE.s		LAB_289A				; branch if not
 7813/    2DDC :                        
 7814/    2DDC : 177C 00FF 0595         	MOVE.b	#$FF,FAC1_s(a3)			; set sign byte
 7815/    2DE2 : 6006                   	BRA.s		LAB_289C				; now go scan & check for hex/bin/int
 7816/    2DE4 :                        
 7817/    2DE4 :                        LAB_289A
 7818/    2DE4 :                        								; first character wasn't numeric or -
 7819/    2DE4 : B03C 002B              	CMP.b		#'+',d0				; compare with '+'
 7820/    2DE8 : 6606                   	BNE.s		LAB_289D				; branch if not '+' (go check for '.'/hex/binary
 7821/    2DEA :                        								; /integer)
 7822/    2DEA :                        	
 7823/    2DEA :                        LAB_289C
 7824/    2DEA :                        								; was "+" or "-" to start, so get next character
 7825/    2DEA : 6100 E4D0              	BSR		LAB_IGBY				; increment & scan memory
 7826/    2DEE : 6522                   	BCS.s		LAB_28FE				; branch if numeric character
 7827/    2DF0 :                        
 7828/    2DF0 :                        LAB_289D
 7829/    2DF0 : B03C 002E              	CMP.b		#'.',d0				; else compare with '.'
 7830/    2DF4 : 6700 0092              	BEQ		LAB_2904				; branch if '.'
 7831/    2DF8 :                        
 7832/    2DF8 :                        								; code here for hex/binary/integer numbers
 7833/    2DF8 : B03C 0024              	CMP.b		#'$',d0				; compare with '$'
 7834/    2DFC : 6700 010A              	BEQ		LAB_CHEX				; branch if '$'
 7835/    2E00 :                        
 7836/    2E00 : B03C 0025              	CMP.b		#'%',d0				; else compare with '%'
 7837/    2E04 : 6700 0164              	BEQ		LAB_CBIN				; branch if '%'
 7838/    2E08 :                        
 7839/    2E08 : 6000 008C              	BRA		LAB_2Y01				; not #.$%& so return 0
 7840/    2E0C :                        
 7841/    2E0C :                        LAB_28FD
 7842/    2E0C : 6100 E4AE              	BSR		LAB_IGBY				; get next character
 7843/    2E10 : 646C                   	BCC.s		LAB_2902				; exit loop if not a digit
 7844/    2E12 :                        
 7845/    2E12 :                        LAB_28FE
 7846/    2E12 : 6100 01A8              	BSR		d1x10					; multiply d1 by 10 and add character
 7847/    2E16 : 64F4                   	BCC.s		LAB_28FD				; loop for more if no overflow
 7848/    2E18 :                        
 7849/    2E18 :                        LAB_28FF
 7850/    2E18 :                        								; overflowed mantissa, count 10s exponent
 7851/    2E18 : 5283                   	ADDQ.l	#1,d3					; increment mantissa decimal exponent count
 7852/    2E1A : 6100 E4A0              	BSR		LAB_IGBY				; get next character
 7853/    2E1E : 65F8                   	BCS.s		LAB_28FF				; loop while numeric character
 7854/    2E20 :                        
 7855/    2E20 :                        								; done overflow, now flush fraction or do E
 7856/    2E20 : B03C 002E              	CMP.b		#'.',d0				; else compare with '.'
 7857/    2E24 : 6606                   	BNE.s		LAB_2901				; branch if not '.'
 7858/    2E26 :                        
 7859/    2E26 :                        LAB_2900
 7860/    2E26 :                        								; flush remaining fraction digits
 7861/    2E26 : 6100 E494              	BSR		LAB_IGBY				; get next character
 7862/    2E2A : 65FA                   	BCS		LAB_2900				; loop while numeric character
 7863/    2E2C :                        
 7864/    2E2C :                        LAB_2901
 7865/    2E2C :                        								; done number, only (possible) exponent remains
 7866/    2E2C : B03C 0045              	CMP.b		#'E',d0				; else compare with 'E'
 7867/    2E30 : 6664                   	BNE.s		LAB_2Y01				; if not 'E' all done, go evaluate
 7868/    2E32 :                        
 7869/    2E32 :                        								; process exponent
 7870/    2E32 : 6100 E488              	BSR		LAB_IGBY				; get next character
 7871/    2E36 : 6528                   	BCS.s		LAB_2X04				; branch if digit
 7872/    2E38 :                        
 7873/    2E38 : B03C 002D              	CMP.b		#'-',d0				; or is it -ve number
 7874/    2E3C : 6706                   	BEQ.s		LAB_2X01				; branch if so
 7875/    2E3E :                        
 7876/    2E3E : B03C 00B3              	CMP.b		#TK_MINUS,d0			; or is it -ve number
 7877/    2E42 : 6608                   	BNE.s		LAB_2X02				; branch if not
 7878/    2E44 :                        
 7879/    2E44 :                        LAB_2X01
 7880/    2E44 : 177C 00FF 05AF         	MOVE.b	#$FF,expneg(a3)			; set exponent sign
 7881/    2E4A : 600E                   	BRA.s		LAB_2X03				; now go scan & check exponent
 7882/    2E4C :                        
 7883/    2E4C :                        LAB_2X02
 7884/    2E4C : B03C 002B              	CMP.b		#'+',d0				; or is it +ve number
 7885/    2E50 : 6708                   	BEQ.s		LAB_2X03				; branch if so
 7886/    2E52 :                        
 7887/    2E52 : B03C 00B2              	CMP.b		#TK_PLUS,d0				; or is it +ve number
 7888/    2E56 : 6600 D81E              	BNE		LAB_SNER				; wasn't - + TK_MINUS TK_PLUS or # so do error
 7889/    2E5A :                        
 7890/    2E5A :                        LAB_2X03
 7891/    2E5A : 6100 E460              	BSR		LAB_IGBY				; get next character
 7892/    2E5E : 6436                   	BCC.s		LAB_2Y01				; if not digit all done, go evaluate
 7893/    2E60 :                        LAB_2X04
 7894/    2E60 : C8FC 000A              	MULU		#10,d4				; multiply decimal exponent by 10
 7895/    2E64 : C0BC 0000 00FF         	AND.l		#$FF,d0				; mask character
 7896/    2E6A : 903C 0030              	SUB.b		#'0',d0				; convert to value
 7897/    2E6E : D880                   	ADD.l		d0,d4					; add to decimal exponent
 7898/    2E70 : B83C 0030              	CMP.b		#48,d4				; compare with decimal exponent limit+10
 7899/    2E74 : 6FE4                   	BLE.s		LAB_2X03				; loop if no overflow/underflow
 7900/    2E76 :                        
 7901/    2E76 :                        LAB_2X05
 7902/    2E76 :                        								; exponent value has overflowed
 7903/    2E76 : 6100 E444              	BSR		LAB_IGBY				; get next character
 7904/    2E7A : 65FA                   	BCS.s		LAB_2X05				; loop while numeric digit
 7905/    2E7C :                        
 7906/    2E7C : 6018                   	BRA.s		LAB_2Y01				; all done, go evaluate
 7907/    2E7E :                        
 7908/    2E7E :                        LAB_2902
 7909/    2E7E : B03C 002E              	CMP.b		#'.',d0				; else compare with '.'
 7910/    2E82 : 6704                   	BEQ.s		LAB_2904				; branch if was '.'
 7911/    2E84 :                        
 7912/    2E84 : 60A6                   	BRA.s		LAB_2901				; branch if not '.' (go check/do 'E')
 7913/    2E86 :                        
 7914/    2E86 :                        LAB_2903
 7915/    2E86 : 5383                   	SUBQ.l	#1,d3					; decrement mantissa decimal exponent
 7916/    2E88 :                        LAB_2904
 7917/    2E88 :                        								; was dp so get fraction part
 7918/    2E88 : 6100 E432              	BSR		LAB_IGBY				; get next character
 7919/    2E8C : 649E                   	BCC.s		LAB_2901				; exit loop if not a digit (go check/do 'E')
 7920/    2E8E :                        
 7921/    2E8E : 6100 012C              	BSR		d1x10					; multiply d1 by 10 and add character
 7922/    2E92 : 64F2                   	BCC.s		LAB_2903				; loop for more if no overflow
 7923/    2E94 :                        
 7924/    2E94 : 6090                   	BRA.s		LAB_2900				; else go flush remaining fraction part
 7925/    2E96 :                        
 7926/    2E96 :                        LAB_2Y01
 7927/    2E96 :                        								; now evaluate result
 7928/    2E96 : 4A2B 05AF              	TST.b		expneg(a3)				; test exponent sign
 7929/    2E9A : 6A02                   	BPL.s		LAB_2Y02				; branch if sign positive
 7930/    2E9C :                        
 7931/    2E9C : 4484                   	NEG.l		d4					; negate decimal exponent
 7932/    2E9E :                        LAB_2Y02
 7933/    2E9E : D883                   	ADD.l		d3,d4					; add mantissa decimal exponent
 7934/    2EA0 : 7620                   	MOVEQ		#32,d3				; set up max binary exponent
 7935/    2EA2 : 4A81                   	TST.l		d1					; test mantissa
 7936/    2EA4 : 6752                   	BEQ.s		LAB_rtn0				; if mantissa=0 return 0
 7937/    2EA6 :                        
 7938/    2EA6 : 6B08                   	BMI.s		LAB_2Y04				; branch if already mormalised
 7939/    2EA8 :                        
 7940/    2EA8 : 5383                   	SUBQ.l	#1,d3					; decrement bianry exponent for DBMI loop
 7941/    2EAA :                        LAB_2Y03
 7942/    2EAA : D281                   	ADD.l		d1,d1					; shift mantissa
 7943/    2EAC : 5BCB FFFC              	DBMI		d3,LAB_2Y03				; decrement & loop if not normalised
 7944/    2EB0 :                        
 7945/    2EB0 :                        								; ensure not too big or small
 7946/    2EB0 :                        LAB_2Y04
 7947/    2EB0 : B8BC 0000 0026         	CMP.l		#38,d4				; compare decimal exponent with max exponent
 7948/    2EB6 : 6E00 D7AE              	BGT		LAB_OFER				; if greater do overflow error and warm start
 7949/    2EBA :                        
 7950/    2EBA : B8BC FFFF FFDA         	CMP.l		#-38,d4				; compare decimal exponent with min exponent
 7951/    2EC0 : 6D34                   	BLT.s		LAB_ret0				; if less just return zero
 7952/    2EC2 :                        
 7953/    2EC2 : 4484                   	NEG.l		d4					; negate decimal exponent to go right way
 7954/    2EC4 : C9FC 0006              	MULS		#6,d4					; 6 bytes per entry
 7955/    2EC8 : 2F08                   	MOVE.l	a0,-(sp)				; save register
 7956/    2ECA : 41FA 0210              	LEA		LAB_P_10(pc),a0			; point to table
 7957/    2ECE : 1770 4000 059C         	MOVE.b	(a0,d4.w),FAC2_e(a3)		; copy exponent for multiply
 7958/    2ED4 : 2770 4002 0598         	MOVE.l	2(a0,d4.w),FAC2_m(a3)		; copy table mantissa
 7959/    2EDA : 205F                   	MOVE.l	(sp)+,a0				; restore register
 7960/    2EDC :                        
 7961/    2EDC : 0A03 0080              	EORI.b	#$80,d3				; normalise input exponent
 7962/    2EE0 : 2741 0590              	MOVE.l	d1,FAC1_m(a3)			; save input mantissa
 7963/    2EE4 : 1743 0594              	MOVE.b	d3,FAC1_e(a3)			; save input exponent
 7964/    2EE8 : 176B 0595 059E         	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; set sign as sign compare
 7965/    2EEE :                        
 7966/    2EEE : 4CDF 003E              	MOVEM.l	(sp)+,d1-d5				; restore registers
 7967/    2EF2 : 6000 F050              	BRA		LAB_MULTIPLY			; go multiply input by table
 7968/    2EF6 :                        
 7969/    2EF6 :                        LAB_ret0
 7970/    2EF6 : 7200                   	MOVEQ		#0,d1					; clear mantissa
 7971/    2EF8 :                        LAB_rtn0
 7972/    2EF8 : 2601                   	MOVE.l	d1,d3					; clear exponent
 7973/    2EFA : 1743 0594              	MOVE.b	d3,FAC1_e(a3)			; save exponent
 7974/    2EFE : 2741 0590              	MOVE.l	d1,FAC1_m(a3)			; save mantissa
 7975/    2F02 : 4CDF 003E              	MOVEM.l	(sp)+,d1-d5				; restore registers
 7976/    2F06 : 4E75                   	RTS
 7977/    2F08 :                        
 7978/    2F08 :                        
 7979/    2F08 :                        ;************************************************************************************
 7980/    2F08 :                        ;
 7981/    2F08 :                        ; $ for hex add-on
 7982/    2F08 :                        
 7983/    2F08 :                        ; gets here if the first character was "$" for hex
 7984/    2F08 :                        ; get hex number
 7985/    2F08 :                        
 7986/    2F08 :                        LAB_CHEX
 7987/    2F08 : 177C 0040 05B5         	MOVE.b	#$40,Dtypef(a3)			; set integer numeric data type
 7988/    2F0E : 7620                   	MOVEQ		#32,d3				; set up max binary exponent
 7989/    2F10 :                        LAB_CHXX
 7990/    2F10 : 6100 E3AA              	BSR		LAB_IGBY				; increment & scan memory
 7991/    2F14 : 6514                   	BCS.s		LAB_ISHN				; branch if numeric character
 7992/    2F16 :                        
 7993/    2F16 : 803C 0020              	OR.b		#$20,d0				; case convert, allow "A" to "F" and "a" to "f"
 7994/    2F1A : 903C 0061              	SUB.b		#'a',d0				; subtract "a"
 7995/    2F1E : 652A                   	BCS.s		LAB_CHX3				; exit if <"a"
 7996/    2F20 :                        
 7997/    2F20 : B03C 0006              	CMP.b		#$06,d0				; compare normalised with $06 (max+1)
 7998/    2F24 : 6424                   	BCC.s		LAB_CHX3				; exit if >"f"
 7999/    2F26 :                        
 8000/    2F26 : D03C 003A              	ADD.b		#$3A,d0				; convert to nibble+"0"
 8001/    2F2A :                        LAB_ISHN
 8002/    2F2A : 616C                   	BSR.s		d1x16					; multiply d1 by 16 and add the character
 8003/    2F2C : 64E2                   	BCC.s		LAB_CHXX				; loop for more if no overflow
 8004/    2F2E :                        
 8005/    2F2E :                        								; overflowed mantissa, count 16s exponent
 8006/    2F2E :                        LAB_CHX1
 8007/    2F2E : 5883                   	ADDQ.l	#4,d3					; increment mantissa exponent count
 8008/    2F30 : 6900 D734              	BVS		LAB_OFER				; do overflow error if overflowed
 8009/    2F34 :                        
 8010/    2F34 : 6100 E386              	BSR		LAB_IGBY				; get next character
 8011/    2F38 : 65F4                   	BCS.s		LAB_CHX1				; loop while numeric character
 8012/    2F3A :                        
 8013/    2F3A : 803C 0020              	OR.b		#$20,d0				; case convert, allow "A" to "F" and "a" to "f"
 8014/    2F3E : 903C 0061              	SUB.b		#'a',d0				; subtract "a"
 8015/    2F42 : 6506                   	BCS.s		LAB_CHX3				; exit if <"a"
 8016/    2F44 :                        
 8017/    2F44 : B03C 0006              	CMP.b		#$06,d0				; compare normalised with $06 (max+1)
 8018/    2F48 : 65E4                   	BCS.s		LAB_CHX1				; loop if <="f"
 8019/    2F4A :                        
 8020/    2F4A :                        								; now return value
 8021/    2F4A :                        LAB_CHX3
 8022/    2F4A : 4A81                   	TST.l		d1					; test mantissa
 8023/    2F4C : 67AA                   	BEQ.s		LAB_rtn0				; if mantissa=0 return 0
 8024/    2F4E :                        
 8025/    2F4E : 6B08                   	BMI.s		LAB_exxf				; branch if already mormalised
 8026/    2F50 :                        
 8027/    2F50 : 5383                   	SUBQ.l	#1,d3					; decrement bianry exponent for DBMI loop
 8028/    2F52 :                        LAB_CHX2
 8029/    2F52 : D281                   	ADD.l		d1,d1					; shift mantissa
 8030/    2F54 : 5BCB FFFC              	DBMI		d3,LAB_CHX2				; decrement & loop if not normalised
 8031/    2F58 :                        
 8032/    2F58 :                        LAB_exxf
 8033/    2F58 : 0A03 0080              	EORI.b	#$80,d3				; normalise exponent
 8034/    2F5C : 1743 0594              	MOVE.b	d3,FAC1_e(a3)			; save exponent
 8035/    2F60 : 2741 0590              	MOVE.l	d1,FAC1_m(a3)			; save mantissa
 8036/    2F64 : 4CDF 003E              	MOVEM.l	(sp)+,d1-d5				; restore registers
 8037/    2F68 :                        RTS_024
 8038/    2F68 : 4E75                   	RTS
 8039/    2F6A :                        
 8040/    2F6A :                        
 8041/    2F6A :                        ;************************************************************************************
 8042/    2F6A :                        ;
 8043/    2F6A :                        ; % for binary add-on
 8044/    2F6A :                        
 8045/    2F6A :                        ; gets here if the first character was "%" for binary
 8046/    2F6A :                        ; get binary number
 8047/    2F6A :                        
 8048/    2F6A :                        LAB_CBIN
 8049/    2F6A : 177C 0040 05B5         	MOVE.b	#$40,Dtypef(a3)			; set integer numeric data type
 8050/    2F70 : 7620                   	MOVEQ		#32,d3				; set up max binary exponent
 8051/    2F72 :                        LAB_CBXN
 8052/    2F72 : 6100 E348              	BSR		LAB_IGBY				; increment & scan memory
 8053/    2F76 : 64D2                   	BCC.s		LAB_CHX3				; if not numeric character go return value
 8054/    2F78 :                        
 8055/    2F78 : B03C 0032              	CMP.b		#'2',d0				; compare with "2" (max+1)
 8056/    2F7C : 64CC                   	BCC.s		LAB_CHX3				; if >="2" go return value
 8057/    2F7E :                        
 8058/    2F7E : 2401                   	MOVE.l	d1,d2					; copy value
 8059/    2F80 : 6124                   	BSR.s		d1x02					; multiply d1 by 2 and add character
 8060/    2F82 : 64EE                   	BCC.s		LAB_CBXN				; loop for more if no overflow
 8061/    2F84 :                        
 8062/    2F84 :                        								; overflowed mantissa, count 2s exponent
 8063/    2F84 :                        LAB_CBX1
 8064/    2F84 : 5283                   	ADDQ.l	#1,d3					; increment mantissa exponent count
 8065/    2F86 : 6900 D6DE              	BVS		LAB_OFER				; do overflow error if overflowed
 8066/    2F8A :                        
 8067/    2F8A : 6100 E330              	BSR		LAB_IGBY				; get next character
 8068/    2F8E : 64BA                   	BCC.s		LAB_CHX3				; if not numeric character go return value
 8069/    2F90 :                        
 8070/    2F90 : B03C 0032              	CMP.b		#'2',d0				; compare with "2" (max+1)
 8071/    2F94 : 65EE                   	BCS.s		LAB_CBX1				; loop if <"2"
 8072/    2F96 :                        
 8073/    2F96 : 60B2                   	BRA.s		LAB_CHX3				; if not numeric character go return value
 8074/    2F98 :                        
 8075/    2F98 :                        ; half way decent times 16 and times 2 with overflow checks
 8076/    2F98 :                        
 8077/    2F98 :                        d1x16
 8078/    2F98 : 2401                   	MOVE.l	d1,d2					; copy value
 8079/    2F9A : D482                   	ADD.l		d2,d2					; times two
 8080/    2F9C : 65CA                   	BCS.s		RTS_024				; return if overflow
 8081/    2F9E :                        
 8082/    2F9E : D482                   	ADD.l		d2,d2					; times four
 8083/    2FA0 : 65C6                   	BCS.s		RTS_024				; return if overflow
 8084/    2FA2 :                        
 8085/    2FA2 : D482                   	ADD.l		d2,d2					; times eight
 8086/    2FA4 : 65C2                   	BCS.s		RTS_024				; return if overflow
 8087/    2FA6 :                        
 8088/    2FA6 :                        d1x02
 8089/    2FA6 : D482                   	ADD.l		d2,d2					; times sixteen (ten/two)
 8090/    2FA8 : 65BE                   	BCS.s		RTS_024				; return if overflow
 8091/    2FAA :                        
 8092/    2FAA :                        ; now add in new digit
 8093/    2FAA :                        
 8094/    2FAA : C0BC 0000 00FF         	AND.l		#$FF,d0				; mask character
 8095/    2FB0 : 903C 0030              	SUB.b		#'0',d0				; convert to value
 8096/    2FB4 : D480                   	ADD.l		d0,d2					; add to result
 8097/    2FB6 : 65B0                   	BCS.s		RTS_024				; return if overflow, it should never ever do
 8098/    2FB8 :                        								; this
 8099/    2FB8 :                        
 8100/    2FB8 : 2202                   	MOVE.l	d2,d1					; copy result
 8101/    2FBA : 4E75                   	RTS
 8102/    2FBC :                        
 8103/    2FBC :                        ; half way decent times 10 with overflow checks
 8104/    2FBC :                        
 8105/    2FBC :                        d1x10
 8106/    2FBC : 2401                   	MOVE.l	d1,d2					; copy value
 8107/    2FBE : D482                   	ADD.l		d2,d2					; times two
 8108/    2FC0 : 6508                   	BCS.s		RTS_025				; return if overflow
 8109/    2FC2 :                        
 8110/    2FC2 : D482                   	ADD.l		d2,d2					; times four
 8111/    2FC4 : 6504                   	BCS.s		RTS_025				; return if overflow
 8112/    2FC6 :                        
 8113/    2FC6 : D481                   	ADD.l		d1,d2					; times five
 8114/    2FC8 : 64DC                   	BCC.s		d1x02					; do times two and add in new digit if ok
 8115/    2FCA :                        
 8116/    2FCA :                        RTS_025
 8117/    2FCA : 4E75                   	RTS
 8118/    2FCC :                        
 8119/    2FCC :                        
 8120/    2FCC :                        ;************************************************************************************
 8121/    2FCC :                        ;
 8122/    2FCC :                        ; token values needed for BASIC
 8123/    2FCC :                        
 8124/    2FCC : =$80                   TK_END		EQU $80				; $80
 8125/    2FCC : =$81                   TK_FOR		EQU TK_END+1			; $81
 8126/    2FCC : =$82                   TK_NEXT		EQU TK_FOR+1			; $82
 8127/    2FCC : =$83                   TK_DATA		EQU TK_NEXT+1			; $83
 8128/    2FCC : =$84                   TK_INPUT		EQU TK_DATA+1			; $84
 8129/    2FCC : =$85                   TK_DIM		EQU TK_INPUT+1			; $85
 8130/    2FCC : =$86                   TK_READ		EQU TK_DIM+1			; $86
 8131/    2FCC : =$87                   TK_LET		EQU TK_READ+1			; $87
 8132/    2FCC : =$88                   TK_DEC		EQU TK_LET+1			; $88
 8133/    2FCC : =$89                   TK_GOTO		EQU TK_DEC+1			; $89
 8134/    2FCC : =$8A                   TK_RUN		EQU TK_GOTO+1			; $8A
 8135/    2FCC : =$8B                   TK_IF			EQU TK_RUN+1			; $8B
 8136/    2FCC : =$8C                   TK_RESTORE		EQU TK_IF+1				; $8C
 8137/    2FCC : =$8D                   TK_GOSUB		EQU TK_RESTORE+1			; $8D
 8138/    2FCC : =$8E                   TK_RETURN		EQU TK_GOSUB+1			; $8E
 8139/    2FCC : =$8F                   TK_REM		EQU TK_RETURN+1			; $8F
 8140/    2FCC : =$90                   TK_STOP		EQU TK_REM+1			; $90
 8141/    2FCC : =$91                   TK_ON			EQU TK_STOP+1			; $91
 8142/    2FCC : =$92                   TK_NULL		EQU TK_ON+1				; $92
 8143/    2FCC : =$93                   TK_INC		EQU TK_NULL+1			; $93
 8144/    2FCC : =$94                   TK_WAIT		EQU TK_INC+1			; $94
 8145/    2FCC : =$95                   TK_LOAD		EQU TK_WAIT+1			; $95
 8146/    2FCC : =$96                   TK_SAVE		EQU TK_LOAD+1			; $96
 8147/    2FCC : =$97                   TK_DEF		EQU TK_SAVE+1			; $97
 8148/    2FCC : =$98                   TK_POKE		EQU TK_DEF+1			; $98
 8149/    2FCC : =$99                   TK_DOKE		EQU TK_POKE+1			; $99
 8150/    2FCC : =$9A                   TK_LOKE		EQU TK_DOKE+1			; $9A
 8151/    2FCC : =$9B                   TK_CALL		EQU TK_LOKE+1			; $9B
 8152/    2FCC : =$9C                   TK_DO			EQU TK_CALL+1			; $9C
 8153/    2FCC : =$9D                   TK_LOOP		EQU TK_DO+1				; $9D
 8154/    2FCC : =$9E                   TK_PRINT		EQU TK_LOOP+1			; $9E
 8155/    2FCC : =$9F                   TK_CONT		EQU TK_PRINT+1			; $9F
 8156/    2FCC : =$A0                   TK_LIST		EQU TK_CONT+1			; $A0
 8157/    2FCC : =$A1                   TK_CLEAR		EQU TK_LIST+1			; $A1
 8158/    2FCC : =$A2                   TK_NEW		EQU TK_CLEAR+1			; $A2
 8159/    2FCC : =$A3                   TK_WIDTH		EQU TK_NEW+1			; $A3
 8160/    2FCC : =$A4                   TK_GET		EQU TK_WIDTH+1			; $A4
 8161/    2FCC : =$A5                   TK_SWAP		EQU TK_GET+1			; $A5
 8162/    2FCC : =$A6                   TK_BITSET		EQU TK_SWAP+1			; $A6
 8163/    2FCC : =$A7                   TK_BITCLR		EQU TK_BITSET+1			; $A7
 8164/    2FCC : =$A8                   TK_TAB		EQU TK_BITCLR+1			; $A8
 8165/    2FCC : =$A9                   TK_ELSE		EQU TK_TAB+1			; $A9
 8166/    2FCC : =$AA                   TK_TO			EQU TK_ELSE+1			; $AA
 8167/    2FCC : =$AB                   TK_FN			EQU TK_TO+1				; $AB
 8168/    2FCC : =$AC                   TK_SPC		EQU TK_FN+1				; $AC
 8169/    2FCC : =$AD                   TK_THEN		EQU TK_SPC+1			; $AD
 8170/    2FCC : =$AE                   TK_NOT		EQU TK_THEN+1			; $AE
 8171/    2FCC : =$AF                   TK_STEP		EQU TK_NOT+1			; $AF
 8172/    2FCC : =$B0                   TK_UNTIL		EQU TK_STEP+1			; $B0
 8173/    2FCC : =$B1                   TK_WHILE		EQU TK_UNTIL+1			; $B1
 8174/    2FCC : =$B2                   TK_PLUS		EQU TK_WHILE+1			; $B2
 8175/    2FCC : =$B3                   TK_MINUS		EQU TK_PLUS+1			; $B3
 8176/    2FCC : =$B4                   TK_MULT		EQU TK_MINUS+1			; $B4
 8177/    2FCC : =$B5                   TK_DIV		EQU TK_MULT+1			; $B5
 8178/    2FCC : =$B6                   TK_POWER		EQU TK_DIV+1			; $B6
 8179/    2FCC : =$B7                   TK_AND		EQU TK_POWER+1			; $B7
 8180/    2FCC : =$B8                   TK_EOR		EQU TK_AND+1			; $B8
 8181/    2FCC : =$B9                   TK_OR			EQU TK_EOR+1			; $B9
 8182/    2FCC : =$BA                   TK_RSHIFT		EQU TK_OR+1				; $BA
 8183/    2FCC : =$BB                   TK_LSHIFT		EQU TK_RSHIFT+1			; $BB
 8184/    2FCC : =$BC                   TK_GT			EQU TK_LSHIFT+1			; $BC
 8185/    2FCC : =$BD                   TK_EQUAL		EQU TK_GT+1				; $BD
 8186/    2FCC : =$BE                   TK_LT			EQU TK_EQUAL+1			; $BE
 8187/    2FCC : =$BF                   TK_SGN		EQU TK_LT+1				; $BF
 8188/    2FCC : =$C0                   TK_INT		EQU TK_SGN+1			; $C0
 8189/    2FCC : =$C1                   TK_ABS		EQU TK_INT+1			; $C1
 8190/    2FCC : =$C2                   TK_USR		EQU TK_ABS+1			; $C2
 8191/    2FCC : =$C3                   TK_FRE		EQU TK_USR+1			; $C3
 8192/    2FCC : =$C4                   TK_POS		EQU TK_FRE+1			; $C4
 8193/    2FCC : =$C5                   TK_SQR		EQU TK_POS+1			; $C5
 8194/    2FCC : =$C6                   TK_RND		EQU TK_SQR+1			; $C6
 8195/    2FCC : =$C7                   TK_LOG		EQU TK_RND+1			; $C7
 8196/    2FCC : =$C8                   TK_EXP		EQU TK_LOG+1			; $C8
 8197/    2FCC : =$C9                   TK_COS		EQU TK_EXP+1			; $C9
 8198/    2FCC : =$CA                   TK_SIN		EQU TK_COS+1			; $CA
 8199/    2FCC : =$CB                   TK_TAN		EQU TK_SIN+1			; $CB
 8200/    2FCC : =$CC                   TK_ATN		EQU TK_TAN+1			; $CC
 8201/    2FCC : =$CD                   TK_PEEK		EQU TK_ATN+1			; $CD
 8202/    2FCC : =$CE                   TK_DEEK		EQU TK_PEEK+1			; $CE
 8203/    2FCC : =$CF                   TK_LEEK		EQU TK_DEEK+1			; $CF
 8204/    2FCC : =$D0                   TK_LEN		EQU TK_LEEK+1			; $D0
 8205/    2FCC : =$D1                   TK_STRS		EQU TK_LEN+1			; $D1
 8206/    2FCC : =$D2                   TK_VAL		EQU TK_STRS+1			; $D2
 8207/    2FCC : =$D3                   TK_ASC		EQU TK_VAL+1			; $D3
 8208/    2FCC : =$D4                   TK_UCASES		EQU TK_ASC+1			; $D4
 8209/    2FCC : =$D5                   TK_LCASES		EQU TK_UCASES+1			; $D5
 8210/    2FCC : =$D6                   TK_CHRS		EQU TK_LCASES+1			; $D6
 8211/    2FCC : =$D7                   TK_HEXS		EQU TK_CHRS+1			; $D7
 8212/    2FCC : =$D8                   TK_BINS		EQU TK_HEXS+1			; $D8
 8213/    2FCC : =$D9                   TK_BITTST		EQU TK_BINS+1			; $D9
 8214/    2FCC : =$DA                   TK_MAX		EQU TK_BITTST+1			; $DA
 8215/    2FCC : =$DB                   TK_MIN		EQU TK_MAX+1			; $DB
 8216/    2FCC : =$DC                   TK_RAM		EQU TK_MIN+1			; $DC
 8217/    2FCC : =$DD                   TK_PI			EQU TK_RAM+1			; $DD
 8218/    2FCC : =$DE                   TK_TWOPI		EQU TK_PI+1				; $DE
 8219/    2FCC : =$DF                   TK_VPTR		EQU TK_TWOPI+1			; $DF
 8220/    2FCC : =$E0                   TK_SADD		EQU TK_VPTR+1			; $E0
 8221/    2FCC : =$E1                   TK_LEFTS		EQU TK_SADD+1			; $E1
 8222/    2FCC : =$E2                   TK_RIGHTS		EQU TK_LEFTS+1			; $E2
 8223/    2FCC : =$E3                   TK_MIDS		EQU TK_RIGHTS+1			; $E3
 8224/    2FCC : =$E4                   TK_USINGS		EQU TK_MIDS+1			; $E4
 8225/    2FCC :                        
 8226/    2FCC :                        
 8227/    2FCC :                        ;************************************************************************************
 8228/    2FCC :                        ;
 8229/    2FCC :                        ; binary to unsigned decimal table
 8230/    2FCC :                        
 8231/    2FCC :                        Bin2dec
 8232/    2FCC : 3B9A CA00              	dc.l	$3B9ACA00					; 1000000000
 8233/    2FD0 : 05F5 E100              	dc.l	$05F5E100					; 100000000
 8234/    2FD4 : 0098 9680              	dc.l	$00989680					; 10000000
 8235/    2FD8 : 000F 4240              	dc.l	$000F4240					; 1000000
 8236/    2FDC : 0001 86A0              	dc.l	$000186A0					; 100000
 8237/    2FE0 : 0000 2710              	dc.l	$00002710					; 10000
 8238/    2FE4 : 0000 03E8              	dc.l	$000003E8					; 1000
 8239/    2FE8 : 0000 0064              	dc.l	$00000064					; 100
 8240/    2FEC : 0000 000A              	dc.l	$0000000A					; 10
 8241/    2FF0 : 0000 0000              	dc.l	$00000000					; 0 end marker
 8242/    2FF4 :                        
 8243/    2FF4 :                        LAB_RSED
 8244/    2FF4 : 332E 3232              	dc.l	$332E3232					; 858665522
 8245/    2FF8 :                        
 8246/    2FF8 :                        ; string to value exponent table
 8247/    2FF8 :                        
 8248/    2FF8 : FF00                   	dc.w	255<<8					; 10**38
 8249/    2FFA : 9676 9951              	dc.l	$96769951
 8250/    2FFE : FB00                   	dc.w	251<<8					; 10**37
 8251/    3000 : F0BD C21B              	dc.l	$F0BDC21B
 8252/    3004 : F800                   	dc.w	248<<8					; 10**36
 8253/    3006 : C097 CE7C              	dc.l	$C097CE7C
 8254/    300A : F500                   	dc.w	245<<8					; 10**35
 8255/    300C : 9A13 0B96              	dc.l	$9A130B96
 8256/    3010 : F100                   	dc.w	241<<8					; 10**34
 8257/    3012 : F684 DF57              	dc.l	$F684DF57
 8258/    3016 : EE00                   	dc.w	238<<8					; 10**33
 8259/    3018 : C537 1912              	dc.l	$C5371912
 8260/    301C : EB00                   	dc.w	235<<8					; 10**32
 8261/    301E : 9DC5 ADA8              	dc.l	$9DC5ADA8
 8262/    3022 : E700                   	dc.w	231<<8					; 10**31
 8263/    3024 : FC6F 7C40              	dc.l	$FC6F7C40
 8264/    3028 : E400                   	dc.w	228<<8					; 10**30
 8265/    302A : C9F2 C9CD              	dc.l	$C9F2C9CD
 8266/    302E : E100                   	dc.w	225<<8					; 10**29
 8267/    3030 : A18F 07D7              	dc.l	$A18F07D7
 8268/    3034 : DE00                   	dc.w	222<<8					; 10**28
 8269/    3036 : 813F 3979              	dc.l	$813F3979
 8270/    303A : DA00                   	dc.w	218<<8					; 10**27
 8271/    303C : CECB 8F28              	dc.l	$CECB8F28
 8272/    3040 : D700                   	dc.w	215<<8					; 10**26
 8273/    3042 : A56F A5BA              	dc.l	$A56FA5BA
 8274/    3046 : D400                   	dc.w	212<<8					; 10**25
 8275/    3048 : 8459 5161              	dc.l	$84595161
 8276/    304C : D000                   	dc.w	208<<8					; 10**24
 8277/    304E : D3C2 1BCF              	dc.l	$D3C21BCF
 8278/    3052 : CD00                   	dc.w	205<<8					; 10**23
 8279/    3054 : A968 163F              	dc.l	$A968163F
 8280/    3058 : CA00                   	dc.w	202<<8					; 10**22
 8281/    305A : 8786 7832              	dc.l	$87867832
 8282/    305E : C600                   	dc.w	198<<8					; 10**21
 8283/    3060 : D8D7 26B7              	dc.l	$D8D726B7
 8284/    3064 : C300                   	dc.w	195<<8					; 10**20
 8285/    3066 : AD78 EBC6              	dc.l	$AD78EBC6
 8286/    306A : C000                   	dc.w	192<<8					; 10**19
 8287/    306C : 8AC7 2305              	dc.l	$8AC72305
 8288/    3070 : BC00                   	dc.w	188<<8					; 10**18
 8289/    3072 : DE0B 6B3A              	dc.l	$DE0B6B3A
 8290/    3076 : B900                   	dc.w	185<<8					; 10**17
 8291/    3078 : B1A2 BC2F              	dc.l	$B1A2BC2F
 8292/    307C : B600                   	dc.w	182<<8					; 10**16
 8293/    307E : 8E1B C9BF              	dc.l	$8E1BC9BF
 8294/    3082 : B200                   	dc.w	178<<8					; 10**15
 8295/    3084 : E35F A932              	dc.l	$E35FA932
 8296/    3088 : AF00                   	dc.w	175<<8					; 10**14
 8297/    308A : B5E6 20F5              	dc.l	$B5E620F5
 8298/    308E : AC00                   	dc.w	172<<8					; 10**13
 8299/    3090 : 9184 E72A              	dc.l	$9184E72A
 8300/    3094 : A800                   	dc.w	168<<8					; 10**12
 8301/    3096 : E8D4 A510              	dc.l	$E8D4A510
 8302/    309A : A500                   	dc.w	165<<8					; 10**11
 8303/    309C : BA43 B740              	dc.l	$BA43B740
 8304/    30A0 : A200                   	dc.w	162<<8					; 10**10
 8305/    30A2 : 9502 F900              	dc.l	$9502F900
 8306/    30A6 : 9E00                   	dc.w	158<<8					; 10**9
 8307/    30A8 : EE6B 2800              	dc.l	$EE6B2800
 8308/    30AC : 9B00                   	dc.w	155<<8					; 10**8
 8309/    30AE : BEBC 2000              	dc.l	$BEBC2000
 8310/    30B2 : 9800                   	dc.w	152<<8					; 10**7
 8311/    30B4 : 9896 8000              	dc.l	$98968000
 8312/    30B8 : 9400                   	dc.w	148<<8					; 10**6
 8313/    30BA : F424 0000              	dc.l	$F4240000
 8314/    30BE : 9100                   	dc.w	145<<8					; 10**5
 8315/    30C0 : C350 0000              	dc.l	$C3500000
 8316/    30C4 : 8E00                   	dc.w	142<<8					; 10**4
 8317/    30C6 : 9C40 0000              	dc.l	$9C400000
 8318/    30CA : 8A00                   	dc.w	138<<8					; 10**3
 8319/    30CC : FA00 0000              	dc.l	$FA000000
 8320/    30D0 : 8700                   	dc.w	135<<8					; 10**2
 8321/    30D2 : C800 0000              	dc.l	$C8000000
 8322/    30D6 : 8400                   	dc.w	132<<8					; 10**1
 8323/    30D8 : A000 0000              	dc.l	$A0000000
 8324/    30DC :                        LAB_P_10
 8325/    30DC : 8100                   	dc.w	129<<8					; 10**0
 8326/    30DE : 8000 0000              	dc.l	$80000000
 8327/    30E2 : 7D00                   	dc.w	125<<8					; 10**-1
 8328/    30E4 : CCCC CCCD              	dc.l	$CCCCCCCD
 8329/    30E8 : 7A00                   	dc.w	122<<8					; 10**-2
 8330/    30EA : A3D7 0A3D              	dc.l	$A3D70A3D
 8331/    30EE : 7700                   	dc.w	119<<8					; 10**-3
 8332/    30F0 : 8312 6E98              	dc.l	$83126E98
 8333/    30F4 : 7300                   	dc.w	115<<8					; 10**-4
 8334/    30F6 : D1B7 1759              	dc.l	$D1B71759
 8335/    30FA : 7000                   	dc.w	112<<8					; 10**-5
 8336/    30FC : A7C5 AC47              	dc.l	$A7C5AC47
 8337/    3100 : 6D00                   	dc.w	109<<8					; 10**-6
 8338/    3102 : 8637 BD06              	dc.l	$8637BD06
 8339/    3106 : 6900                   	dc.w	105<<8					; 10**-7
 8340/    3108 : D6BF 94D6              	dc.l	$D6BF94D6
 8341/    310C : 6600                   	dc.w	102<<8					; 10**-8
 8342/    310E : ABCC 7712              	dc.l	$ABCC7712
 8343/    3112 : 6300                   	dc.w	99<<8						; 10**-9
 8344/    3114 : 8970 5F41              	dc.l	$89705F41
 8345/    3118 : 5F00                   	dc.w	95<<8						; 10**-10
 8346/    311A : DBE6 FECF              	dc.l	$DBE6FECF
 8347/    311E : 5C00                   	dc.w	92<<8						; 10**-11
 8348/    3120 : AFEB FF0C              	dc.l	$AFEBFF0C
 8349/    3124 : 5900                   	dc.w	89<<8						; 10**-12
 8350/    3126 : 8CBC CC09              	dc.l	$8CBCCC09
 8351/    312A : 5500                   	dc.w	85<<8						; 10**-13
 8352/    312C : E12E 1342              	dc.l	$E12E1342
 8353/    3130 : 5200                   	dc.w	82<<8						; 10**-14
 8354/    3132 : B424 DC35              	dc.l	$B424DC35
 8355/    3136 : 4F00                   	dc.w	79<<8						; 10**-15
 8356/    3138 : 901D 7CF7              	dc.l	$901D7CF7
 8357/    313C : 4B00                   	dc.w	75<<8						; 10**-16
 8358/    313E : E695 94BF              	dc.l	$E69594BF
 8359/    3142 : 4800                   	dc.w	72<<8						; 10**-17
 8360/    3144 : B877 AA32              	dc.l	$B877AA32
 8361/    3148 : 4500                   	dc.w	69<<8						; 10**-18
 8362/    314A : 9392 EE8F              	dc.l	$9392EE8F
 8363/    314E : 4100                   	dc.w	65<<8						; 10**-19
 8364/    3150 : EC1E 4A7E              	dc.l	$EC1E4A7E
 8365/    3154 : 3E00                   	dc.w	62<<8						; 10**-20
 8366/    3156 : BCE5 0865              	dc.l	$BCE50865
 8367/    315A : 3B00                   	dc.w	59<<8						; 10**-21
 8368/    315C : 971D A050              	dc.l	$971DA050
 8369/    3160 : 3700                   	dc.w	55<<8						; 10**-22
 8370/    3162 : F1C9 0081              	dc.l	$F1C90081
 8371/    3166 : 3400                   	dc.w	52<<8						; 10**-23
 8372/    3168 : C16D 9A01              	dc.l	$C16D9A01
 8373/    316C : 3100                   	dc.w	49<<8						; 10**-24
 8374/    316E : 9ABE 14CD              	dc.l	$9ABE14CD
 8375/    3172 : 2D00                   	dc.w	45<<8						; 10**-25
 8376/    3174 : F796 87AE              	dc.l	$F79687AE
 8377/    3178 : 2A00                   	dc.w	42<<8						; 10**-26
 8378/    317A : C612 0625              	dc.l	$C6120625
 8379/    317E : 2700                   	dc.w	39<<8						; 10**-27
 8380/    3180 : 9E74 D1B8              	dc.l	$9E74D1B8
 8381/    3184 : 2300                   	dc.w	35<<8						; 10**-28
 8382/    3186 : FD87 B5F3              	dc.l	$FD87B5F3
 8383/    318A : 2000                   	dc.w	32<<8						; 10**-29
 8384/    318C : CAD2 F7F5              	dc.l	$CAD2F7F5
 8385/    3190 : 1D00                   	dc.w	29<<8						; 10**-30
 8386/    3192 : A242 5FF7              	dc.l	$A2425FF7
 8387/    3196 : 1A00                   	dc.w	26<<8						; 10**-31
 8388/    3198 : 81CE B32C              	dc.l	$81CEB32C
 8389/    319C : 1600                   	dc.w	22<<8						; 10**-32
 8390/    319E : CFB1 1EAD              	dc.l	$CFB11EAD
 8391/    31A2 : 1300                   	dc.w	19<<8						; 10**-33
 8392/    31A4 : A627 4BBE              	dc.l	$A6274BBE
 8393/    31A8 : 1000                   	dc.w	16<<8						; 10**-34
 8394/    31AA : 84EC 3C98              	dc.l	$84EC3C98
 8395/    31AE : 0C00                   	dc.w	12<<8						; 10**-35
 8396/    31B0 : D4AD 2DC0              	dc.l	$D4AD2DC0
 8397/    31B4 : 0900                   	dc.w	9<<8						; 10**-36
 8398/    31B6 : AA24 2499              	dc.l	$AA242499
 8399/    31BA : 0600                   	dc.w	6<<8						; 10**-37
 8400/    31BC : 881C EA14              	dc.l	$881CEA14
 8401/    31C0 : 0200                   	dc.w	2<<8						; 10**-38
 8402/    31C2 : D9C7 DCED              	dc.l	$D9C7DCED
 8403/    31C6 :                        
 8404/    31C6 :                        
 8405/    31C6 :                        ;************************************************************************************
 8406/    31C6 :                        ;
 8407/    31C6 :                        ; table of constants for cordic SIN/COS/TAN calculations
 8408/    31C6 :                        ; constants are un normalised fractions and are atn(2^-i)/2pi
 8409/    31C6 :                        
 8410/    31C6 : 4DBA 76D4              	dc.l	$4DBA76D4					; SIN/COS multiply constant
 8411/    31CA :                        TAB_SNCO
 8412/    31CA : 2000 0000              	dc.l	$20000000					; atn(2^0)/2pi
 8413/    31CE : 12E4 051E              	dc.l	$12E4051E					; atn(2^1)/2pi
 8414/    31D2 : 09FB 385C              	dc.l	$09FB385C					; atn(2^2)/2pi
 8415/    31D6 : 0511 11D5              	dc.l	$051111D5					; atn(2^3)/2pi
 8416/    31DA : 028B 0D44              	dc.l	$028B0D44					; atn(2^4)/2pi
 8417/    31DE : 0145 D7E2              	dc.l	$0145D7E2					; atn(2^5)/2pi
 8418/    31E2 : 00A2 F61F              	dc.l	$00A2F61F					; atn(2^6)/2pi
 8419/    31E6 : 0051 7C56              	dc.l	$00517C56					; atn(2^7)/2pi
 8420/    31EA : 0028 BE54              	dc.l	$0028BE54					; atn(2^8)/2pi
 8421/    31EE : 0014 5F2F              	dc.l	$00145F2F					; atn(2^9)/2pi
 8422/    31F2 : 000A 2F99              	dc.l	$000A2F99					; atn(2^10)/2pi
 8423/    31F6 : 0005 17CD              	dc.l	$000517CD					; atn(2^11)/2pi
 8424/    31FA : 0002 8BE7              	dc.l	$00028BE7					; atn(2^12)/2pi
 8425/    31FE : 0001 45F4              	dc.l	$000145F4					; atn(2^13)/2pi
 8426/    3202 : 0000 A2FA              	dc.l	$0000A2FA					; atn(2^14)/2pi
 8427/    3206 : 0000 517D              	dc.l	$0000517D					; atn(2^15)/2pi
 8428/    320A : 0000 28BF              	dc.l	$000028BF					; atn(2^16)/2pi
 8429/    320E : 0000 1460              	dc.l	$00001460					; atn(2^17)/2pi
 8430/    3212 : 0000 0A30              	dc.l	$00000A30					; atn(2^18)/2pi
 8431/    3216 : 0000 0518              	dc.l	$00000518					; atn(2^19)/2pi
 8432/    321A : 0000 028C              	dc.l	$0000028C					; atn(2^20)/2pi
 8433/    321E : 0000 0146              	dc.l	$00000146					; atn(2^21)/2pi
 8434/    3222 : 0000 00A3              	dc.l	$000000A3					; atn(2^22)/2pi
 8435/    3226 : 0000 0052              	dc.l	$00000052					; atn(2^23)/2pi
 8436/    322A : 0000 0029              	dc.l	$00000029					; atn(2^24)/2pi
 8437/    322E : 0000 0015              	dc.l	$00000015					; atn(2^25)/2pi
 8438/    3232 : 0000 000B              	dc.l	$0000000B					; atn(2^26)/2pi
 8439/    3236 : 0000 0006              	dc.l	$00000006					; atn(2^27)/2pi
 8440/    323A : 0000 0003              	dc.l	$00000003					; atn(2^28)/2pi
 8441/    323E : 0000 0002              	dc.l	$00000002					; atn(2^29)/2pi
 8442/    3242 : 0000 0001              	dc.l	$00000001					; atn(2^30)/2pi
 8443/    3246 : 0000 0001              	dc.l	$00000001					; atn(2^31)/2pi
 8444/    324A :                        
 8445/    324A :                        
 8446/    324A :                        ;************************************************************************************
 8447/    324A :                        ;
 8448/    324A :                        ; table of constants for cordic ATN calculation
 8449/    324A :                        ; constants are normalised to two integer bits and are atn(2^-i)
 8450/    324A :                        
 8451/    324A :                        TAB_ATNC
 8452/    324A : 1DAC 6705              	dc.l	$1DAC6705					; atn(2^-1)
 8453/    324E : 0FAD BAFD              	dc.l	$0FADBAFD					; atn(2^-2)
 8454/    3252 : 07F5 6EA7              	dc.l	$07F56EA7					; atn(2^-3)
 8455/    3256 : 03FE AB77              	dc.l	$03FEAB77					; atn(2^-4)
 8456/    325A : 01FF D55C              	dc.l	$01FFD55C					; atn(2^-5)
 8457/    325E : 00FF FAAB              	dc.l	$00FFFAAB					; atn(2^-6)
 8458/    3262 : 007F FF55              	dc.l	$007FFF55					; atn(2^-7)
 8459/    3266 : 003F FFEB              	dc.l	$003FFFEB					; atn(2^-8)
 8460/    326A : 001F FFFD              	dc.l	$001FFFFD					; atn(2^-9)
 8461/    326E : 0010 0000              	dc.l	$00100000					; atn(2^-10)
 8462/    3272 : 0008 0000              	dc.l	$00080000					; atn(2^-11)
 8463/    3276 : 0004 0000              	dc.l	$00040000					; atn(2^-12)
 8464/    327A : 0002 0000              	dc.l	$00020000					; atn(2^-13)
 8465/    327E : 0001 0000              	dc.l	$00010000					; atn(2^-14)
 8466/    3282 : 0000 8000              	dc.l	$00008000					; atn(2^-15)
 8467/    3286 : 0000 4000              	dc.l	$00004000					; atn(2^-16)
 8468/    328A : 0000 2000              	dc.l	$00002000					; atn(2^-17)
 8469/    328E : 0000 1000              	dc.l	$00001000					; atn(2^-18)
 8470/    3292 : 0000 0800              	dc.l	$00000800					; atn(2^-19)
 8471/    3296 : 0000 0400              	dc.l	$00000400					; atn(2^-20)
 8472/    329A : 0000 0200              	dc.l	$00000200					; atn(2^-21)
 8473/    329E : 0000 0100              	dc.l	$00000100					; atn(2^-22)
 8474/    32A2 : 0000 0080              	dc.l	$00000080					; atn(2^-23)
 8475/    32A6 : 0000 0040              	dc.l	$00000040					; atn(2^-24)
 8476/    32AA : 0000 0020              	dc.l	$00000020					; atn(2^-25)
 8477/    32AE : 0000 0010              	dc.l	$00000010					; atn(2^-26)
 8478/    32B2 : 0000 0008              	dc.l	$00000008					; atn(2^-27)
 8479/    32B6 : 0000 0004              	dc.l	$00000004					; atn(2^-28)
 8480/    32BA : 0000 0002              	dc.l	$00000002					; atn(2^-29)
 8481/    32BE : 0000 0001              	dc.l	$00000001					; atn(2^-30)
 8482/    32C2 :                        LAB_1D96
 8483/    32C2 : 0000 0000              	dc.l	$00000000					; atn(2^-31)
 8484/    32C6 : 0000 0000              	dc.l	$00000000					; atn(2^-32)
 8485/    32CA :                        
 8486/    32CA :                        ; constants are normalised to n integer bits and are tanh(2^-i)
 8487/    32CA : =$2                    n	equ	2
 8488/    32CA :                        TAB_HTHET
 8489/    32CA : 2327 D4F4              	dc.l	$2327d4f4				; atnh(2^-1) .549306144
 8490/    32CE : 1058 AEFA              	dc.l	$1058aefa				; atnh(2^-2) .255412812
 8491/    32D2 : 080A C48E              	dc.l	$080ac48e				; atnh(2^-3)
 8492/    32D6 : 0401 5622              	dc.l	$04015622				; atnh(2^-4)
 8493/    32DA : 0200 2AB0              	dc.l	$02002ab0				; atnh(2^-5)
 8494/    32DE : 0100 0554              	dc.l	$01000554				; atnh(2^-6)
 8495/    32E2 : 0080 00AA              	dc.l	$008000aa				; atnh(2^-7)
 8496/    32E6 : 0040 0014              	dc.l	$00400014				; atnh(2^-8)
 8497/    32EA : 0020 0002              	dc.l	$00200002				; atnh(2^-9)
 8498/    32EE : 0010 0000              	dc.l	$00100000				; atnh(2^-10)
 8499/    32F2 : 0008 0000              	dc.l	$00080000				; atnh(2^-11)
 8500/    32F6 : 0004 0000              	dc.l	$00040000				; atnh(2^-12)
 8501/    32FA : 0002 0000              	dc.l	$00020000				; atnh(2^-13)
 8502/    32FE : 0001 0000              	dc.l	$00010000				; atnh(2^-14)
 8503/    3302 : 0000 8000              	dc.l	$00008000				; atnh(2^-15)
 8504/    3306 : 0000 4000              	dc.l	$00004000				; atnh(2^-16)
 8505/    330A : 0000 2000              	dc.l	$00002000				; atnh(2^-17)
 8506/    330E : 0000 1000              	dc.l	$00001000				; atnh(2^-18)
 8507/    3312 : 0000 0800              	dc.l	$00000800				; atnh(2^-19)
 8508/    3316 : 0000 0400              	dc.l	$00000400				; atnh(2^-20)
 8509/    331A : 0000 0200              	dc.l	$00000200				; atnh(2^-21)
 8510/    331E : 0000 0100              	dc.l	$00000100				; atnh(2^-22)
 8511/    3322 : 0000 0080              	dc.l	$00000080				; atnh(2^-23)
 8512/    3326 : 0000 0040              	dc.l	$00000040				; atnh(2^-24)
 8513/    332A : 0000 0020              	dc.l	$00000020				; atnh(2^-25)
 8514/    332E : 0000 0010              	dc.l	$00000010				; atnh(2^-26)
 8515/    3332 : 0000 0008              	dc.l	$00000008				; atnh(2^-27)
 8516/    3336 : 0000 0004              	dc.l	$00000004				; atnh(2^-28)
 8517/    333A : 0000 0002              	dc.l	$00000002				; atnh(2^-29)
 8518/    333E : 0000 0001              	dc.l	$00000001				; atnh(2^-30)
 8519/    3342 : 0000 0000              	dc.l	$00000000				; atnh(2^-31)
 8520/    3346 : 0000 0000              	dc.l	$00000000				; atnh(2^-32)
 8521/    334A : =$26A3D110             KFCTSEED	equ	$26A3D110			; $26A3D110
 8522/    334A :                        
 8523/    334A :                        
 8524/    334A :                        ;************************************************************************************
 8525/    334A :                        ;
 8526/    334A :                        ; command vector table
 8527/    334A :                        
 8528/    334A :                        LAB_CTBL
 8529/    334A : D79E                   	dc.w	LAB_END-LAB_CTBL				; END
 8530/    334C : D6D2                   	dc.w	LAB_FOR-LAB_CTBL				; FOR
 8531/    334E : DD44                   	dc.w	LAB_NEXT-LAB_CTBL				; NEXT
 8532/    3350 : D8F2                   	dc.w	LAB_DATA-LAB_CTBL				; DATA
 8533/    3352 : DC38                   	dc.w	LAB_INPUT-LAB_CTBL			; INPUT
 8534/    3354 : E116                   	dc.w	LAB_DIM-LAB_CTBL				; DIM
 8535/    3356 : DC5E                   	dc.w	LAB_READ-LAB_CTBL				; READ
 8536/    3358 : DA6A                   	dc.w	LAB_LET-LAB_CTBL				; LET
 8537/    335A : DA06                   	dc.w	LAB_DEC-LAB_CTBL				; DEC	
 8538/    335C : D85A                   	dc.w	LAB_GOTO-LAB_CTBL				; GOTO
 8539/    335E : D822                   	dc.w	LAB_RUN-LAB_CTBL				; RUN
 8540/    3360 : D91A                   	dc.w	LAB_IF-LAB_CTBL				; IF
 8541/    3362 : D7CC                   	dc.w	LAB_RESTORE-LAB_CTBL			; RESTORE
 8542/    3364 : D848                   	dc.w	LAB_GOSUB-LAB_CTBL			; GOSUB
 8543/    3366 : D8DE                   	dc.w	LAB_RETURN-LAB_CTBL			; RETURN
 8544/    3368 : D98C                   	dc.w	LAB_REM-LAB_CTBL				; REM
 8545/    336A : D7A6                   	dc.w	LAB_STOP-LAB_CTBL				; STOP
 8546/    336C : D994                   	dc.w	LAB_ON-LAB_CTBL				; ON
 8547/    336E : D7FA                   	dc.w	LAB_NULL-LAB_CTBL				; NULL
 8548/    3370 : DA0C                   	dc.w	LAB_INC-LAB_CTBL				; INC	
 8549/    3372 : EA1E                   	dc.w	LAB_WAIT-LAB_CTBL				; WAIT
 8550/    3374 : EA0C                   	dc.w	LAB_LOAD-LAB_CTBL				; LOAD
 8551/    3376 : EA10                   	dc.w	LAB_SAVE-LAB_CTBL				; SAVE
 8552/    3378 : E4A6                   	dc.w	LAB_DEF-LAB_CTBL				; DEF
 8553/    337A : E98C                   	dc.w	LAB_POKE-LAB_CTBL				; POKE
 8554/    337C : E9BC                   	dc.w	LAB_DOKE-LAB_CTBL				; DOKE
 8555/    337E : E9C2                   	dc.w	LAB_LOKE-LAB_CTBL				; LOKE
 8556/    3380 : EA14                   	dc.w	LAB_CALL-LAB_CTBL				; CALL
 8557/    3382 : D836                   	dc.w	LAB_DO-LAB_CTBL				; DO	
 8558/    3384 : D888                   	dc.w	LAB_LOOP-LAB_CTBL				; LOOP
 8559/    3386 : DAFE                   	dc.w	LAB_PRINT-LAB_CTBL			; PRINT
 8560/    3388 : D804                   	dc.w	LAB_CONT-LAB_CTBL				; CONT
 8561/    338A : D61C                   	dc.w	LAB_LIST-LAB_CTBL				; LIST
 8562/    338C : D618                   	dc.w	LAB_CLEAR-LAB_CTBL			; CLEAR
 8563/    338E : D5C6                   	dc.w	LAB_NEW-LAB_CTBL				; NEW
 8564/    3390 : F954                   	dc.w	LAB_WDTH-LAB_CTBL				; WIDTH
 8565/    3392 : DAC4                   	dc.w	LAB_GET-LAB_CTBL				; GET
 8566/    3394 : E9D6                   	dc.w	LAB_SWAP-LAB_CTBL				; SWAP
 8567/    3396 : F49E                   	dc.w	LAB_BITSET-LAB_CTBL			; BITSET
 8568/    3398 : F4AE                   	dc.w	LAB_BITCLR-LAB_CTBL			; BITCLR
 8569/    339A :                        
 8570/    339A :                        
 8571/    339A :                        ;************************************************************************************
 8572/    339A :                        ;
 8573/    339A :                        ; function pre process routine table
 8574/    339A :                        
 8575/    339A :                        LAB_FTPP
 8576/    339A : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; SGN(n)	process numeric expression in ()
 8577/    339C : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; INT(n)		"
 8578/    339E : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; ABS(n)		"
 8579/    33A0 : DDC4                   	dc.w	LAB_EVEZ-LAB_FTPP				; USR(x)	process any expression
 8580/    33A2 : DF0C                   	dc.w	LAB_1BF7-LAB_FTPP				; FRE(x)	process any expression in ()
 8581/    33A4 : DF0C                   	dc.w	LAB_1BF7-LAB_FTPP				; POS(x)		"
 8582/    33A6 : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; SQR(n)	process numeric expression in ()
 8583/    33A8 : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; RND(n)		"
 8584/    33AA : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; LOG(n)		"
 8585/    33AC : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; EXP(n)		"
 8586/    33AE : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; COS(n)		"
 8587/    33B0 : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; SIN(n)		"
 8588/    33B2 : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; TAN(n)		"
 8589/    33B4 : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; ATN(n)		"
 8590/    33B6 : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; PEEK(n)		"
 8591/    33B8 : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; DEEK(n)		"
 8592/    33BA : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; LEEK(n)		"
 8593/    33BC : DFB6                   	dc.w	LAB_PPFS-LAB_FTPP				; LEN($)	process string expression in ()
 8594/    33BE : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; STR$(n)	process numeric expression in ()
 8595/    33C0 : DFB6                   	dc.w	LAB_PPFS-LAB_FTPP				; VAL($)	process string expression in ()
 8596/    33C2 : DFB6                   	dc.w	LAB_PPFS-LAB_FTPP				; ASC($)		"
 8597/    33C4 : DFB6                   	dc.w	LAB_PPFS-LAB_FTPP				; UCASE$($)		"
 8598/    33C6 : DFB6                   	dc.w	LAB_PPFS-LAB_FTPP				; LCASE$($)		"
 8599/    33C8 : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; CHR$(n)	process numeric expression in ()
 8600/    33CA : DFFE                   	dc.w	LAB_BHSS-LAB_FTPP				; HEX$()	bin/hex pre process
 8601/    33CC : DFFE                   	dc.w	LAB_BHSS-LAB_FTPP				; BIN$()		"
 8602/    33CE : 0000                   	dc.w	$0000						; BITTST()	none
 8603/    33D0 : 0000                   	dc.w	$0000						; MAX()		"
 8604/    33D2 : 0000                   	dc.w	$0000						; MIN()		"
 8605/    33D4 : DFD2                   	dc.w	LAB_PPBI-LAB_FTPP				; RAMBASE	advance pointer
 8606/    33D6 : DFD2                   	dc.w	LAB_PPBI-LAB_FTPP				; PI			"
 8607/    33D8 : DFD2                   	dc.w	LAB_PPBI-LAB_FTPP				; TWOPI		"
 8608/    33DA : 0000                   	dc.w	$0000						; VARPTR()	none
 8609/    33DC : 0000                   	dc.w	$0000						; SADD()		"
 8610/    33DE : DFDC                   	dc.w	LAB_LRMS-LAB_FTPP				; LEFT$()	process string expression
 8611/    33E0 : DFDC                   	dc.w	LAB_LRMS-LAB_FTPP				; RIGHT$()		"
 8612/    33E2 : DFDC                   	dc.w	LAB_LRMS-LAB_FTPP				; MID$()		"
 8613/    33E4 : DDC4                   	dc.w	LAB_EVEZ-LAB_FTPP				; USING$(x)	process any expression
 8614/    33E6 :                        
 8615/    33E6 :                        
 8616/    33E6 :                        ;************************************************************************************
 8617/    33E6 :                        ;
 8618/    33E6 :                        ; action addresses for functions
 8619/    33E6 :                        
 8620/    33E6 :                        LAB_FTBL
 8621/    33E6 : ED4A                   	dc.w	LAB_SGN-LAB_FTBL				; SGN()
 8622/    33E8 : EDCE                   	dc.w	LAB_INT-LAB_FTBL				; INT()
 8623/    33EA : ED5C                   	dc.w	LAB_ABS-LAB_FTBL				; ABS()
 8624/    33EC : E968                   	dc.w	LAB_USR-LAB_FTBL				; USR()
 8625/    33EE : E3C2                   	dc.w	LAB_FRE-LAB_FTBL				; FRE()
 8626/    33F0 : E3F4                   	dc.w	LAB_POS-LAB_FTBL				; POS()
 8627/    33F2 : F938                   	dc.w	LAB_SQR-LAB_FTBL				; SQR()
 8628/    33F4 : F21C                   	dc.w	LAB_RND-LAB_FTBL				; RND()
 8629/    33F6 : EA6C                   	dc.w	LAB_LOG-LAB_FTBL				; LOG()
 8630/    33F8 : F102                   	dc.w	LAB_EXP-LAB_FTBL				; EXP()
 8631/    33FA : F270                   	dc.w	LAB_COS-LAB_FTBL				; COS()
 8632/    33FC : F288                   	dc.w	LAB_SIN-LAB_FTBL				; SIN()
 8633/    33FE : F24E                   	dc.w	LAB_TAN-LAB_FTBL				; TAN()
 8634/    3400 : F34E                   	dc.w	LAB_ATN-LAB_FTBL				; ATN()
 8635/    3402 : E8E4                   	dc.w	LAB_PEEK-LAB_FTBL				; PEEK()
 8636/    3404 : E8F6                   	dc.w	LAB_DEEK-LAB_FTBL				; DEEK()
 8637/    3406 : E90C                   	dc.w	LAB_LEEK-LAB_FTBL				; LEEK()
 8638/    3408 : E826                   	dc.w	LAB_LENS-LAB_FTBL				; LEN()
 8639/    340A : E4EA                   	dc.w	LAB_STRS-LAB_FTBL				; STR$()
 8640/    340C : E86C                   	dc.w	LAB_VAL-LAB_FTBL				; VAL()
 8641/    340E : E82E                   	dc.w	LAB_ASC-LAB_FTBL				; ASC()
 8642/    3410 : E7DC                   	dc.w	LAB_UCASE-LAB_FTBL			; UCASE$()
 8643/    3412 : E7AC                   	dc.w	LAB_LCASE-LAB_FTBL			; LCASE$()
 8644/    3414 : E714                   	dc.w	LAB_CHRS-LAB_FTBL				; CHR$()
 8645/    3416 : F7DA                   	dc.w	LAB_HEXS-LAB_FTBL				; HEX$()
 8646/    3418 : F788                   	dc.w	LAB_BINS-LAB_FTBL				; BIN$()
 8647/    341A : F422                   	dc.w	LAB_BTST-LAB_FTBL				; BITTST()
 8648/    341C : F846                   	dc.w	LAB_MAX-LAB_FTBL				; MAX()
 8649/    341E : F85C                   	dc.w	LAB_MIN-LAB_FTBL				; MIN()
 8650/    3420 : F9AA                   	dc.w	LAB_RAM-LAB_FTBL				; RAMBASE
 8651/    3422 : F9B4                   	dc.w	LAB_PI-LAB_FTBL				; PI
 8652/    3424 : F9C4                   	dc.w	LAB_TWOPI-LAB_FTBL			; TWOPI
 8653/    3426 : F99A                   	dc.w	LAB_VARPTR-LAB_FTBL			; VARPTR()
 8654/    3428 : E80E                   	dc.w	LAB_SADD-LAB_FTBL				; SADD()
 8655/    342A : E724                   	dc.w	LAB_LEFT-LAB_FTBL				; LEFT$()
 8656/    342C : E738                   	dc.w	LAB_RIGHT-LAB_FTBL			; RIGHT$()
 8657/    342E : E768                   	dc.w	LAB_MIDS-LAB_FTBL				; MID$()
 8658/    3430 : F450                   	dc.w	LAB_USINGS-LAB_FTBL			; USING$()
 8659/    3432 :                        
 8660/    3432 :                        
 8661/    3432 :                        ;************************************************************************************
 8662/    3432 :                        ;
 8663/    3432 :                        ; hierarchy and action addresses for operator
 8664/    3432 :                        
 8665/    3432 :                        LAB_OPPT
 8666/    3432 : 0079                   	dc.w	$0079						; +
 8667/    3434 : E96E                   	dc.w	LAB_ADD-LAB_OPPT
 8668/    3436 : 0079                   	dc.w	$0079						; -
 8669/    3438 : E95A                   	dc.w	LAB_SUBTRACT-LAB_OPPT
 8670/    343A : 007B                   	dc.w	$007B						; *
 8671/    343C : EB12                   	dc.w	LAB_MULTIPLY-LAB_OPPT
 8672/    343E : 007B                   	dc.w	$007B						; /
 8673/    3440 : EB9E                   	dc.w	LAB_DIVIDE-LAB_OPPT
 8674/    3442 : 007F                   	dc.w	$007F						; ^
 8675/    3444 : F000                   	dc.w	LAB_POWER-LAB_OPPT
 8676/    3446 : 0050                   	dc.w	$0050						; AND
 8677/    3448 : DFA6                   	dc.w	LAB_AND-LAB_OPPT
 8678/    344A : 0046                   	dc.w	$0046						; EOR
 8679/    344C : DF96                   	dc.w	LAB_EOR-LAB_OPPT
 8680/    344E : 0046                   	dc.w	$0046						; OR
 8681/    3450 : DF9E                   	dc.w	LAB_OR-LAB_OPPT
 8682/    3452 : 0056                   	dc.w	$0056						; >>
 8683/    3454 : E04A                   	dc.w	LAB_RSHIFT-LAB_OPPT
 8684/    3456 : 0056                   	dc.w	$0056						; <<
 8685/    3458 : E03A                   	dc.w	LAB_LSHIFT-LAB_OPPT
 8686/    345A : 007D                   	dc.w	$007D						; >
 8687/    345C : F064                   	dc.w	LAB_GTHAN-LAB_OPPT			; used to evaluate -n
 8688/    345E : 005A                   	dc.w	$005A						; =
 8689/    3460 : DFBC                   	dc.w	LAB_EQUAL-LAB_OPPT			; used to evaluate NOT
 8690/    3462 : 0064                   	dc.w	$0064						; <
 8691/    3464 : DFC6                   	dc.w	LAB_LTHAN-LAB_OPPT
 8692/    3466 :                        
 8693/    3466 :                        
 8694/    3466 :                        ;************************************************************************************
 8695/    3466 :                        ;
 8696/    3466 :                        ; misc constants
 8697/    3466 :                        
 8698/    3466 :                        ; This table is used in converting numbers to ASCII.
 8699/    3466 :                        ; first four entries for expansion to 9.25 digits
 8700/    3466 :                        
 8701/    3466 :                        LAB_2A9A
 8702/    3466 : FFF0 BDC0              	dc.l	$FFF0BDC0					; -1000000
 8703/    346A : 0001 86A0              	dc.l	$000186A0					; 100000
 8704/    346E : FFFF D8F0              	dc.l	$FFFFD8F0					; -10000
 8705/    3472 : 0000 03E8              	dc.l	$000003E8					; 1000
 8706/    3476 : FFFF FF9C              	dc.l	$FFFFFF9C					; -100
 8707/    347A : 0000 000A              	dc.l	$0000000A					; 10
 8708/    347E : FFFF FFFF              	dc.l	$FFFFFFFF					; -1
 8709/    3482 :                        LAB_2A9B
 8710/    3482 :                        
 8711/    3482 :                        
 8712/    3482 :                        ;************************************************************************************
 8713/    3482 :                        ;
 8714/    3482 :                        ; new keyword tables
 8715/    3482 :                        
 8716/    3482 :                        ; offsets to keyword tables
 8717/    3482 :                        
 8718/    3482 :                        TAB_CHRT
 8719/    3482 : 0000                   	dc.w	TAB_STAR-TAB_STAR				; "*"	$2A
 8720/    3484 : 0002                   	dc.w	TAB_PLUS-TAB_STAR				; "+"	$2B
 8721/    3486 : FFFF                   	dc.w	-1						; "," $2C no keywords
 8722/    3488 : 0004                   	dc.w	TAB_MNUS-TAB_STAR				; "-"	$2D
 8723/    348A : FFFF                   	dc.w	-1						; "." $2E no keywords
 8724/    348C : 0006                   	dc.w	TAB_SLAS-TAB_STAR				; "/"	$2F
 8725/    348E : FFFF                   	dc.w	-1						; "0" $30 no keywords
 8726/    3490 : FFFF                   	dc.w	-1						; "1" $31 no keywords
 8727/    3492 : FFFF                   	dc.w	-1						; "2" $32 no keywords
 8728/    3494 : FFFF                   	dc.w	-1						; "3" $33 no keywords
 8729/    3496 : FFFF                   	dc.w	-1						; "4" $34 no keywords
 8730/    3498 : FFFF                   	dc.w	-1						; "5" $35 no keywords
 8731/    349A : FFFF                   	dc.w	-1						; "6" $36 no keywords
 8732/    349C : FFFF                   	dc.w	-1						; "7" $37 no keywords
 8733/    349E : FFFF                   	dc.w	-1						; "8" $38 no keywords
 8734/    34A0 : FFFF                   	dc.w	-1						; "9" $39 no keywords
 8735/    34A2 : FFFF                   	dc.w	-1						; ";" $3A no keywords
 8736/    34A4 : FFFF                   	dc.w	-1						; ":" $3B no keywords
 8737/    34A6 : 0008                   	dc.w	TAB_LESS-TAB_STAR				; "<"	$3C
 8738/    34A8 : 000C                   	dc.w	TAB_EQUL-TAB_STAR				; "="	$3D
 8739/    34AA : 000E                   	dc.w	TAB_MORE-TAB_STAR				; ">"	$3E
 8740/    34AC : 0012                   	dc.w	TAB_QEST-TAB_STAR				; "?"	$3F
 8741/    34AE : FFFF                   	dc.w	-1						; "@" $40 no keywords
 8742/    34B0 : 0014                   	dc.w	TAB_ASCA-TAB_STAR				; "A"	$41
 8743/    34B2 : 0024                   	dc.w	TAB_ASCB-TAB_STAR				; "B"	$42
 8744/    34B4 : 003D                   	dc.w	TAB_ASCC-TAB_STAR				; "C"	$43
 8745/    34B6 : 0054                   	dc.w	TAB_ASCD-TAB_STAR				; "D"	$44
 8746/    34B8 : 006D                   	dc.w	TAB_ASCE-TAB_STAR				; "E"	$45
 8747/    34BA : 007C                   	dc.w	TAB_ASCF-TAB_STAR				; "F"	$46
 8748/    34BC : 0086                   	dc.w	TAB_ASCG-TAB_STAR				; "G"	$47
 8749/    34BE : 0093                   	dc.w	TAB_ASCH-TAB_STAR				; "H"	$48
 8750/    34C0 : 0099                   	dc.w	TAB_ASCI-TAB_STAR				; "I"	$49
 8751/    34C2 : FFFF                   	dc.w	-1						; "J" $4A no keywords
 8752/    34C4 : FFFF                   	dc.w	-1						; "K" $4B no keywords
 8753/    34C6 : 00A8                   	dc.w	TAB_ASCL-TAB_STAR				; "L"	$4C
 8754/    34C8 : 00D6                   	dc.w	TAB_ASCM-TAB_STAR				; "M"	$4D
 8755/    34CA : 00E4                   	dc.w	TAB_ASCN-TAB_STAR				; "N"	$4E
 8756/    34CC : 00F3                   	dc.w	TAB_ASCO-TAB_STAR				; "O"	$4F
 8757/    34CE : 00F8                   	dc.w	TAB_ASCP-TAB_STAR				; "P"	$50
 8758/    34D0 : FFFF                   	dc.w	-1						; "Q" $51 no keywords
 8759/    34D2 : 010D                   	dc.w	TAB_ASCR-TAB_STAR				; "R"	$52
 8760/    34D4 : 0137                   	dc.w	TAB_ASCS-TAB_STAR				; "S"	$53
 8761/    34D6 : 0162                   	dc.w	TAB_ASCT-TAB_STAR				; "T"	$54
 8762/    34D8 : 0176                   	dc.w	TAB_ASCU-TAB_STAR				; "U"	$55
 8763/    34DA : 018E                   	dc.w	TAB_ASCV-TAB_STAR				; "V"	$56
 8764/    34DC : 019A                   	dc.w	TAB_ASCW-TAB_STAR				; "W"	$57
 8765/    34DE : FFFF                   	dc.w	-1						; "X" $58 no keywords
 8766/    34E0 : FFFF                   	dc.w	-1						; "Y" $59 no keywords
 8767/    34E2 : FFFF                   	dc.w	-1						; "Z" $5A no keywords
 8768/    34E4 : FFFF                   	dc.w	-1						; "[" $5B no keywords
 8769/    34E6 : FFFF                   	dc.w	-1						; "\" $5C no keywords
 8770/    34E8 : FFFF                   	dc.w	-1						; "]" $5D no keywords
 8771/    34EA : 01A9                   	dc.w	TAB_POWR-TAB_STAR				; "^"	$5E
 8772/    34EC :                        
 8773/    34EC :                        
 8774/    34EC :                        ;************************************************************************************
 8775/    34EC :                        ;
 8776/    34EC :                        ; Table of Basic keywords for LIST command
 8777/    34EC :                        ; [byte]first character,[byte]remaining length -1
 8778/    34EC :                        ; [word]offset from table start
 8779/    34EC :                        
 8780/    34EC :                        LAB_KEYT
 8781/    34EC : 4501                   	dc.b	'E',1
 8782/    34EE : 0071                   	dc.w	KEY_END-TAB_STAR				; END
 8783/    34F0 : 4601                   	dc.b	'F',1
 8784/    34F2 : 007C                   	dc.w	KEY_FOR-TAB_STAR				; FOR
 8785/    34F4 : 4E02                   	dc.b	'N',2
 8786/    34F6 : 00E7                   	dc.w	KEY_NEXT-TAB_STAR				; NEXT
 8787/    34F8 : 4402                   	dc.b	'D',2
 8788/    34FA : 0054                   	dc.w	KEY_DATA-TAB_STAR				; DATA
 8789/    34FC : 4903                   	dc.b	'I',3
 8790/    34FE : 009E                   	dc.w	KEY_INPUT-TAB_STAR			; INPUT
 8791/    3500 : 4401                   	dc.b	'D',1
 8792/    3502 : 0063                   	dc.w	KEY_DIM-TAB_STAR				; DIM
 8793/    3504 : 5202                   	dc.b	'R',2
 8794/    3506 : 0114                   	dc.w	KEY_READ-TAB_STAR				; READ
 8795/    3508 : 4C01                   	dc.b	'L',1
 8796/    350A : 00BE                   	dc.w	KEY_LET-TAB_STAR				; LET
 8797/    350C : 4401                   	dc.b	'D',1
 8798/    350E : 0058                   	dc.w	KEY_DEC-TAB_STAR				; DEC
 8799/    3510 : 4702                   	dc.b	'G',2
 8800/    3512 : 0089                   	dc.w	KEY_GOTO-TAB_STAR				; GOTO
 8801/    3514 : 5201                   	dc.b	'R',1
 8802/    3516 : 0133                   	dc.w	KEY_RUN-TAB_STAR				; RUN
 8803/    3518 : 4900                   	dc.b	'I',0
 8804/    351A : 0099                   	dc.w	KEY_IF-TAB_STAR				; IF
 8805/    351C : 5205                   	dc.b	'R',5
 8806/    351E : 011B                   	dc.w	KEY_RESTORE-TAB_STAR			; RESTORE
 8807/    3520 : 4703                   	dc.b	'G',3
 8808/    3522 : 008D                   	dc.w	KEY_GOSUB-TAB_STAR			; GOSUB
 8809/    3524 : 5204                   	dc.b	'R',4
 8810/    3526 : 0122                   	dc.w	KEY_RETURN-TAB_STAR			; RETURN
 8811/    3528 : 5201                   	dc.b	'R',1
 8812/    352A : 0118                   	dc.w	KEY_REM-TAB_STAR				; REM
 8813/    352C : 5302                   	dc.b	'S',2
 8814/    352E : 0154                   	dc.w	KEY_STOP-TAB_STAR				; STOP
 8815/    3530 : 4F00                   	dc.b	'O',0
 8816/    3532 : 00F3                   	dc.w	KEY_ON-TAB_STAR				; ON
 8817/    3534 : 4E02                   	dc.b	'N',2
 8818/    3536 : 00EE                   	dc.w	KEY_NULL-TAB_STAR				; NULL
 8819/    3538 : 4901                   	dc.b	'I',1
 8820/    353A : 009B                   	dc.w	KEY_INC-TAB_STAR				; INC
 8821/    353C : 5702                   	dc.b	'W',2
 8822/    353E : 019A                   	dc.w	KEY_WAIT-TAB_STAR				; WAIT
 8823/    3540 : 4C02                   	dc.b	'L',2
 8824/    3542 : 00C5                   	dc.w	KEY_LOAD-TAB_STAR				; LOAD
 8825/    3544 : 5302                   	dc.b	'S',2
 8826/    3546 : 013C                   	dc.w	KEY_SAVE-TAB_STAR				; SAVE
 8827/    3548 : 4401                   	dc.b	'D',1
 8828/    354A : 0060                   	dc.w	KEY_DEF-TAB_STAR				; DEF
 8829/    354C : 5002                   	dc.b	'P',2
 8830/    354E : 00FF                   	dc.w	KEY_POKE-TAB_STAR				; POKE
 8831/    3550 : 4402                   	dc.b	'D',2
 8832/    3552 : 0066                   	dc.w	KEY_DOKE-TAB_STAR				; DOKE
 8833/    3554 : 4C02                   	dc.b	'L',2
 8834/    3556 : 00CD                   	dc.w	KEY_LOKE-TAB_STAR				; LOKE
 8835/    3558 : 4302                   	dc.b	'C',2
 8836/    355A : 003D                   	dc.w	KEY_CALL-TAB_STAR				; CALL
 8837/    355C : 4400                   	dc.b	'D',0
 8838/    355E : 006A                   	dc.w	KEY_DO-TAB_STAR				; DO
 8839/    3560 : 4C02                   	dc.b	'L',2
 8840/    3562 : 00D1                   	dc.w	KEY_LOOP-TAB_STAR				; LOOP
 8841/    3564 : 5003                   	dc.b	'P',3
 8842/    3566 : 0107                   	dc.w	KEY_PRINT-TAB_STAR			; PRINT
 8843/    3568 : 4302                   	dc.b	'C',2
 8844/    356A : 004B                   	dc.w	KEY_CONT-TAB_STAR				; CONT
 8845/    356C : 4C02                   	dc.b	'L',2
 8846/    356E : 00C1                   	dc.w	KEY_LIST-TAB_STAR				; LIST
 8847/    3570 : 4303                   	dc.b	'C',3
 8848/    3572 : 0046                   	dc.w	KEY_CLEAR-TAB_STAR			; CLEAR
 8849/    3574 : 4E01                   	dc.b	'N',1
 8850/    3576 : 00E4                   	dc.w	KEY_NEW-TAB_STAR				; NEW
 8851/    3578 : 5703                   	dc.b	'W',3
 8852/    357A : 01A3                   	dc.w	KEY_WIDTH-TAB_STAR			; WIDTH
 8853/    357C : 4701                   	dc.b	'G',1
 8854/    357E : 0086                   	dc.w	KEY_GET-TAB_STAR				; GET
 8855/    3580 : 5302                   	dc.b	'S',2
 8856/    3582 : 015D                   	dc.w	KEY_SWAP-TAB_STAR				; SWAP
 8857/    3584 : 4204                   	dc.b	'B',4
 8858/    3586 : 002F                   	dc.w	KEY_BITSET-TAB_STAR			; BITSET
 8859/    3588 : 4204                   	dc.b	'B',4
 8860/    358A : 0029                   	dc.w	KEY_BITCLR-TAB_STAR			; BITCLR
 8861/    358C : 5402                   	dc.b	'T',2
 8862/    358E : 0162                   	dc.w	KEY_TAB-TAB_STAR				; TAB(
 8863/    3590 : 4502                   	dc.b	'E',2
 8864/    3592 : 006D                   	dc.w	KEY_ELSE-TAB_STAR				; ELSE
 8865/    3594 : 5400                   	dc.b	'T',0
 8866/    3596 : 016E                   	dc.w	KEY_TO-TAB_STAR				; TO
 8867/    3598 : 4600                   	dc.b	'F',0
 8868/    359A : 007F                   	dc.w	KEY_FN-TAB_STAR				; FN
 8869/    359C : 5302                   	dc.b	'S',2
 8870/    359E : 0148                   	dc.w	KEY_SPC-TAB_STAR				; SPC(
 8871/    35A0 : 5402                   	dc.b	'T',2
 8872/    35A2 : 016A                   	dc.w	KEY_THEN-TAB_STAR				; THEN
 8873/    35A4 : 4E01                   	dc.b	'N',1
 8874/    35A6 : 00EB                   	dc.w	KEY_NOT-TAB_STAR				; NOT
 8875/    35A8 : 5302                   	dc.b	'S',2
 8876/    35AA : 0150                   	dc.w	KEY_STEP-TAB_STAR				; STEP
 8877/    35AC : 5503                   	dc.b	'U',3
 8878/    35AE : 017D                   	dc.w	KEY_UNTIL-TAB_STAR			; UNTIL
 8879/    35B0 : 5703                   	dc.b	'W',3
 8880/    35B2 : 019E                   	dc.w	KEY_WHILE-TAB_STAR			; WHILE
 8881/    35B4 :                        
 8882/    35B4 : 2BFF                   	dc.b	'+',-1
 8883/    35B6 : 0002                   	dc.w	KEY_PLUS-TAB_STAR				; +
 8884/    35B8 : 2DFF                   	dc.b	'-',-1
 8885/    35BA : 0004                   	dc.w	KEY_MINUS-TAB_STAR			; -
 8886/    35BC : 2AFF                   	dc.b	'*',-1
 8887/    35BE : 0000                   	dc.w	KEY_MULT-TAB_STAR				; *
 8888/    35C0 : 2FFF                   	dc.b	'/',-1
 8889/    35C2 : 0006                   	dc.w	KEY_DIV-TAB_STAR				; /
 8890/    35C4 : 5EFF                   	dc.b	'^',-1
 8891/    35C6 : 01A9                   	dc.w	KEY_POWER-TAB_STAR			; ^
 8892/    35C8 : 4101                   	dc.b	'A',1
 8893/    35CA : 0018                   	dc.w	KEY_AND-TAB_STAR				; AND
 8894/    35CC : 4501                   	dc.b	'E',1
 8895/    35CE : 0074                   	dc.w	KEY_EOR-TAB_STAR				; EOR
 8896/    35D0 : 4F00                   	dc.b	'O',0
 8897/    35D2 : 00F5                   	dc.w	KEY_OR-TAB_STAR				; OR
 8898/    35D4 : 3E00                   	dc.b	'>',0
 8899/    35D6 : 000E                   	dc.w	KEY_RSHIFT-TAB_STAR			; >>
 8900/    35D8 : 3C00                   	dc.b	'<',0
 8901/    35DA : 0008                   	dc.w	KEY_LSHIFT-TAB_STAR			; <<
 8902/    35DC : 3EFF                   	dc.b	'>',-1
 8903/    35DE : 0010                   	dc.w	KEY_GT-TAB_STAR				; >
 8904/    35E0 : 3DFF                   	dc.b	'=',-1
 8905/    35E2 : 000C                   	dc.w	KEY_EQUAL-TAB_STAR			; =
 8906/    35E4 : 3CFF                   	dc.b	'<',-1
 8907/    35E6 : 000A                   	dc.w	KEY_LT-TAB_STAR				; <
 8908/    35E8 :                        
 8909/    35E8 : 5302                   	dc.b	'S',2
 8910/    35EA : 0140                   	dc.w	KEY_SGN-TAB_STAR				; SGN(
 8911/    35EC : 4902                   	dc.b	'I',2
 8912/    35EE : 00A3                   	dc.w	KEY_INT-TAB_STAR				; INT(
 8913/    35F0 : 4102                   	dc.b	'A',2
 8914/    35F2 : 0014                   	dc.w	KEY_ABS-TAB_STAR				; ABS(
 8915/    35F4 : 5502                   	dc.b	'U',2
 8916/    35F6 : 0189                   	dc.w	KEY_USR-TAB_STAR				; USR(
 8917/    35F8 : 4602                   	dc.b	'F',2
 8918/    35FA : 0081                   	dc.w	KEY_FRE-TAB_STAR				; FRE(
 8919/    35FC : 5002                   	dc.b	'P',2
 8920/    35FE : 0103                   	dc.w	KEY_POS-TAB_STAR				; POS(
 8921/    3600 : 5302                   	dc.b	'S',2
 8922/    3602 : 014C                   	dc.w	KEY_SQR-TAB_STAR				; SQR(
 8923/    3604 : 5202                   	dc.b	'R',2
 8924/    3606 : 012F                   	dc.w	KEY_RND-TAB_STAR				; RND(
 8925/    3608 : 4C02                   	dc.b	'L',2
 8926/    360A : 00C9                   	dc.w	KEY_LOG-TAB_STAR				; LOG(
 8927/    360C : 4502                   	dc.b	'E',2
 8928/    360E : 0077                   	dc.w	KEY_EXP-TAB_STAR				; EXP(
 8929/    3610 : 4302                   	dc.b	'C',2
 8930/    3612 : 004F                   	dc.w	KEY_COS-TAB_STAR				; COS(
 8931/    3614 : 5302                   	dc.b	'S',2
 8932/    3616 : 0144                   	dc.w	KEY_SIN-TAB_STAR				; SIN(
 8933/    3618 : 5402                   	dc.b	'T',2
 8934/    361A : 0166                   	dc.w	KEY_TAN-TAB_STAR				; TAN(
 8935/    361C : 4102                   	dc.b	'A',2
 8936/    361E : 001F                   	dc.w	KEY_ATN-TAB_STAR				; ATN(
 8937/    3620 : 5003                   	dc.b	'P',3
 8938/    3622 : 00F8                   	dc.w	KEY_PEEK-TAB_STAR				; PEEK(
 8939/    3624 : 4403                   	dc.b	'D',3
 8940/    3626 : 005B                   	dc.w	KEY_DEEK-TAB_STAR				; DEEK(
 8941/    3628 : 4C03                   	dc.b	'L',3
 8942/    362A : 00AF                   	dc.w	KEY_LEEK-TAB_STAR				; LEEK(
 8943/    362C : 4C02                   	dc.b	'L',2
 8944/    362E : 00BA                   	dc.w	KEY_LEN-TAB_STAR				; LEN(
 8945/    3630 : 5303                   	dc.b	'S',3
 8946/    3632 : 0158                   	dc.w	KEY_STRS-TAB_STAR				; STR$(
 8947/    3634 : 5602                   	dc.b	'V',2
 8948/    3636 : 018E                   	dc.w	KEY_VAL-TAB_STAR				; VAL(
 8949/    3638 : 4102                   	dc.b	'A',2
 8950/    363A : 001B                   	dc.w	KEY_ASC-TAB_STAR				; ASC(
 8951/    363C : 5505                   	dc.b	'U',5
 8952/    363E : 0176                   	dc.w	KEY_UCASES-TAB_STAR			; UCASE$(
 8953/    3640 : 4C05                   	dc.b	'L',5
 8954/    3642 : 00A8                   	dc.w	KEY_LCASES-TAB_STAR			; LCASE$(
 8955/    3644 : 4303                   	dc.b	'C',3
 8956/    3646 : 0041                   	dc.w	KEY_CHRS-TAB_STAR				; CHR$(
 8957/    3648 : 4803                   	dc.b	'H',3
 8958/    364A : 0093                   	dc.w	KEY_HEXS-TAB_STAR				; HEX$(
 8959/    364C : 4203                   	dc.b	'B',3
 8960/    364E : 0024                   	dc.w	KEY_BINS-TAB_STAR				; BIN$(
 8961/    3650 : 4205                   	dc.b	'B',5
 8962/    3652 : 0035                   	dc.w	KEY_BITTST-TAB_STAR			; BITTST(
 8963/    3654 : 4D02                   	dc.b	'M',2
 8964/    3656 : 00D6                   	dc.w	KEY_MAX-TAB_STAR				; MAX(
 8965/    3658 : 4D02                   	dc.b	'M',2
 8966/    365A : 00DF                   	dc.w	KEY_MIN-TAB_STAR				; MIN(
 8967/    365C : 5205                   	dc.b	'R',5
 8968/    365E : 010D                   	dc.w	KEY_RAM-TAB_STAR				; RAMBASE
 8969/    3660 : 5000                   	dc.b	'P',0
 8970/    3662 : 00FD                   	dc.w	KEY_PI-TAB_STAR				; PI
 8971/    3664 : 5403                   	dc.b	'T',3
 8972/    3666 : 0170                   	dc.w	KEY_TWOPI-TAB_STAR			; TWOPI
 8973/    3668 : 5605                   	dc.b	'V',5
 8974/    366A : 0192                   	dc.w	KEY_VPTR-TAB_STAR				; VARPTR(
 8975/    366C : 5303                   	dc.b	'S',3
 8976/    366E : 0137                   	dc.w	KEY_SADD-TAB_STAR				; SADD(
 8977/    3670 : 4C04                   	dc.b	'L',4
 8978/    3672 : 00B4                   	dc.w	KEY_LEFTS-TAB_STAR			; LEFT$(
 8979/    3674 : 5205                   	dc.b	'R',5
 8980/    3676 : 0128                   	dc.w	KEY_RIGHTS-TAB_STAR			; RIGHT$(
 8981/    3678 : 4D03                   	dc.b	'M',3
 8982/    367A : 00DA                   	dc.w	KEY_MIDS-TAB_STAR				; MID$(
 8983/    367C : 5505                   	dc.b	'U',5
 8984/    367E : 0182                   	dc.w	KEY_USINGS-TAB_STAR			; USING$(
 8985/    3680 :                        
 8986/    3680 :                        
 8987/    3680 :                        ;************************************************************************************
 8988/    3680 :                        ;
 8989/    3680 :                        ; BASIC error messages
 8990/    3680 :                        
 8991/    3680 :                        LAB_BAER
 8992/    3680 : 0030                   	dc.w	LAB_NF-LAB_BAER				; $00 NEXT without FOR
 8993/    3682 : 0041                   	dc.w	LAB_SN-LAB_BAER				; $02 syntax
 8994/    3684 : 0048                   	dc.w	LAB_RG-LAB_BAER				; $04 RETURN without GOSUB
 8995/    3686 : 005D                   	dc.w	LAB_OD-LAB_BAER				; $06 out of data
 8996/    3688 : 0069                   	dc.w	LAB_FC-LAB_BAER				; $08 function call
 8997/    368A : 0077                   	dc.w	LAB_OV-LAB_BAER				; $0A overflow
 8998/    368C : 0080                   	dc.w	LAB_OM-LAB_BAER				; $0C out of memory
 8999/    368E : 008E                   	dc.w	LAB_US-LAB_BAER				; $0E undefined statement
 9000/    3690 : 00A2                   	dc.w	LAB_BS-LAB_BAER				; $10 array bounds
 9001/    3692 : 00AF                   	dc.w	LAB_DD-LAB_BAER				; $12 double dimension array
 9002/    3694 : 00C0                   	dc.w	LAB_D0-LAB_BAER				; $14 divide by 0
 9003/    3696 : 00CF                   	dc.w	LAB_ID-LAB_BAER				; $16 illegal direct
 9004/    3698 : 00DE                   	dc.w	LAB_TM-LAB_BAER				; $18 type mismatch
 9005/    369A : 00EC                   	dc.w	LAB_LS-LAB_BAER				; $1A long string
 9006/    369C : 00FC                   	dc.w	LAB_ST-LAB_BAER				; $1C string too complex
 9007/    369E : 010F                   	dc.w	LAB_CN-LAB_BAER				; $1E continue error
 9008/    36A0 : 011E                   	dc.w	LAB_UF-LAB_BAER				; $20 undefined function
 9009/    36A2 : 0131                   	dc.w	LAB_LD-LAB_BAER				; $22 LOOP without DO
 9010/    36A4 : 0141                   	dc.w	LAB_UV-LAB_BAER				; $24 undefined variable
 9011/    36A6 : 0154                   	dc.w	LAB_UA-LAB_BAER				; $26 undimensioned array
 9012/    36A8 : 0168                   	dc.w	LAB_WD-LAB_BAER				; $28 wrong dimensions
 9013/    36AA : 0179                   	dc.w	LAB_AD-LAB_BAER				; $2A address
 9014/    36AC : 0181                   	dc.w	LAB_FO-LAB_BAER				; $2C format
 9015/    36AE : 0188                   	dc.w	LAB_NI-LAB_BAER				; $2E not implemented
 9016/    36B0 :                        
 9017/    36B0 : 4E45 5854 2077 6974    LAB_NF	dc.b	'NEXT without FOR',$00
          36B8 : 686F 7574 2046 4F52 00
 9018/    36C1 : 5379 6E74 6178 00      LAB_SN	dc.b	'Syntax',$00
 9019/    36C8 : 5245 5455 524E 2077    LAB_RG	dc.b	'RETURN without GOSUB',$00
          36D0 : 6974 686F 7574 2047
          36D8 : 4F53 5542 00         
 9020/    36DD : 4F75 7420 6F66 2044    LAB_OD	dc.b	'Out of DATA',$00
          36E5 : 4154 4100            
 9021/    36E9 : 4675 6E63 7469 6F6E    LAB_FC	dc.b	'Function call',$00
          36F1 : 2063 616C 6C00      
 9022/    36F7 : 4F76 6572 666C 6F77 00 LAB_OV	dc.b	'Overflow',$00
 9023/    3700 : 4F75 7420 6F66 206D    LAB_OM	dc.b	'Out of memory',$00
          3708 : 656D 6F72 7900      
 9024/    370E : 556E 6465 6669 6E65    LAB_US	dc.b	'Undefined statement',$00
          3716 : 6420 7374 6174 656D
          371E : 656E 7400            
 9025/    3722 : 4172 7261 7920 626F    LAB_BS	dc.b	'Array bounds',$00
          372A : 756E 6473 00         
 9026/    372F : 446F 7562 6C65 2064    LAB_DD	dc.b	'Double dimension',$00
          3737 : 696D 656E 7369 6F6E 00
 9027/    3740 : 4469 7669 6465 2062    LAB_D0	dc.b	'Divide by zero',$00
          3748 : 7920 7A65 726F 00   
 9028/    374F : 496C 6C65 6761 6C20    LAB_ID	dc.b	'Illegal direct',$00
          3757 : 6469 7265 6374 00   
 9029/    375E : 5479 7065 206D 6973    LAB_TM	dc.b	'Type mismatch',$00
          3766 : 6D61 7463 6800      
 9030/    376C : 5374 7269 6E67 2074    LAB_LS	dc.b	'String too long',$00
          3774 : 6F6F 206C 6F6E 6700   
 9031/    377C : 5374 7269 6E67 2074    LAB_ST	dc.b	'String too complex',$00
          3784 : 6F6F 2063 6F6D 706C
          378C : 6578 00               
 9032/    378F : 4361 6E27 7420 636F    LAB_CN	dc.b	"Can't continue",$00
          3797 : 6E74 696E 7565 00   
 9033/    379E : 556E 6465 6669 6E65    LAB_UF	dc.b	'Undefined function',$00
          37A6 : 6420 6675 6E63 7469
          37AE : 6F6E 00               
 9034/    37B1 : 4C4F 4F50 2077 6974    LAB_LD	dc.b	'LOOP without DO',$00
          37B9 : 686F 7574 2044 4F00   
 9035/    37C1 : 556E 6465 6669 6E65    LAB_UV	dc.b	'Undefined variable',$00
          37C9 : 6420 7661 7269 6162
          37D1 : 6C65 00               
 9036/    37D4 : 556E 6469 6D65 6E73    LAB_UA	dc.b	'Undimensioned array',$00
          37DC : 696F 6E65 6420 6172
          37E4 : 7261 7900            
 9037/    37E8 : 5772 6F6E 6720 6469    LAB_WD	dc.b	'Wrong dimensions',$00
          37F0 : 6D65 6E73 696F 6E73 00
 9038/    37F9 : 4164 6472 6573 7300    LAB_AD	dc.b	'Address',$00
 9039/    3801 : 466F 726D 6174 00      LAB_FO	dc.b	'Format',$00
 9040/    3808 : 4E6F 7420 696D 706C    LAB_NI  dc.b    'Not implemented',$00
          3810 : 656D 656E 7465 6400   
 9041/    3818 :                        
 9042/    3818 :                        
 9043/    3818 :                        ;************************************************************************************
 9044/    3818 :                        ;
 9045/    3818 :                        ; keyword table for line (un)crunching
 9046/    3818 :                        
 9047/    3818 :                        ; [keyword,token
 9048/    3818 :                        ; [keyword,token]]
 9049/    3818 :                        ; end marker (#$00)
 9050/    3818 :                        
 9051/    3818 :                        TAB_STAR
 9052/    3818 :                        KEY_MULT
 9053/    3818 : B400                   	dc.b TK_MULT,$00					; *
 9054/    381A :                        TAB_PLUS
 9055/    381A :                        KEY_PLUS
 9056/    381A : B200                   	dc.b TK_PLUS,$00					; +
 9057/    381C :                        TAB_MNUS
 9058/    381C :                        KEY_MINUS
 9059/    381C : B300                   	dc.b TK_MINUS,$00					; -
 9060/    381E :                        TAB_SLAS
 9061/    381E :                        KEY_DIV
 9062/    381E : B500                   	dc.b TK_DIV,$00					; /
 9063/    3820 :                        TAB_LESS
 9064/    3820 :                        KEY_LSHIFT
 9065/    3820 : 3CBB                   	dc.b	'<',TK_LSHIFT				; <<
 9066/    3822 :                        KEY_LT
 9067/    3822 : BE                     	dc.b TK_LT						; <
 9068/    3823 : 00                     	dc.b	$00
 9069/    3824 :                        TAB_EQUL
 9070/    3824 :                        KEY_EQUAL
 9071/    3824 : BD00                   	dc.b TK_EQUAL,$00					; =
 9072/    3826 :                        TAB_MORE
 9073/    3826 :                        KEY_RSHIFT
 9074/    3826 : 3EBA                   	dc.b	'>',TK_RSHIFT				; >>
 9075/    3828 :                        KEY_GT
 9076/    3828 : BC                     	dc.b TK_GT						; >
 9077/    3829 : 00                     	dc.b	$00
 9078/    382A :                        TAB_QEST
 9079/    382A : 9E00                   	dc.b TK_PRINT,$00					; ?
 9080/    382C :                        TAB_ASCA
 9081/    382C :                        KEY_ABS
 9082/    382C : 4253 28C1              	dc.b	'BS(',TK_ABS				; ABS(
 9083/    3830 :                        KEY_AND
 9084/    3830 : 4E44 B7                	dc.b	'ND',TK_AND					; AND
 9085/    3833 :                        KEY_ASC
 9086/    3833 : 5343 28D3              	dc.b	'SC(',TK_ASC				; ASC(
 9087/    3837 :                        KEY_ATN
 9088/    3837 : 544E 28CC              	dc.b	'TN(',TK_ATN				; ATN(
 9089/    383B : 00                     	dc.b	$00
 9090/    383C :                        TAB_ASCB
 9091/    383C :                        KEY_BINS
 9092/    383C : 494E 2428 D8           	dc.b	'IN$(',TK_BINS				; BIN$(
 9093/    3841 :                        KEY_BITCLR
 9094/    3841 : 4954 434C 52A7         	dc.b	'ITCLR',TK_BITCLR				; BITCLR
 9095/    3847 :                        KEY_BITSET
 9096/    3847 : 4954 5345 54A6         	dc.b	'ITSET',TK_BITSET				; BITSET
 9097/    384D :                        KEY_BITTST
 9098/    384D : 4954 5453 5428 D9      	dc.b	'ITTST(',TK_BITTST			; BITTST(
 9099/    3854 : 00                     	dc.b	$00
 9100/    3855 :                        TAB_ASCC
 9101/    3855 :                        KEY_CALL
 9102/    3855 : 414C 4C9B              	dc.b	'ALL',TK_CALL				; CALL
 9103/    3859 :                        KEY_CHRS
 9104/    3859 : 4852 2428 D6           	dc.b	'HR$(',TK_CHRS				; CHR$(
 9105/    385E :                        KEY_CLEAR
 9106/    385E : 4C45 4152 A1           	dc.b	'LEAR',TK_CLEAR				; CLEAR
 9107/    3863 :                        KEY_CONT
 9108/    3863 : 4F4E 549F              	dc.b	'ONT',TK_CONT				; CONT
 9109/    3867 :                        KEY_COS
 9110/    3867 : 4F53 28C9              	dc.b	'OS(',TK_COS				; COS(
 9111/    386B : 00                     	dc.b	$00
 9112/    386C :                        TAB_ASCD
 9113/    386C :                        KEY_DATA
 9114/    386C : 4154 4183              	dc.b	'ATA',TK_DATA				; DATA
 9115/    3870 :                        KEY_DEC
 9116/    3870 : 4543 88                	dc.b	'EC',TK_DEC					; DEC
 9117/    3873 :                        KEY_DEEK
 9118/    3873 : 4545 4B28 CE           	dc.b	'EEK(',TK_DEEK				; DEEK(
 9119/    3878 :                        KEY_DEF
 9120/    3878 : 4546 97                	dc.b	'EF',TK_DEF					; DEF
 9121/    387B :                        KEY_DIM
 9122/    387B : 494D 85                	dc.b	'IM',TK_DIM					; DIM
 9123/    387E :                        KEY_DOKE
 9124/    387E : 4F4B 4599              	dc.b	'OKE',TK_DOKE				; DOKE
 9125/    3882 :                        KEY_DO
 9126/    3882 : 4F9C                   	dc.b	'O',TK_DO					; DO
 9127/    3884 : 00                     	dc.b	$00
 9128/    3885 :                        TAB_ASCE
 9129/    3885 :                        KEY_ELSE
 9130/    3885 : 4C53 45A9              	dc.b	'LSE',TK_ELSE				; ELSE
 9131/    3889 :                        KEY_END
 9132/    3889 : 4E44 80                	dc.b	'ND',TK_END					; END
 9133/    388C :                        KEY_EOR
 9134/    388C : 4F52 B8                	dc.b	'OR',TK_EOR					; EOR
 9135/    388F :                        KEY_EXP
 9136/    388F : 5850 28C8              	dc.b	'XP(',TK_EXP				; EXP(
 9137/    3893 : 00                     	dc.b	$00
 9138/    3894 :                        TAB_ASCF
 9139/    3894 :                        KEY_FOR
 9140/    3894 : 4F52 81                	dc.b	'OR',TK_FOR					; FOR
 9141/    3897 :                        KEY_FN
 9142/    3897 : 4EAB                   	dc.b	'N',TK_FN					; FN
 9143/    3899 :                        KEY_FRE
 9144/    3899 : 5245 28C3              	dc.b	'RE(',TK_FRE				; FRE(
 9145/    389D : 00                     	dc.b	$00
 9146/    389E :                        TAB_ASCG
 9147/    389E :                        KEY_GET
 9148/    389E : 4554 A4                	dc.b	'ET',TK_GET					; GET
 9149/    38A1 :                        KEY_GOTO
 9150/    38A1 : 4F54 4F89              	dc.b	'OTO',TK_GOTO				; GOTO
 9151/    38A5 :                        KEY_GOSUB
 9152/    38A5 : 4F53 5542 8D           	dc.b	'OSUB',TK_GOSUB				; GOSUB
 9153/    38AA : 00                     	dc.b	$00
 9154/    38AB :                        TAB_ASCH
 9155/    38AB :                        KEY_HEXS
 9156/    38AB : 4558 2428 D700         	dc.b	'EX$(',TK_HEXS,$00			; HEX$(
 9157/    38B1 :                        TAB_ASCI
 9158/    38B1 :                        KEY_IF
 9159/    38B1 : 468B                   	dc.b	'F',TK_IF					; IF
 9160/    38B3 :                        KEY_INC
 9161/    38B3 : 4E43 93                	dc.b	'NC',TK_INC					; INC
 9162/    38B6 :                        KEY_INPUT
 9163/    38B6 : 4E50 5554 84           	dc.b	'NPUT',TK_INPUT				; INPUT
 9164/    38BB :                        KEY_INT
 9165/    38BB : 4E54 28C0              	dc.b	'NT(',TK_INT				; INT(
 9166/    38BF : 00                     	dc.b	$00
 9167/    38C0 :                        TAB_ASCL
 9168/    38C0 :                        KEY_LCASES
 9169/    38C0 : 4341 5345 2428 D5      	dc.b	'CASE$(',TK_LCASES			; LCASE$(
 9170/    38C7 :                        KEY_LEEK
 9171/    38C7 : 4545 4B28 CF           	dc.b	'EEK(',TK_LEEK				; LEEK(
 9172/    38CC :                        KEY_LEFTS
 9173/    38CC : 4546 5424 28E1         	dc.b	'EFT$(',TK_LEFTS				; LEFT$(
 9174/    38D2 :                        KEY_LEN
 9175/    38D2 : 454E 28D0              	dc.b	'EN(',TK_LEN				; LEN(
 9176/    38D6 :                        KEY_LET
 9177/    38D6 : 4554 87                	dc.b	'ET',TK_LET					; LET
 9178/    38D9 :                        KEY_LIST
 9179/    38D9 : 4953 54A0              	dc.b	'IST',TK_LIST				; LIST
 9180/    38DD :                        KEY_LOAD
 9181/    38DD : 4F41 4495              	dc.b	'OAD',TK_LOAD				; LOAD
 9182/    38E1 :                        KEY_LOG
 9183/    38E1 : 4F47 28C7              	dc.b	'OG(',TK_LOG				; LOG(
 9184/    38E5 :                        KEY_LOKE
 9185/    38E5 : 4F4B 459A              	dc.b	'OKE',TK_LOKE				; LOKE
 9186/    38E9 :                        KEY_LOOP
 9187/    38E9 : 4F4F 509D              	dc.b	'OOP',TK_LOOP				; LOOP
 9188/    38ED : 00                     	dc.b	$00
 9189/    38EE :                        TAB_ASCM
 9190/    38EE :                        KEY_MAX
 9191/    38EE : 4158 28DA              	dc.b	'AX(',TK_MAX				; MAX(
 9192/    38F2 :                        KEY_MIDS
 9193/    38F2 : 4944 2428 E3           	dc.b	'ID$(',TK_MIDS				; MID$(
 9194/    38F7 :                        KEY_MIN
 9195/    38F7 : 494E 28DB              	dc.b	'IN(',TK_MIN				; MIN(
 9196/    38FB : 00                     	dc.b	$00
 9197/    38FC :                        TAB_ASCN
 9198/    38FC :                        KEY_NEW
 9199/    38FC : 4557 A2                	dc.b	'EW',TK_NEW					; NEW
 9200/    38FF :                        KEY_NEXT
 9201/    38FF : 4558 5482              	dc.b	'EXT',TK_NEXT				; NEXT
 9202/    3903 :                        KEY_NOT
 9203/    3903 : 4F54 AE                	dc.b	'OT',TK_NOT					; NOT
 9204/    3906 :                        KEY_NULL
 9205/    3906 : 554C 4C92              	dc.b	'ULL',TK_NULL				; NULL
 9206/    390A : 00                     	dc.b	$00
 9207/    390B :                        TAB_ASCO
 9208/    390B :                        KEY_ON
 9209/    390B : 4E91                   	dc.b	'N',TK_ON					; ON
 9210/    390D :                        KEY_OR
 9211/    390D : 52B9                   	dc.b	'R',TK_OR					; OR
 9212/    390F : 00                     	dc.b	$00
 9213/    3910 :                        TAB_ASCP
 9214/    3910 :                        KEY_PEEK
 9215/    3910 : 4545 4B28 CD           	dc.b	'EEK(',TK_PEEK				; PEEK(
 9216/    3915 :                        KEY_PI
 9217/    3915 : 49DD                   	dc.b	'I',TK_PI					; PI
 9218/    3917 :                        KEY_POKE
 9219/    3917 : 4F4B 4598              	dc.b	'OKE',TK_POKE				; POKE
 9220/    391B :                        KEY_POS
 9221/    391B : 4F53 28C4              	dc.b	'OS(',TK_POS				; POS(
 9222/    391F :                        KEY_PRINT
 9223/    391F : 5249 4E54 9E           	dc.b	'RINT',TK_PRINT				; PRINT
 9224/    3924 : 00                     	dc.b	$00
 9225/    3925 :                        TAB_ASCR
 9226/    3925 :                        KEY_RAM
 9227/    3925 : 414D 4241 5345 DC      	dc.b	'AMBASE',TK_RAM				; RAMBASE
 9228/    392C :                        KEY_READ
 9229/    392C : 4541 4486              	dc.b	'EAD',TK_READ				; READ
 9230/    3930 :                        KEY_REM
 9231/    3930 : 454D 8F                	dc.b	'EM',TK_REM					; REM
 9232/    3933 :                        KEY_RESTORE
 9233/    3933 : 4553 544F 5245 8C      	dc.b	'ESTORE',TK_RESTORE			; RESTORE
 9234/    393A :                        KEY_RETURN
 9235/    393A : 4554 5552 4E8E         	dc.b	'ETURN',TK_RETURN				; RETURN
 9236/    3940 :                        KEY_RIGHTS
 9237/    3940 : 4947 4854 2428 E2      	dc.b	'IGHT$(',TK_RIGHTS			; RIGHT$(
 9238/    3947 :                        KEY_RND
 9239/    3947 : 4E44 28C6              	dc.b	'ND(',TK_RND				; RND(
 9240/    394B :                        KEY_RUN
 9241/    394B : 554E 8A                	dc.b	'UN',TK_RUN					; RUN
 9242/    394E : 00                     	dc.b	$00
 9243/    394F :                        TAB_ASCS
 9244/    394F :                        KEY_SADD
 9245/    394F : 4144 4428 E0           	dc.b	'ADD(',TK_SADD				; SADD(
 9246/    3954 :                        KEY_SAVE
 9247/    3954 : 4156 4596              	dc.b	'AVE',TK_SAVE				; SAVE
 9248/    3958 :                        KEY_SGN
 9249/    3958 : 474E 28BF              	dc.b	'GN(',TK_SGN				; SGN(
 9250/    395C :                        KEY_SIN
 9251/    395C : 494E 28CA              	dc.b	'IN(',TK_SIN				; SIN(
 9252/    3960 :                        KEY_SPC
 9253/    3960 : 5043 28AC              	dc.b	'PC(',TK_SPC				; SPC(
 9254/    3964 :                        KEY_SQR
 9255/    3964 : 5152 28C5              	dc.b	'QR(',TK_SQR				; SQR(
 9256/    3968 :                        KEY_STEP
 9257/    3968 : 5445 50AF              	dc.b	'TEP',TK_STEP				; STEP
 9258/    396C :                        KEY_STOP
 9259/    396C : 544F 5090              	dc.b	'TOP',TK_STOP				; STOP
 9260/    3970 :                        KEY_STRS
 9261/    3970 : 5452 2428 D1           	dc.b	'TR$(',TK_STRS				; STR$(
 9262/    3975 :                        KEY_SWAP
 9263/    3975 : 5741 50A5              	dc.b	'WAP',TK_SWAP				; SWAP
 9264/    3979 : 00                     	dc.b	$00
 9265/    397A :                        TAB_ASCT
 9266/    397A :                        KEY_TAB
 9267/    397A : 4142 28A8              	dc.b	'AB(',TK_TAB				; TAB(
 9268/    397E :                        KEY_TAN
 9269/    397E : 414E 28CB              	dc.b	'AN(',TK_TAN				; TAN
 9270/    3982 :                        KEY_THEN
 9271/    3982 : 4845 4EAD              	dc.b	'HEN',TK_THEN				; THEN
 9272/    3986 :                        KEY_TO
 9273/    3986 : 4FAA                   	dc.b	'O',TK_TO					; TO
 9274/    3988 :                        KEY_TWOPI
 9275/    3988 : 574F 5049 DE           	dc.b	'WOPI',TK_TWOPI				; TWOPI
 9276/    398D : 00                     	dc.b	$00
 9277/    398E :                        TAB_ASCU
 9278/    398E :                        KEY_UCASES
 9279/    398E : 4341 5345 2428 D4      	dc.b	'CASE$(',TK_UCASES			; UCASE$(
 9280/    3995 :                        KEY_UNTIL
 9281/    3995 : 4E54 494C B0           	dc.b	'NTIL',TK_UNTIL				; UNTIL
 9282/    399A :                        KEY_USINGS
 9283/    399A : 5349 4E47 2428 E4      	dc.b	'SING$(',TK_USINGS			; USING$(
 9284/    39A1 :                        KEY_USR
 9285/    39A1 : 5352 28C2              	dc.b	'SR(',TK_USR				; USR(
 9286/    39A5 : 00                     	dc.b	$00
 9287/    39A6 :                        TAB_ASCV
 9288/    39A6 :                        KEY_VAL
 9289/    39A6 : 414C 28D2              	dc.b	'AL(',TK_VAL				; VAL(
 9290/    39AA :                        KEY_VPTR
 9291/    39AA : 4152 5054 5228 DF      	dc.b	'ARPTR(',TK_VPTR				; VARPTR(
 9292/    39B1 : 00                     	dc.b	$00
 9293/    39B2 :                        TAB_ASCW
 9294/    39B2 :                        KEY_WAIT
 9295/    39B2 : 4149 5494              	dc.b	'AIT',TK_WAIT				; WAIT
 9296/    39B6 :                        KEY_WHILE
 9297/    39B6 : 4849 4C45 B1           	dc.b	'HILE',TK_WHILE				; WHILE
 9298/    39BB :                        KEY_WIDTH
 9299/    39BB : 4944 5448 A3           	dc.b	'IDTH',TK_WIDTH				; WIDTH
 9300/    39C0 : 00                     	dc.b	$00
 9301/    39C1 :                        TAB_POWR
 9302/    39C1 :                        KEY_POWER
 9303/    39C1 : B600                   	dc.b	TK_POWER,$00				; ^
 9304/    39C3 :                        
 9305/    39C3 :                        ;************************************************************************************
 9306/    39C3 :                        ;
 9307/    39C3 :                        ; just messages
 9308/    39C3 :                        
 9309/    39C3 :                        LAB_BMSG
 9310/    39C3 : 0D0A 4272 6561 6B00    	dc.b	$0D,$0A,'Break',$00
 9311/    39CB :                        LAB_EMSG
 9312/    39CB : 2045 7272 6F72 00      	dc.b	' Error',$00
 9313/    39D2 :                        LAB_LMSG
 9314/    39D2 : 2069 6E20 6C69 6E65    	dc.b	' in line ',$00
          39DA : 2000                  
 9315/    39DC :                        LAB_IMSG
 9316/    39DC : 4578 7472 6120 6967    	dc.b	'Extra ignored',$0D,$0A,$00
          39E4 : 6E6F 7265 640D 0A00   
 9317/    39EC :                        LAB_REDO
 9318/    39EC : 5265 646F 2066 726F    	dc.b	'Redo from start',$0D,$0A,$00
          39F4 : 6D20 7374 6172 740D
          39FC : 0A00                  
 9319/    39FE :                        LAB_RMSG
 9320/    39FE : 0D0A 5265 6164 790D    	dc.b	$0D,$0A,'Ready',$0D,$0A,$00
          3A06 : 0A00                  
 9321/    3A08 :                        LAB_SMSG
 9322/    3A08 : 2042 7974 6573 2066    	dc.b	' Bytes free',$0D,$0A,$0A
          3A10 : 7265 650D 0A0A      
 9323/    3A16 : 456E 6861 6E63 6564    	dc.b	'Enhanced 68k BASIC Version 3.54',$0D,$0A,$00
          3A1E : 2036 386B 2042 4153
          3A26 : 4943 2056 6572 7369
          3A2E : 6F6E 2033 2E35 340D
          3A36 : 0A00                  
 9324/    3A38 :                        
 9325/    3A38 :                        ROM_E:
 9326/    3A38 :                        
 9327/    3A38 :                        ;************************************************************************************
 9328/    3A38 :                        ;
 9329/    3A38 :                        ; This lot is in Work area
 9330/    3A38 :                        
 9331/    3A38 : =$3B00                 WORK_B	EQU	(ROM_E+$100) & $ffffff00
 9332/    3A38 :                        
 9333/    3B00 :                        	ORG	WORK_B
 9334/    3B00 :                        
 9335/    3B00 : =$3B00                 ram_strt	equ	WORK_B
 9336/    3B00 :                        
 9337/    3B00 : =$7C500                ram_size:	EQU	$80000 - WORK_B
 9338/    3B00 :                        
 9339/    3B00 :                        ;
 9340/    3B00 :                        ;
 9341/    3B00 :                        
 9342/    3B00 :                        ;************************************************************************************
 9343/    3B00 :                        ; EhBASIC keywords quick reference list												*
 9344/    3B00 :                        ;************************************************************************************
 9345/    3B00 :                        
 9346/    3B00 :                        ; glossary
 9347/    3B00 :                        
 9348/    3B00 :                        ;		<.>		  required
 9349/    3B00 :                        ;		{.|.}		  one of required
 9350/    3B00 :                        ;		[.]		  optional
 9351/    3B00 :                        ;		...		  may repeat as last
 9352/    3B00 :                        
 9353/    3B00 :                        ;		any		= anything
 9354/    3B00 :                        ;		num		= number
 9355/    3B00 :                        ;		state		= statement
 9356/    3B00 :                        ;		n		= positive integer
 9357/    3B00 :                        ;		str		= string
 9358/    3B00 :                        ;		var		= variable
 9359/    3B00 :                        ;		nvar		= numeric variable
 9360/    3B00 :                        ;		svar		= string variable
 9361/    3B00 :                        ;		expr		= expression
 9362/    3B00 :                        ;		nexpr		= numeric expression
 9363/    3B00 :                        ;		sexpr		= string expression
 9364/    3B00 :                        
 9365/    3B00 :                        ; statement separator
 9366/    3B00 :                        
 9367/    3B00 :                        ; :			. [<state>] : [<state>]							; done
 9368/    3B00 :                        
 9369/    3B00 :                        ; number bases
 9370/    3B00 :                        
 9371/    3B00 :                        ; %			. %<binary num>								; done
 9372/    3B00 :                        ; $			. $<hex num>								; done
 9373/    3B00 :                        
 9374/    3B00 :                        ; commands
 9375/    3B00 :                        
 9376/    3B00 :                        ; END		. END										; done
 9377/    3B00 :                        ; FOR		. FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]	; done
 9378/    3B00 :                        ; NEXT		. NEXT [<nvar>[,<nvar>]...]						; done
 9379/    3B00 :                        ; DATA		. DATA [{num|["]str["]}[,{num|["]str["]}]...]	; done
 9380/    3B00 :                        ; INPUT		. INPUT [<">str<">;] <var>[,<var>[,<var>]...]	; done
 9381/    3B00 :                        ; DIM		. DIM <var>(<nexpr>[,<nexpr>[,<nexpr>]])		; done
 9382/    3B00 :                        ; READ		. READ <var>[,<var>[,<var>]...]				; done
 9383/    3B00 :                        ; LET		. [LET] <var>=<expr>						; done
 9384/    3B00 :                        ; DEC		. DEC <nvar>[,<nvar>[,<nvar>]...]			; done
 9385/    3B00 :                        ; GOTO		. GOTO <n>									; done
 9386/    3B00 :                        ; RUN		. RUN [<n>]									; done
 9387/    3B00 :                        ; IF		. IF <expr>{GOTO<n>|THEN<{n|comm}>}[ELSE <{n|comm}>]	; done
 9388/    3B00 :                        ; RESTORE	. RESTORE [<n>]								; done
 9389/    3B00 :                        ; GOSUB		. GOSUB <n>									; done
 9390/    3B00 :                        ; RETURN	. RETURN									; done
 9391/    3B00 :                        ; REM		. REM [<any>]								; done
 9392/    3B00 :                        ; STOP		. STOP										; done
 9393/    3B00 :                        ; ON		. ON <nexpr>{GOTO|GOSUB}<n>[,<n>[,<n>]...]	; done
 9394/    3B00 :                        ; NULL		. NULL <nexpr>								; done
 9395/    3B00 :                        ; INC		. INC <nvar>[,<nvar>[,<nvar>]...]			; done
 9396/    3B00 :                        ; WAIT		. WAIT <nexpr>,<nexpr>[,<nexpr>]			; done
 9397/    3B00 :                        ; LOAD		. LOAD [<sexpr>]							; done for sim
 9398/    3B00 :                        ; SAVE		. SAVE [<sexpr>][,[<n>][-<n>]]				; done for sim
 9399/    3B00 :                        ; DEF		. DEF FN<var>(<var>)=<expr>					; done
 9400/    3B00 :                        ; POKE		. POKE <nexpr>,<nexpr>						; done
 9401/    3B00 :                        ; DOKE		. DOKE <nexpr>,<nexpr>						; done
 9402/    3B00 :                        ; LOKE		. LOKE <nexpr>,<nexpr>						; done
 9403/    3B00 :                        ; CALL		. CALL <nexpr>								; done
 9404/    3B00 :                        ; DO		. DO										; done
 9405/    3B00 :                        ; LOOP		. LOOP [{WHILE|UNTIL}<nexpr>]				; done
 9406/    3B00 :                        ; PRINT		. PRINT [{;|,}][<expr>][{;|,}[<expr>]...]	; done
 9407/    3B00 :                        ; CONT		. CONT										; done
 9408/    3B00 :                        ; LIST		. LIST [<n>][-<n>]							; done
 9409/    3B00 :                        ; CLEAR		. CLEAR										; done
 9410/    3B00 :                        ; NEW		. NEW										; done
 9411/    3B00 :                        ; WIDTH		. WIDTH [<n>][,<n>]							; done
 9412/    3B00 :                        ; GET		. GET <var>									; done
 9413/    3B00 :                        ; SWAP		. SWAP <var>,<var>							; done
 9414/    3B00 :                        ; BITSET	. BITSET <nexpr>,<nexpr>					; done
 9415/    3B00 :                        ; BITCLR	. BITCLR <nexpr>,<nexpr>					; done
 9416/    3B00 :                        
 9417/    3B00 :                        ; sub commands (may not start a statement)
 9418/    3B00 :                        
 9419/    3B00 :                        ; TAB		. TAB(<nexpr>)								; done
 9420/    3B00 :                        ; ELSE		. IF <expr>{GOTO<n>|THEN<{n|comm}>}[ELSE <{n|comm}>]	; done
 9421/    3B00 :                        ; TO		. FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]			; done
 9422/    3B00 :                        ; FN		. FN <var>(<expr>)							; done
 9423/    3B00 :                        ; SPC		. SPC(<nexpr>)								; done
 9424/    3B00 :                        ; THEN		. IF <nexpr> {THEN <{n|comm}>|GOTO <n>}		; done
 9425/    3B00 :                        ; NOT		. NOT <nexpr>								; done
 9426/    3B00 :                        ; STEP		. FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]			; done
 9427/    3B00 :                        ; UNTIL		. LOOP [{WHILE|UNTIL}<nexpr>]				; done
 9428/    3B00 :                        ; WHILE		. LOOP [{WHILE|UNTIL}<nexpr>]				; done
 9429/    3B00 :                        
 9430/    3B00 :                        ; operators
 9431/    3B00 :                        
 9432/    3B00 :                        ; +			. [expr] + <expr>							; done
 9433/    3B00 :                        ; -			. [nexpr] - <nexpr>							; done
 9434/    3B00 :                        ; *			. <nexpr>	; <nexpr>						; done fast hardware
 9435/    3B00 :                        ; /			. <nexpr> / <nexpr>							; done fast hardware
 9436/    3B00 :                        ; ^			. <nexpr> ^ <nexpr>							; done
 9437/    3B00 :                        ; AND		. <nexpr> AND <nexpr>						; done
 9438/    3B00 :                        ; EOR		. <nexpr> EOR <nexpr>						; done
 9439/    3B00 :                        ; OR		. <nexpr> OR <nexpr>						; done
 9440/    3B00 :                        ; >>		. <nexpr> >> <nexpr>						; done
 9441/    3B00 :                        ; <<		. <nexpr> << <nexpr>						; done
 9442/    3B00 :                        
 9443/    3B00 :                        ; compare functions
 9444/    3B00 :                        
 9445/    3B00 :                        ; <			. <expr> < <expr>							; done
 9446/    3B00 :                        ; =			. <expr> = <expr>							; done
 9447/    3B00 :                        ; >			. <expr> > <expr>							; done
 9448/    3B00 :                        
 9449/    3B00 :                        ; functions
 9450/    3B00 :                        
 9451/    3B00 :                        ; SGN		. SGN(<nexpr>)								; done
 9452/    3B00 :                        ; INT		. INT(<nexpr>)								; done
 9453/    3B00 :                        ; ABS		. ABS(<nexpr>)								; done
 9454/    3B00 :                        ; USR		. USR(<expr>)								; done
 9455/    3B00 :                        ; FRE		. FRE(<expr>)								; done
 9456/    3B00 :                        ; POS		. POS(<expr>)								; done
 9457/    3B00 :                        ; SQR		. SQR(<nexpr>)								; done fast shift/sub
 9458/    3B00 :                        ; RND		. RND(<nexpr>)								; done 32 bit PRNG
 9459/    3B00 :                        ; LOG		. LOG(<nexpr>)								; done fast cordic
 9460/    3B00 :                        ; EXP		. EXP(<nexpr>)								; done fast cordic
 9461/    3B00 :                        ; COS		. COS(<nexpr>)								; done fast cordic
 9462/    3B00 :                        ; SIN		. SIN(<nexpr>)								; done fast cordic
 9463/    3B00 :                        ; TAN		. TAN(<nexpr>)								; done fast cordic
 9464/    3B00 :                        ; ATN		. ATN(<nexpr>)								; done fast cordic
 9465/    3B00 :                        ; PEEK		. PEEK(<nexpr>)								; done
 9466/    3B00 :                        ; DEEK		. DEEK(<nexpr>)								; done
 9467/    3B00 :                        ; LEEK		. LEEK(<nexpr>)								; done
 9468/    3B00 :                        ; LEN		. LEN(<sexpr>)								; done
 9469/    3B00 :                        ; STR$		. STR$(<nexpr>)								; done
 9470/    3B00 :                        ; VAL		. VAL(<sexpr>)								; done
 9471/    3B00 :                        ; ASC		. ASC(<sexpr>)								; done
 9472/    3B00 :                        ; UCASE$	. UCASE$(<sexpr>)							; done
 9473/    3B00 :                        ; LCASE$	. LCASE$(<sexpr>)							; done
 9474/    3B00 :                        ; CHR$		. CHR$(<nexpr>)								; done
 9475/    3B00 :                        ; HEX$		. HEX$(<nexpr>)								; done
 9476/    3B00 :                        ; BIN$		. BIN$(<nexpr>)								; done
 9477/    3B00 :                        ; BTST		. BTST(<nexpr>,<nexpr>)						; done
 9478/    3B00 :                        ; MAX		. MAX(<nexpr>[,<nexpr>[,<nexpr>]...])		; done
 9479/    3B00 :                        ; MIN		. MIN(<nexpr>[,<nexpr>[,<nexpr>]...])		; done
 9480/    3B00 :                        ; PI		. PI										; done
 9481/    3B00 :                        ; TWOPI		. TWOPI										; done
 9482/    3B00 :                        ; VARPTR	. VARPTR(<var>)								; done
 9483/    3B00 :                        ; SADD		. SADD(<svar>)								; done
 9484/    3B00 :                        ; LEFT$		. LEFT$(<sexpr>,<nexpr>)					; done
 9485/    3B00 :                        ; RIGHT$	. RIGHT$(<sexpr>,<nexpr>)					; done
 9486/    3B00 :                        ; MID$		. MID$(<sexpr>,<nexpr>[,<nexpr>])			; done
 9487/    3B00 :                        ; USING$	. USING$(<sexpr>,<nexpr>[,<nexpr>]...])		; done
 9488/    3B00 :                        
 9489/    3B00 :                        
 9490/    3B00 :                        ;************************************************************************************
 9491/    3B00 :                        
 9492/    3B00 :                        	END	code_start
 AS V1.42 Beta [Bld 283] - Source File BASIC68K.ASM - Page 2 - 4/10/2025 21:30:24


  Symbol Table (* = unused):
  --------------------------

 AC1GTAC2 :                    2008 C |
*ARCHITECTURE :                                        "i386-unknown-win32" - |
 ASPTL :                        5A8 C |  ASRCH :                        5DA C |
 ASTRTL :                       5AC C |  BHSEND :                       5D6 C |
 BIN2DEC :                     2FCC C |  BINPR :                       2BB2 C |
 BINSS :                        5B6 C |  BLINEL :                       456 C |
 BREAKF :                       5DC C | *CASESENSITIVE :                  0 - |
*CBI_CHR :                      107 C |  CCBYTE :                       5E9 C |
 CCFLAG :                       5E8 C |  CCNULL :                       5EA C |
 CFLAG :                        5E1 C |  CIN1 :                         52A C |
 CLINEL :                       452 C |  CLR_INT :                      4B2 C |
 CODE_START :                   550 C |  COMP_F :                       5E3 C |
*CONSTPI :        3.141592653589793 - |  CONTMP_BUF :                   180 C |
 CON_SIZE :                      80 - |  COSOUT :                       5B4 - |
 COUT_1 :                       514 C |  CPNTRL :                       45A C |
 CRD_BUF :                      200 C |  CRD_CNT :                      112 C |
 CRD_RP :                       113 C |  CRD_WP :                       114 C |
*CREQ_COM :                     106 C | *CVARAL :                       46E C |
 D1X02 :                       2FA6 C |  D1X10 :                       2FBC C |
 D1X16 :                       2F98 C | *DATA_DMA :                     10E C |
*DATE :                 "4/10/2025" - |  DECSS :                        5C6 C |
 DEFDIM :                       5B4 C |  DES_SK :                       48E C |
 DES_SK_E :                     476 C |  DIMCNT :                       5DB C |
*DISK_DRIVE :                   108 C | *DISK_SECTOR :                  10C C |
*DISK_TRACK :                   10A C |  DLINEL :                       45E C |
 DOCMP :                        C08 C |  DOREST :                       BF4 C |
 DPTRL :                        462 C |  DTYPEF :                       5B5 - |
 DUMMY_H :                      486 C |  EARRYL :                       442 C |
 EMEML :                        44A C |  ENDBHS :                      2B8C C |
 END_COUT :                     53E C |  EXIT_CIN :                     47E C |
 EXPCNT :                       5AD - |  EXPNEG :                       5AF - |
 FAC1_E :                       594 C |  FAC1_M :                       590 C |
 FAC1_S :                       595 - |  FAC2_E :                       59C C |
 FAC2_M :                       598 C |  FAC2_S :                       59D - |
 FAC_SC :                       59E - | *FALSE :                          0 - |
 FEND :                           8 - |  FLAG :                         59F - |
*FLASH_SUPPORT :                  0 - | *FLOATMAX :      1.797693134866E308 - |
 FSD :                            0 - |  FSDC :                           A - |
 FSDPI :                          8 - |  FSLI :                           6 - |
 FSTI :                           4 - | *FULLPMMU :                       1 - |
 FUNC_L :                       5B0 C |  GCLCTD :                       5DE C |
 GETFIRST :                    13E0 C |  GETPAIR :                     149C C |
 GOPR :                        2BBC C | *HAS64 :                          1 - |
*HASFPU :                         0 - | *HASPMMU :                        0 - |
 HEXSS :                        5CE C |  IBUFFE :                       590 C |
 IBUFFS :                       490 C |  ICLIM :                        5E7 C |
 IMODE :                        5E0 C |  INGET :                       2C10 C |
*INIVEC :                         0 C | *INIVECE :                       C0 C |
*INSUPMODE :                      1 - |  IRQ5_H :                       400 C |
 ITEMP :                        42A C |  KEY_ABS :                     382C C |
 KEY_AND :                     3830 C |  KEY_ASC :                     3833 C |
 KEY_ATN :                     3837 C |  KEY_BINS :                    383C C |
 KEY_BITCLR :                  3841 C |  KEY_BITSET :                  3847 C |
 KEY_BITTST :                  384D C |  KEY_CALL :                    3855 C |
 KEY_CHRS :                    3859 C |  KEY_CLEAR :                   385E C |
 KEY_CONT :                    3863 C |  KEY_COS :                     3867 C |
 KEY_DATA :                    386C C |  KEY_DEC :                     3870 C |
 KEY_DEEK :                    3873 C |  KEY_DEF :                     3878 C |
 KEY_DIM :                     387B C |  KEY_DIV :                     381E C |
 KEY_DO :                      3882 C |  KEY_DOKE :                    387E C |
 KEY_ELSE :                    3885 C |  KEY_END :                     3889 C |
 KEY_EOR :                     388C C |  KEY_EQUAL :                   3824 C |
 KEY_EXP :                     388F C |  KEY_FN :                      3897 C |
 KEY_FOR :                     3894 C |  KEY_FRE :                     3899 C |
 KEY_GET :                     389E C |  KEY_GOSUB :                   38A5 C |
 KEY_GOTO :                    38A1 C |  KEY_GT :                      3828 C |
 KEY_HEXS :                    38AB C |  KEY_IF :                      38B1 C |
 KEY_INC :                     38B3 C |  KEY_INPUT :                   38B6 C |
 KEY_INT :                     38BB C |  KEY_LCASES :                  38C0 C |
 KEY_LEEK :                    38C7 C |  KEY_LEFTS :                   38CC C |
 KEY_LEN :                     38D2 C |  KEY_LET :                     38D6 C |
 KEY_LIST :                    38D9 C |  KEY_LOAD :                    38DD C |
 KEY_LOG :                     38E1 C |  KEY_LOKE :                    38E5 C |
 KEY_LOOP :                    38E9 C |  KEY_LSHIFT :                  3820 C |
 KEY_LT :                      3822 C |  KEY_MAX :                     38EE C |
 KEY_MIDS :                    38F2 C |  KEY_MIN :                     38F7 C |
 KEY_MINUS :                   381C C |  KEY_MULT :                    3818 C |
 KEY_NEW :                     38FC C |  KEY_NEXT :                    38FF C |
 KEY_NOT :                     3903 C |  KEY_NULL :                    3906 C |
 KEY_ON :                      390B C |  KEY_OR :                      390D C |
 KEY_PEEK :                    3910 C |  KEY_PI :                      3915 C |
 KEY_PLUS :                    381A C |  KEY_POKE :                    3917 C |
 KEY_POS :                     391B C |  KEY_POWER :                   39C1 C |
 KEY_PRINT :                   391F C |  KEY_RAM :                     3925 C |
 KEY_READ :                    392C C |  KEY_REM :                     3930 C |
 KEY_RESTORE :                 3933 C |  KEY_RETURN :                  393A C |
 KEY_RIGHTS :                  3940 C |  KEY_RND :                     3947 C |
 KEY_RSHIFT :                  3826 C |  KEY_RUN :                     394B C |
 KEY_SADD :                    394F C |  KEY_SAVE :                    3954 C |
 KEY_SGN :                     3958 C |  KEY_SIN :                     395C C |
 KEY_SPC :                     3960 C |  KEY_SQR :                     3964 C |
 KEY_STEP :                    3968 C |  KEY_STOP :                    396C C |
 KEY_STRS :                    3970 C |  KEY_SWAP :                    3975 C |
 KEY_TAB :                     397A C |  KEY_TAN :                     397E C |
 KEY_THEN :                    3982 C |  KEY_TO :                      3986 C |
 KEY_TWOPI :                   3988 C |  KEY_UCASES :                  398E C |
 KEY_UNTIL :                   3995 C |  KEY_USINGS :                  399A C |
 KEY_USR :                     39A1 C |  KEY_VAL :                     39A6 C |
 KEY_VPTR :                    39AA C |  KEY_WAIT :                    39B2 C |
 KEY_WHILE :                   39B6 C |  KEY_WIDTH :                   39BB C |
 KFCTSEED :                26A3D110 - |  LAB_11A5 :                    10AE C |
 LAB_11A6 :                    10B0 C |  LAB_11BD :                    10BC C |
 LAB_1269 :                     698 C |  LAB_1274 :                     6A6 C |
 LAB_127D :                     6AE C |  LAB_127E :                     6BC C |
 LAB_1295 :                     6D0 C |  LAB_12AE :                     6F2 C |
 LAB_12B0 :                     6F4 C |  LAB_12E6 :                     714 C |
 LAB_12FF :                     746 C |  LAB_1301 :                     748 C |
 LAB_1303 :                     766 C |  LAB_1325 :                     77E C |
 LAB_132E :                     76E C |  LAB_1330 :                     770 C |
 LAB_134B :                     78C C |  LAB_1357 :                     7AA C |
 LAB_1359 :                     7B0 C |  LAB_1374 :                     7D0 C |
 LAB_1378 :                     7D6 C |  LAB_137F :                     7E2 C |
 LAB_138E :                     7E8 C |  LAB_1392 :                     7EC C |
 LAB_13A6 :                     820 C |  LAB_13AC :                     828 C |
 LAB_13C6 :                     852 C |  LAB_13CC :                     858 C |
 LAB_13D6 :                     87A C |  LAB_13D8 :                     880 C |
 LAB_13EA :                     88C C |  LAB_13EC :                     88E C |
 LAB_13FF :                     8A6 C |  LAB_1401 :                     8AA C |
 LAB_1408 :                     8B6 C |  LAB_1410 :                     8C2 C |
 LAB_1417 :                     8CC C |  LAB_141B :                     8CE C |
 LAB_141F :                     8DE C |  LAB_142A :                     8E4 C |
 LAB_142C :                     8F0 C |  LAB_145E :                     90A C |
 LAB_145F :                     8FC C |  LAB_1463 :                     912 C |
 LAB_1477 :                     91E C |  LAB_147A :                     924 C |
*LAB_1480 :                     93E C |  LAB_1491 :                     948 C |
 LAB_14BD :                     97A C |  LAB_14C0 :                     97E C |
 LAB_14D4 :                     99E C | *LAB_14E2 :                     9BA C |
 LAB_150C :                     9C8 C |  LAB_1519 :                     9D8 C |
 LAB_152E :                     9E4 C |  LAB_1540 :                     A10 C |
 LAB_15B3 :                     A70 C |  LAB_15C2 :                     A9A C |
 LAB_15D1 :                     AA6 C |  LAB_15DC :                     A82 C |
 LAB_15F6 :                     A94 C |  LAB_15FF :                     AB4 C |
 LAB_1602 :                     AB8 C |  LAB_1624 :                     B3C C |
 LAB_1629 :                     ADC C |  LAB_1636 :                     AE0 C |
 LAB_1639 :                     AE6 C |  LAB_163B :                     AF2 C |
 LAB_1647 :                     AFE C |  LAB_164F :                     B04 C |
 LAB_16B0 :                     B9C C |  LAB_16D0 :                     BC0 C |
 LAB_1723 :                     C5A C |  LAB_1725 :                     C5E C |
 LAB_172C :                     C4A C |  LAB_172D :                     C52 C |
 LAB_174B :                     C86 C |  LAB_174E :                     CAA C |
 LAB_1750 :                     CB6 C |  LAB_1752 :                     CC2 C |
 LAB_1754 :                     CDA C | *LAB_1756 :                     CC6 C |
 LAB_176C :                     CF8 C |  LAB_1773 :                     D02 C |
 LAB_1785 :                     D1E C |  LAB_1786 :                     D4A C |
 LAB_17B7 :                     D60 C |  LAB_17B8 :                     D5C C |
 LAB_17D5 :                     DDC C |  LAB_17D6 :                     DE0 C |
*LAB_1810 :                     DF2 C |  LAB_1811 :                     E02 C |
 LAB_1813 :                     E08 C |  LAB_1829 :                     E40 C |
 LAB_182C :                     E44 C |  LAB_1831 :                     E4A C |
 LAB_185E :                     E8A C |  LAB_1866 :                     E8E C |
 LAB_1880 :                     F50 C |  LAB_1886 :                     F5A C |
 LAB_188A :                     F5E C |  LAB_188B :                     E9C C |
 LAB_1898 :                     EAA C |  LAB_18A2 :                     EB4 C |
 LAB_18B7 :                     ED6 C |  LAB_18B8 :                     EE2 C |
 LAB_18BD :                     EE8 C |  LAB_18C3 :                     EF2 C |
 LAB_18C6 :                     EF6 C |  LAB_18CD :                     F00 C |
 LAB_18E3 :                     F0A C |  LAB_18F0 :                     F2A C |
 LAB_18F7 :                     F38 C |  LAB_18F9 :                     F3C C |
 LAB_1904 :                     F62 C |  LAB_1913 :                     F74 C |
 LAB_1934 :                     F9A C |  LAB_1953 :                     FAE C |
 LAB_195B :                     FB6 C | *LAB_1961 :                     FC0 C |
 LAB_1984 :                     FE0 C |  LAB_1985 :                     FE4 C |
 LAB_1986 :                     FE8 C |  LAB_1999 :                     FFC C |
 LAB_19B0 :                    100E C |  LAB_19B6 :                    101E C |
 LAB_19C2 :                    102E C |  LAB_19DD :                    1042 C |
 LAB_19F6 :                    1062 C |  LAB_1A03 :                    1070 C |
 LAB_1A0E :                    1080 C |  LAB_1A1B :                    1086 C |
 LAB_1A46 :                    10A0 C |  LAB_1A90 :                    111E C |
 LAB_1A9B :                    112C C |  LAB_1ABA :                    1156 C |
 LAB_1ACD :                    1182 C |  LAB_1ADB :                    118E C |
 LAB_1ADE :                    1192 C |  LAB_1AE0 :                    11A8 C |
 LAB_1AFA :                    11C2 C |  LAB_1B0B :                    11D8 C |
 LAB_1B13 :                    11E0 C |  LAB_1B1C :                    11F0 C |
 LAB_1B1D :                    11F2 C |  LAB_1B2A :                    1204 C |
 LAB_1B3C :                    1220 C |  LAB_1B43 :                    1166 C |
 LAB_1B78 :                    122C C |  LAB_1B7B :                    1230 C |
 LAB_1B7D :                    1232 C |  LAB_1B84 :                    123C C |
 LAB_1B86 :                    1240 C |  LAB_1B9D :                    1264 C |
 LAB_1BC1 :                    1294 C |  LAB_1BD0 :                    1304 C |
 LAB_1BE7 :                    131E C |  LAB_1BF3 :                    12A0 C |
 LAB_1BF7 :                    12A6 C |  LAB_1BFB :                    12AA C |
 LAB_1C01 :                    12B2 C |  LAB_1C11 :                    12DC C |
 LAB_1C13 :                    12E2 C |  LAB_1C18 :                    12EA C |
 LAB_1C19 :                    12EE C |  LAB_1C1A :                    12FE C |
 LAB_1C2A :                    135C C |  LAB_1CAE :                    1404 C |
 LAB_1CB5 :                    1422 C |  LAB_1CD4 :                    142C C |
 LAB_1CD5 :                    1432 C |  LAB_1CD6 :                    1434 C |
 LAB_1CDB :                    1444 C |  LAB_1CE6 :                    1436 C |
 LAB_1CF2 :                    1446 C |  LAB_1CFE :                    145C C |
 LAB_1D10 :                    14D4 C |  LAB_1D12 :                    14D8 C |
 LAB_1D2D :                    14EA C |  LAB_1D2E :                    14F6 C |
 LAB_1D44 :                    1512 C |  LAB_1D45 :                    1522 C |
 LAB_1D48 :                    1536 C |  LAB_1D49 :                    153E C |
 LAB_1D4A :                    1542 C |  LAB_1D4B :                    1552 C |
 LAB_1D5D :                    155A C |  LAB_1D5E :                    1560 C |
 LAB_1D83 :                    14C4 C |  LAB_1D8A :                    14BE C |
 LAB_1D94 :                    1574 C | *LAB_1D96 :                    32C2 C |
*LAB_1D98 :                    157E C |  LAB_1DAC :                    1598 C |
 LAB_1DAE :                    159A C |  LAB_1DAF :                    15A6 C |
 LAB_1DB0 :                    15B4 C |  LAB_1DB1 :                    15B8 C |
 LAB_1DB2 :                    15BC C |  LAB_1DD7 :                    15D4 C |
 LAB_1DE6 :                    15EE C |  LAB_1E17 :                    1630 C |
 LAB_1E1F :                    1636 C |  LAB_1E5C :                    1670 C |
 LAB_1E8D :                    168C C |  LAB_1EA1 :                    16A8 C |
 LAB_1EC0 :                    16D0 C |  LAB_1ED6 :                    16FC C |
 LAB_1ED8 :                    170A C |  LAB_1EDF :                    16C4 C |
 LAB_1F07 :                    171C C |  LAB_1F28 :                    1736 C |
 LAB_1F2C :                    173C C |  LAB_1F5A :                    174A C |
 LAB_1F6A :                    1772 C |  LAB_1F6B :                    177E C |
 LAB_1F7C :                    1784 C |  LAB_1FB4 :                    17B2 C |
 LAB_1FD0 :                    17DE C |  LAB_201E :                    1838 C |
 LAB_2043 :                    1886 C |  LAB_2044 :                    18B8 C |
 LAB_2045 :                    18C2 C |  LAB_204S :                    1888 C |
 LAB_204T :                    18B6 C |  LAB_20AE :                    18D4 C |
 LAB_20B4 :                    18D8 C |  LAB_20BE :                    18DE C |
 LAB_20C9 :                    1902 C |  LAB_20CB :                    18EE C |
 LAB_20D0 :                    18F6 C |  LAB_20D8 :                    190C C |
 LAB_20E0 :                    1914 C |  LAB_2115 :                    1934 C |
 LAB_2117 :                    194C C |  LAB_2128 :                    1966 C |
 LAB_2137 :                    196A C |  LAB_214B :                    198A C |
 LAB_2161 :                    19A0 C |  LAB_2176 :                    19A8 C |
 LAB_217E :                    19B6 C |  LAB_2183 :                    19D0 C |
 LAB_218B :                    19D8 C |  LAB_218F :                    19DA C |
 LAB_21C2 :                    19E6 C |  LAB_21C4 :                    19EC C |
 LAB_21D1 :                    1A20 C |  LAB_2206 :                    1A26 C |
 LAB_2212 :                    1A4E C |  LAB_2216 :                    1A10 C |
 LAB_2240 :                    1A18 C |  LAB_224D :                    1A54 C |
 LAB_224E :                    1A6A C |  LAB_229E :                    1AAE C |
 LAB_22A0 :                    1ABA C |  LAB_22B6 :                    1AC8 C |
 LAB_22BA :                    1ACC C |  LAB_22BD :                    1AD6 C |
 LAB_22E6 :                    1AF0 C | *LAB_2316 :                    1B30 C |
 LAB_2317 :                    1B32 C |  LAB_231C :                    1B36 C |
 LAB_2358 :                    1B6A C |  LAB_2368 :                    1B8A C |
 LAB_2441 :                    1D7E C |  LAB_2445 :                    1D82 C |
 LAB_2467 :                    1DD2 C |  LAB_2468 :                    1DD6 C |
 LAB_249C :                    1DC4 C |  LAB_24A8 :                    1DDA C |
 LAB_24B4 :                    1E04 C |  LAB_24D0 :                    1E10 C |
 LAB_24D5 :                    1E1C C |  LAB_24D6 :                    1E36 C |
 LAB_24D7 :                    1E44 C |  LAB_24D8 :                    1E4A C |
 LAB_24D9 :                    1E2A C |  LAB_24DA :                    1E50 C |
 LAB_24F7 :                    1DF4 C |  LAB_24F8 :                    1DFA C |
 LAB_2778 :                    20B8 C |  LAB_277C :                    20BA C |
 LAB_279B :                    20DE C |  LAB_27BA :                    20EC C |
 LAB_27C3 :                    2108 C |  LAB_27C4 :                    2112 C |
 LAB_27CA :                    2118 C |  LAB_27CE :                    2120 C |
 LAB_27D0 :                    2124 C |  LAB_27DB :                    2132 C |
 LAB_27F0 :                    23F6 C |  LAB_27F1 :                    240C C |
 LAB_27F2 :                    2412 C |  LAB_27F3 :                    2414 C |
 LAB_27FA :                    214A C |  LAB_2828 :                    216A C |
*LAB_282E :                    2170 C |  LAB_282F :                    2172 C |
 LAB_2831 :                    2176 C |  LAB_284G :                    219A C |
 LAB_284H :                    21AC C |  LAB_284J :                    21AE C |
 LAB_284L :                    21A2 C |  LAB_2887 :                    2DBA C |
 LAB_289A :                    2DE4 C |  LAB_289C :                    2DEA C |
 LAB_289D :                    2DF0 C |  LAB_28FD :                    2E0C C |
 LAB_28FE :                    2E12 C |  LAB_28FF :                    2E18 C |
 LAB_2900 :                    2E26 C |  LAB_2901 :                    2E2C C |
 LAB_2902 :                    2E7E C |  LAB_2903 :                    2E86 C |
 LAB_2904 :                    2E88 C |  LAB_2953 :                    21D0 C |
 LAB_295E :                    21DC C |  LAB_2967 :                    21E8 C |
 LAB_2968 :                    21F0 C |  LAB_2969 :                    2202 C |
 LAB_296A :                    220C C |  LAB_2970 :                    2222 C |
 LAB_2978 :                    2232 C |  LAB_2989 :                    2242 C |
 LAB_299C :                    2296 C |  LAB_29A7 :                    22BE C |
 LAB_29B7 :                    22D6 C |  LAB_29B9 :                    226E C |
 LAB_29C0 :                    22E4 C |  LAB_29C3 :                    22FC C |
 LAB_29D9 :                    2318 C |  LAB_29E4 :                    232A C |
 LAB_29F7 :                    233E C |  LAB_29FB :                    2342 C |
 LAB_29FD :                    234A C |  LAB_2A18 :                    235A C |
 LAB_2A1A :                    235C C |  LAB_2A21 :                    2364 C |
 LAB_2A3B :                    2386 C |  LAB_2A4B :                    2394 C |
 LAB_2A58 :                    23A8 C |  LAB_2A68 :                    23C0 C |
 LAB_2A74 :                    23CC C |  LAB_2A89 :                    23E8 C |
 LAB_2A8C :                    23EC C |  LAB_2A91 :                    23F2 C |
 LAB_2A9A :                    3466 C |  LAB_2A9B :                    3482 C |
 LAB_2X01 :                    2E44 C |  LAB_2X02 :                    2E4C C |
 LAB_2X03 :                    2E5A C |  LAB_2X04 :                    2E60 C |
 LAB_2X05 :                    2E76 C |  LAB_2Y01 :                    2E96 C |
 LAB_2Y02 :                    2E9E C |  LAB_2Y03 :                    2EAA C |
 LAB_2Y04 :                    2EB0 C |  LAB_3216 :                    2052 C |
 LAB_32_16 :                   2050 C |  LAB_ABER :                     65A C |
 LAB_ABS :                     2142 C |  LAB_AD :                      37F9 C |
 LAB_ADD :                     1DA0 C |  LAB_ADER :                     626 C |
 LAB_AND :                     13D8 C |  LAB_ASC :                     1C14 C |
 LAB_ATCD :                    2796 C |  LAB_ATGO :                    2752 C |
 LAB_ATLE :                    2770 C |  LAB_ATN :                     2734 C |
 LAB_ATNP :                    2790 C |  LAB_AYFC :                    17BE C |
 LAB_BAER :                    3680 C |  LAB_BHCB :                    13BE C |
 LAB_BHSS :                    1398 C |  LAB_BINS :                    2B6E C |
 LAB_BITCLR :                  27F8 C |  LAB_BITSET :                  27E8 C |
 LAB_BMSG :                    39C3 C |  LAB_BS :                      3722 C |
 LAB_BTST :                    2808 C |  LAB_CALL :                    1D5E C |
 LAB_CASC :                    14AE C |  LAB_CATN :                    279C C |
*LAB_CAUC :                    14B4 C |  LAB_CBIN :                    2F6A C |
 LAB_CBX1 :                    2F84 C |  LAB_CBXN :                    2F72 C |
 LAB_CCER :                     63E C |  LAB_CHEX :                    2F08 C |
 LAB_CHRS :                    1AFA C |  LAB_CHX1 :                    2F2E C |
 LAB_CHX2 :                    2F52 C |  LAB_CHX3 :                    2F4A C |
 LAB_CHXX :                    2F10 C |  LAB_CKRN :                    17E6 C |
 LAB_CKTM :                    1148 C |  LAB_CLEAR :                    962 C |
 LAB_CN :                      378F C |  LAB_COLD :                     56A C |
 LAB_CONT :                     B4E C |  LAB_CORD :                    26C6 C |
 LAB_COS :                     2656 C |  LAB_CRLF :                     E94 C |
 LAB_CTBL :                    334A C |  LAB_CTNM :                    1146 C |
 LAB_D0 :                      3740 C |  LAB_D002 :                    2AD2 C |
 LAB_D00A :                    2AE2 C |  LAB_D00E :                    2AF2 C |
 LAB_DATA :                     C3C C |  LAB_DD :                      372F C |
 LAB_DDER :                     656 C |  LAB_DEC :                      D50 C |
 LAB_DECI :                     DB0 C |  LAB_DEEK :                    1CDC C |
 LAB_DEF :                     17F0 C |  LAB_DIM :                     1460 C |
 LAB_DIV0 :                    204A C |  LAB_DIVIDE :                  1FD0 C |
 LAB_DIVX :                    2020 C |  LAB_DO :                       B80 C |
 LAB_DOKE :                    1D06 C |  LAB_DUPFMT :                  2ABA C |
 LAB_DZER :                     652 C |  LAB_EMSG :                    39CB C |
 LAB_END :                      AE8 C |  LAB_EOR :                     13C8 C |
 LAB_EQUAL :                   13EE C |  LAB_ESML :                    256C C |
 LAB_EVBY :                    1C2C C |  LAB_EVEX :                    115C C |
 LAB_EVEZ :                    115E C |  LAB_EVIN :                    15FA C |
 LAB_EVIR :                    160A C |  LAB_EVNM :                    1144 C |
 LAB_EVPI :                    1602 C |  LAB_EX1 :                     24A4 C |
 LAB_EXAD :                    25F6 C |  LAB_EXCC :                    25DC C |
 LAB_EXCM :                    250E C |  LAB_EXNN :                    25C8 C |
 LAB_EXOF :                    24C8 C |  LAB_EXOL :                    24DE C |
 LAB_EXOU :                    24B4 C |  LAB_EXP :                     24E8 C |
 LAB_EXPL :                    25C2 C |  LAB_EXPS :                    2520 C |
 LAB_EXRN :                    25CE C |  LAB_EXXF :                    2F58 C |
 LAB_FB95 :                    2C20 C |  LAB_FBA0 :                    2C04 C |
 LAB_FC :                      36E9 C |  LAB_FCER :                     66A C |
 LAB_FO :                      3801 C |  LAB_FOER :                     622 C |
 LAB_FOR :                      A1C C |  LAB_FRE :                     17A8 C |
 LAB_FTBL :                    33E6 C |  LAB_FTPP :                    339A C |
 LAB_FVAR :                    14CC C |  LAB_GADB :                    1C80 C |
 LAB_GADW :                    1C94 C |  LAB_GARB :                    1980 C |
 LAB_GBYT :                    12BE C |  LAB_GEAD :                    1CB4 C |
 LAB_GET :                      E0E C |  LAB_GETS :                     E28 C |
 LAB_GFPN :                     D12 C |  LAB_GOSUB :                    B92 C |
 LAB_GOTO :                     BA4 C |  LAB_GOTS :                     BB4 C |
 LAB_GSCH :                     B34 C |  LAB_GTBY :                    1C28 C |
 LAB_GTHAN :                   2496 C |  LAB_GTWO :                    1C3E C |
 LAB_GVAL :                    126A C |  LAB_GVAR :                    14CE C |
 LAB_HEXS :                    2BC0 C |  LAB_ID :                      374F C |
 LAB_IDER :                     64E C |  LAB_IF :                       C64 C |
 LAB_IGBY :                    12BC C |  LAB_IMSG :                    39DC C |
 LAB_INC :                      D56 C |  LAB_INCI :                     DA6 C |
 LAB_INCT :                     D98 C |  LAB_INLN :                     7A0 C |
 LAB_INPUT :                    F82 C |  LAB_INT :                     21B4 C |
 LAB_IRTS :                    21CE C |  LAB_ISHN :                    2F2A C |
 LAB_KEYT :                    34EC C |  LAB_LAAD :                    1ECA C |
 LAB_LCASE :                   1B92 C |  LAB_LD :                      37B1 C |
 LAB_LDER :                     636 C |  LAB_LEEK :                    1CF2 C |
 LAB_LEFT :                    1B0A C |  LAB_LENS :                    1C0C C |
 LAB_LET :                      DB4 C |  LAB_LIST :                     966 C |
 LAB_LMSG :                    39D2 C |  LAB_LOAD :                    1D56 C |
 LAB_LOCC :                    1ED0 C |  LAB_LOCX :                    1EEC C |
 LAB_LOG :                     1E52 C |  LAB_LOKE :                    1D0C C |
 LAB_LOLP :                    1EDA C |  LAB_LONE :                    1F08 C |
 LAB_LONN :                    1EF0 C |  LAB_LOOP :                     BD2 C |
 LAB_LOWZ :                    1F42 C |  LAB_LOXO :                    1F0E C |
 LAB_LOXP :                    1EFE C |  LAB_LRMS :                    1376 C |
 LAB_LS :                      376C C |  LAB_LSHIFT :                  146C C |
 LAB_LTHAN :                   13F8 C |  LAB_LTPF :                    26D6 C |
 LAB_LTPT :                    26E6 C |  LAB_LT_1 :                    205E C |
 LAB_MADD :                    1F70 C |  LAB_MAN1 :                    2044 C |
 LAB_MAX :                     2C2C C |  LAB_MAXN :                    2C38 C |
 LAB_MIDS :                    1B4E C |  LAB_MIN :                     2C42 C |
 LAB_MINN :                    2C4E C | *LAB_MKCHR :                   1AFE C |
 LAB_MMEC :                    2C58 C |  LAB_MNOC :                    1F6A C |
 LAB_MUEX :                    1FBE C | *LAB_MUF1 :                    1F9A C |
 LAB_MUF2 :                    1FA4 C |  LAB_MUF3 :                    1FBA C |
 LAB_MULTIPLY :                1F44 C |  LAB_MUUF :                    1FC4 C |
 LAB_NB1T :                    2096 C |  LAB_NEW :                      910 C |
 LAB_NEXT :                    108E C |  LAB_NF :                      36B0 C |
 LAB_NFER :                     67A C |  LAB_NI :                      3808 C |
 LAB_NOST :                     E3A C |  LAB_NSTT :                    2CBE C |
 LAB_NULL :                     B44 C |  LAB_OD :                      36DD C |
 LAB_ODER :                     66E C |  LAB_OFER :                     666 C |
 LAB_OM :                      3700 C |  LAB_OMER :                     662 C |
 LAB_ON :                       CDE C |  LAB_OPPT :                    3432 C |
 LAB_OR :                      13D0 C |  LAB_OV :                      36F7 C |
 LAB_P004 :                    2B10 C |  LAB_P008 :                    2B26 C |
 LAB_P00C :                    2B2E C |  LAB_P00E :                    2B3A C |
 LAB_P010 :                    2B3E C |  LAB_P018 :                    2B58 C |
 LAB_P01A :                    2B5C C |  LAB_P01E :                    2B64 C |
 LAB_PEEK :                    1CCA C |  LAB_PFAC :                    20A0 C |
 LAB_PHFA :                    2C68 C |  LAB_PI :                      2D9A C |
 LAB_POKE :                    1CD6 C |  LAB_POON :                    2416 C |
 LAB_POS :                     17DA C |  LAB_POWER :                   2432 C |
 LAB_POWP :                    2464 C |  LAB_POZE :                    2426 C |
 LAB_PPBI :                    136C C |  LAB_PPFN :                    135E C |
 LAB_PPFS :                    1350 C |  LAB_PRINT :                    E48 C |
 LAB_PRNA :                     F0C C |  LAB_PROCFO :                  2AF8 C |
 LAB_P_10 :                    30DC C |  LAB_RAM :                     2D90 C |
 LAB_READ :                     FA8 C |  LAB_REDO :                    39EC C |
 LAB_REM :                      CD6 C |  LAB_REMM :                    2076 C |
 LAB_RESS :                     B28 C |  LAB_RESTORE :                  B16 C |
 LAB_RET0 :                    2EF6 C |  LAB_RETURN :                   C28 C |
 LAB_RG :                      36C8 C |  LAB_RGER :                     672 C |
 LAB_RIGHT :                   1B1E C |  LAB_RMSG :                    39FE C |
 LAB_RND :                     2602 C |  LAB_RSED :                    2FF4 C |
 LAB_RSHIFT :                  147C C |  LAB_RTN0 :                    2EF8 C |
 LAB_RTST :                    191A C |  LAB_RUN :                      B6C C |
 LAB_RUNN :                     B7A C |  LAB_SADD :                    1BF4 C |
 LAB_SAVE :                    1D5A C |  LAB_SCCA :                    12B4 C |
 LAB_SCER :                     642 C |  LAB_SCGB :                    12AE C |
 LAB_SCL0 :                    26BC C |  LAB_SCLN :                     8FE C |
 LAB_SCZE :                    26AE C |  LAB_SET1 :                    2028 C |
 LAB_SGBY :                    1C24 C |  LAB_SGN :                     2130 C |
 LAB_SIN :                     266E C |  LAB_SLER :                     646 C |
 LAB_SMSG :                    3A08 C |  LAB_SN :                      36C1 C |
 LAB_SNBS :                     C42 C |  LAB_SNER :                     676 C |
 LAB_SQE1 :                    2D42 C |  LAB_SQE2 :                    2D48 C |
 LAB_SQNA :                    2D70 C |  LAB_SQNS :                    2D5A C |
 LAB_SQR :                     2D1E C |  LAB_SSLN :                     8F6 C |
 LAB_ST :                      377C C |  LAB_STOP :                     AF0 C |
 LAB_STRS :                    18D0 C |  LAB_SUBTRACT :                1D8C C |
 LAB_SVAR :                    14CA C |  LAB_SVTB :                    2CF0 C |
 LAB_SWAP :                    1D20 C |  LAB_TAN :                     2634 C |
 LAB_TBSZ :                    2CD0 C |  LAB_TM :                      375E C |
 LAB_TMER :                     64A C |  LAB_TWOPI :                   2DAA C |
 LAB_U002 :                    2860 C |  LAB_U004 :                    28B6 C |
 LAB_U005 :                    28C6 C |  LAB_U006 :                    28C8 C |
 LAB_U008 :                    28DC C |  LAB_U009 :                    28FE C |
 LAB_U00A :                    2906 C |  LAB_U00B :                    2910 C |
 LAB_U00C :                    2924 C |  LAB_U00D :                    2928 C |
 LAB_U00E :                    293A C |  LAB_U00F :                    2946 C |
 LAB_U010 :                    294A C |  LAB_U014 :                    2950 C |
 LAB_U018 :                    2958 C |  LAB_U01C :                    296E C |
 LAB_U020 :                    297A C |  LAB_U022 :                    2980 C |
 LAB_U026 :                    2990 C |  LAB_U02A :                    299A C |
 LAB_U02B :                    29B2 C |  LAB_U02C :                    29B8 C |
 LAB_U02E :                    29CA C |  LAB_U030 :                    29CE C |
 LAB_U034 :                    29E4 C |  LAB_U036 :                    29EA C |
 LAB_U038 :                    29F2 C |  LAB_U03C :                    29FA C |
 LAB_U03E :                    2A00 C |  LAB_U040 :                    2A18 C |
 LAB_U044 :                    2A28 C |  LAB_U046 :                    2A50 C |
 LAB_U048 :                    2A52 C |  LAB_U04A :                    2A5C C |
 LAB_U04C :                    2A8E C |  LAB_UA :                      37D4 C |
 LAB_UCASE :                   1BC2 C |  LAB_UDER :                     62E C |
 LAB_UF :                      379E C |  LAB_UFAC :                    2084 C |
 LAB_UFER :                     63A C |  LAB_US :                      370E C |
 LAB_USER :                     65E C |  LAB_USINGS :                  2836 C |
 LAB_USR :                     1D4E C |  LAB_UV :                      37C1 C |
 LAB_UVER :                     632 C |  LAB_VAL :                     1C52 C |
 LAB_VALZ :                    1C7A C | *LAB_VARCALL :                 2D82 C |
 LAB_VARPTR :                  2D80 C |  LAB_WAIT :                    1D68 C |
 LAB_WARM :                     400 C |  LAB_WD :                      37E8 C |
 LAB_WDER :                     62A C |  LAB_WDLP :                    2D04 C |
 LAB_WDTH :                    2C9E C |  LAB_XDIV :                    2038 C |
 LAB_XERR :                     67C C |  LAB_XGADW :                   1CAE C |
 LC_LOOP :                     1BA8 C | *LISTON :                         1 - |
 LOOPALWAYS :                   C0E C |  LOOPDONE :                     C22 C |
 LVARPL :                       472 C |  L_DDIV :                      207E C |
 L_DIVRND :                    202C C | *MACEXP :                         7 - |
 MAINLOOP :                    26FE C | *MOMCPU :                     68000 - |
*MOMCPUNAME :               "68000" - |  MV_STR :                       466 C |
*N :                              2 - | *NESTMAX :                      100 - |
 NEXTA :                       2710 C |  NEXTB1 :                      2B7E C |
 NEXTB2 :                      2BA4 C |  NEXTH1 :                      2BD0 C |
 NEXTPRN :                     2610 C |  NINC0 :                       2618 C |
 NINC1 :                       261E C |  NMI_H :                        488 C |
 NMI_MSG :                      49E C | *NOBRK :                          0 - |
 NOLCASE :                     1BEA C |  NOSHIFT :                     1478 C |
 NOSTRING :                    1BF0 C |  NOT2BIG :                     1490 C |
 NOUCASE :                     1BBA C | *NOVAR :                          0 - |
 NO_KEYIN :                     50C C |  NULLCT :                       5E4 C |
 NUMEXP :                       5AC - |  OFCHR :                        '#' - |
 OQUOTE :                       5DD C |  OUTLOOP :                     271E C |
*PADDING :                        1 - |  PIC_REQ :                    80000 - |
 PRG_STRT :                     600 - |  PRNLWORD :                     5A0 C |
 PROG_B :                       400 - |  PRSTK :                        5D8 C |
 RAM_BASE :                     400 C |  RAM_SIZE :                   7C500 - |
 RAM_STRT :                    3B00 - |  RDPTRL :                       466 C |
*RELAXED :                        0 - |  REQ_CLR_IRQ :                    C - |
*REQ_CONIN :                      1 - | *REQ_CONIN1 :                     9 - |
*REQ_CONOUT :                     2 - |  REQ_CONOUT1 :                    A - |
*REQ_CONST :                      3 - |  REQ_E :                        115 C |
 REQ_STRIN :                      B - | *REQ_STROUT :                     4 - |
 ROM_E :                       3A38 C |  RTS_001 :                     12DA C |
 RTS_005 :                      960 C |  RTS_006 :                      B42 C |
 RTS_007 :                      C40 C |  RTS_007A :                     C56 C |
*RTS_008 :                      E0C C |  RTS_009 :                      F08 C |
 RTS_011 :                     1782 C |  RTS_012 :                     1A52 C |
 RTS_013 :                     1AC6 C |  RTS_015 :                     1D1E C |
 RTS_016 :                     1DF8 C |  RTS_017 :                     2116 C |
 RTS_020 :                     24A2 C |  RTS_021 :                     27E6 C |
 RTS_022 :                     2C0E C |  RTS_023 :                     2D1C C |
 RTS_024 :                     2F68 C |  RTS_025 :                     2FCA C |
 SARRYL :                       43E C |  SFNCL :                        432 C |
 SHAD_0 :                       558 C |  SHAD_M :                       100 - |
 SMEML :                        42E C |  SSTORL :                       446 C |
 SSTRL :                        43A C |  STROE :                        4D2 C |
 STROUT :                       4CA C |  STR_ADDR :                     102 C |
 SUBEXIT :                     2728 C |  SUBLOOP :                     26F6 C |
 SUFNXF :                       5DF C |  SUTILL :                       44E C |
 SVARL :                        436 C |  TABSIZ :                       5E2 C |
 TAB_ASCA :                    382C C |  TAB_ASCB :                    383C C |
 TAB_ASCC :                    3855 C |  TAB_ASCD :                    386C C |
 TAB_ASCE :                    3885 C |  TAB_ASCF :                    3894 C |
 TAB_ASCG :                    389E C |  TAB_ASCH :                    38AB C |
 TAB_ASCI :                    38B1 C |  TAB_ASCL :                    38C0 C |
 TAB_ASCM :                    38EE C |  TAB_ASCN :                    38FC C |
 TAB_ASCO :                    390B C |  TAB_ASCP :                    3910 C |
 TAB_ASCR :                    3925 C |  TAB_ASCS :                    394F C |
 TAB_ASCT :                    397A C |  TAB_ASCU :                    398E C |
 TAB_ASCV :                    39A6 C |  TAB_ASCW :                    39B2 C |
 TAB_ATNC :                    324A C |  TAB_CHRT :                    3482 C |
 TAB_EQUL :                    3824 C |  TAB_HTHET :                   32CA C |
 TAB_LESS :                    3820 C |  TAB_MNUS :                    381C C |
 TAB_MORE :                    3826 C |  TAB_PLUS :                    381A C |
 TAB_POWR :                    39C1 C |  TAB_QEST :                    382A C |
 TAB_SLAS :                    381E C |  TAB_SNCO :                    31CA C |
 TAB_STAR :                    3818 C | *TIME :                  "21:30:23" - |
 TK_ABS :                        C1 - |  TK_AND :                        B7 - |
 TK_ASC :                        D3 - |  TK_ATN :                        CC - |
 TK_BINS :                       D8 - |  TK_BITCLR :                     A7 - |
 TK_BITSET :                     A6 - |  TK_BITTST :                     D9 - |
 TK_CALL :                       9B - |  TK_CHRS :                       D6 - |
 TK_CLEAR :                      A1 - |  TK_CONT :                       9F - |
 TK_COS :                        C9 - |  TK_DATA :                       83 - |
 TK_DEC :                        88 - |  TK_DEEK :                       CE - |
 TK_DEF :                        97 - |  TK_DIM :                        85 - |
 TK_DIV :                        B5 - |  TK_DO :                         9C - |
 TK_DOKE :                       99 - |  TK_ELSE :                       A9 - |
 TK_END :                        80 - |  TK_EOR :                        B8 - |
 TK_EQUAL :                      BD - |  TK_EXP :                        C8 - |
 TK_FN :                         AB - |  TK_FOR :                        81 - |
 TK_FRE :                        C3 - |  TK_GET :                        A4 - |
 TK_GOSUB :                      8D - |  TK_GOTO :                       89 - |
 TK_GT :                         BC - |  TK_HEXS :                       D7 - |
 TK_IF :                         8B - |  TK_INC :                        93 - |
 TK_INPUT :                      84 - |  TK_INT :                        C0 - |
 TK_LCASES :                     D5 - |  TK_LEEK :                       CF - |
 TK_LEFTS :                      E1 - |  TK_LEN :                        D0 - |
 TK_LET :                        87 - |  TK_LIST :                       A0 - |
 TK_LOAD :                       95 - |  TK_LOG :                        C7 - |
 TK_LOKE :                       9A - |  TK_LOOP :                       9D - |
 TK_LSHIFT :                     BB - |  TK_LT :                         BE - |
 TK_MAX :                        DA - |  TK_MIDS :                       E3 - |
 TK_MIN :                        DB - |  TK_MINUS :                      B3 - |
 TK_MULT :                       B4 - |  TK_NEW :                        A2 - |
 TK_NEXT :                       82 - |  TK_NOT :                        AE - |
 TK_NULL :                       92 - |  TK_ON :                         91 - |
 TK_OR :                         B9 - |  TK_PEEK :                       CD - |
 TK_PI :                         DD - |  TK_PLUS :                       B2 - |
 TK_POKE :                       98 - |  TK_POS :                        C4 - |
 TK_POWER :                      B6 - |  TK_PRINT :                      9E - |
 TK_RAM :                        DC - |  TK_READ :                       86 - |
 TK_REM :                        8F - |  TK_RESTORE :                    8C - |
 TK_RETURN :                     8E - |  TK_RIGHTS :                     E2 - |
 TK_RND :                        C6 - |  TK_RSHIFT :                     BA - |
 TK_RUN :                        8A - |  TK_SADD :                       E0 - |
 TK_SAVE :                       96 - |  TK_SGN :                        BF - |
 TK_SIN :                        CA - |  TK_SPC :                        AC - |
 TK_SQR :                        C5 - |  TK_STEP :                       AF - |
 TK_STOP :                       90 - |  TK_STRS :                       D1 - |
 TK_SWAP :                       A5 - |  TK_TAB :                        A8 - |
 TK_TAN :                        CB - |  TK_THEN :                       AD - |
 TK_TO :                         AA - |  TK_TWOPI :                      DE - |
 TK_UCASES :                     D4 - |  TK_UNTIL :                      B0 - |
 TK_USINGS :                     E4 - |  TK_USR :                        C2 - |
 TK_VAL :                        D2 - |  TK_VPTR :                       DF - |
 TK_WAIT :                       94 - |  TK_WHILE :                      B1 - |
 TK_WIDTH :                      A3 - |  TOOBIG :                      1496 C |
 TPOS :                         5E5 C |  TPOWER :                       5D9 C |
*TRUE :                           1 - |  TWIDTH :                       5E6 C |
 UC_LOOP :                     1BD8 C |  UNI_CHR :                      101 C |
 UREQ_COM :                     100 C |  USDSS :                        5CC C |
 USRJMP :                       406 C | *USRJPV :                       408 C |
*UT1_PL :                       5A4 C |  VALUE_OFF :                      0 - |
 VARNAME :                      46A C |  VECT_T :                         0 - |
 VEC_CC :                      2BEA C |  VEC_IN :                       4D4 C |
 VEC_LD :                       544 C |  VEC_OUT :                      50E C |
 VEC_SV :                       54A C | *VERSION :                     142F - |
 V_CTLC :                       424 C | *V_CTLCV :                      426 C |
 V_INPT :                       40C C | *V_INPTV :                      40E C |
 V_LOAD :                       418 C | *V_LOADV :                      41A C |
 V_OUTP :                       412 C | *V_OUTPV :                      414 C |
 V_SAVE :                       41E C | *V_SAVEV :                      420 C |
 WA_PIC :                       44C C |  WEXIT :                       2CF4 C |
 WORK_B :                      3B00 - |  WORK_E :                       5EB C |
 WORK_END :                     600 - |  WRMJPV :                       402 C |
 W_PIC :                        4C2 C |

   1161 symbols
     60 unused symbols

 AS V1.42 Beta [Bld 283] - Source File BASIC68K.ASM - Page 3 - 4/10/2025 21:30:24


  Code Pages:
  ----------

STANDARD (0 changed characters)

1 code page

1.00 second assembly time

   9495 lines source file
      6 passes
      0 errors
      0 warnings
